{"aref": "```commonlisp\naref array &rest subscripts => element\n(setf (aref array &rest subscripts) new-element)\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p> <code>subscripts</code> &mdash; a <em>list</em> of <em>valid array indices</em> for the <em>array</em>.  </p><p><code>element</code>, <code>new-element</code> &mdash; an <em>object</em>. </p><p><em>Accesses</em> the <em>array</em> <em>element</em> specified by the <em>subscripts</em>. If no <em>subscripts</em> are supplied and <em>array</em> is zero rank, <code>aref</code> <em>accesses</em> the sole element of <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_aref.htm#aref)", "caadar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caadar)", "cadadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cadadr)", "cadar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cadar)", "cadddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cadddr)", "cadaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cadaar)", "caddar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caddar)", "cadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cadr)", "caddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caddr)", "car": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#car)", "cdaaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdaaar)", "cdaadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdaadr)", "cdaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdaar)", "cdadar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdadar)", "cdaddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdaddr)", "cdadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdadr)", "cdar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdar)", "cddaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cddaar)", "cddadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cddadr)", "caaddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caaddr)", "cddddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cddddr)", "cddar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cddar)", "cdddar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdddar)", "char": "```commonlisp\nchar string index => character\nschar string index => character\n(setf (char string index) new-character)\n(setf (schar string index) new-character)\n```\n\n<p><code>string</code> &mdash; for <code>char</code>, a <em>string</em>; for <code>schar</code>, a <em>simple string</em>. </p><p><code>index</code> &mdash; a <em>valid array index</em> for the <em>string</em>. </p><p><code>character</code>, <code>new-character</code> &mdash; a <em>character</em>. </p><p><code>char</code> and <code>schar</code> <em>access</em> the <em>element</em> of <em>string</em> specified by <em>index</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_.htm#char)", "cdddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdddr)", "compiler-macro-function": "```commonlisp\ncompiler-macro-function name &optional environment => function\n(setf (compiler-macro-function name &optional environment) new-function)\n```\n\n<p><code>name</code> &mdash; a <em>function name</em>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. </p><p><code>function</code>, <code>new-function</code> &mdash; a <em>compiler macro function</em>, or <code>nil</code>. </p><p><em>Accesses</em> the <em>compiler macro function</em> named <em>name</em>, if any, in the <em>environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cmp_ma.htm#compiler-macro-function)", "eighth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#eighth)", "cdr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cdr)", "elt": "```commonlisp\nelt sequence index => object\n(setf (elt sequence index) new-object)\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>index</code> &mdash; a <em>valid sequence index</em> for <em>sequence</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p><em>Accesses</em> the <em>element</em> of <em>sequence</em> specified by <em>index</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_elt.htm#elt)", "fifth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#fifth)", "cddr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#cddr)", "fdefinition": "```commonlisp\nfdefinition function-name => definition\n(setf (fdefinition function-name) new-definition)\n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>.  In the non-<code>setf</code> case, the <em>name</em> must be <em>fbound</em> in the <em>global environment</em>.  </p><p><code>definition</code> &mdash; Current global function definition named by <em>function-name</em>. </p><p><code>new-definition</code> &mdash; a <em>function</em>. </p><p><code>fdefinition</code> <em>accesses</em> the current global function definition named by <em>function-name</em>. The definition may be a <em>function</em> or may be an <em>object</em> representing a <em>special form</em> or <em>macro</em>.  The value returned by <code>fdefinition</code> when <code>fboundp</code> returns true but the <em>function-name</em> denotes a <em>macro</em> or <em>special form</em> is not well-defined, but <code>fdefinition</code> does not signal an error.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fdefin.htm#fdefinition)", "caadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caadr)", "find-class": "```commonlisp\nfind-class symbol &optional errorp environment => class\n(setf (find-class symbol &optional errorp environment) new-class)\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>errorp</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p><code>environment</code>  &mdash;  same as the <code>&amp;environment</code> argument to macro expansion functions and is used to distinguish between compile-time and run-time environments.  The <code>&amp;environment</code> argument has <code>dynamic extent</code>; the consequences are undefined if the <code>&amp;environment</code> argument is referred to outside the <code>dynamic extent</code> of the macro expansion function.  </p><p><code>class</code> &mdash; a <em>class</em> <em>object</em>, or <code>nil</code>. </p><p>Returns the <em>class</em> <em>object</em> named by the <em>symbol</em> in the <em>environment</em>. If there is no such <em>class</em>, <code>nil</code> is returned if <em>errorp</em> is <em>false</em>; otherwise, if <em>errorp</em> is <em>true</em>, an error is signaled. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_c.htm#find-class)", "fill-pointer": "```commonlisp\nfill-pointer vector => fill-pointer\n(setf (fill-pointer vector) new-fill-pointer)\n```\n\n<p><code>vector</code> &mdash; a <em>vector</em> with a <em>fill pointer</em>. </p><p><code>fill-pointer</code>, <code>new-fill-pointer</code> &mdash; a <em>valid fill pointer</em> for the <em>vector</em>. </p><p><em>Accesses</em> the <em>fill pointer</em> of <em>vector</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fill_p.htm#fill-pointer)", "first": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#first)", "get": "```commonlisp\nget symbol indicator &optional default => value\n(setf (get symbol indicator &optional default) new-value)\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>indicator</code> &mdash; an <em>object</em>. </p><p><code>default</code> &mdash; an <em>object</em>. The default is <code>nil</code>. </p><p><code>value</code> &mdash; if the indicated property exists, the <em>object</em> that is its <em>value</em>; otherwise, the specified <em>default</em>. </p><p><code>new-value</code> &mdash; an <em>object</em>. </p><p><code>get</code> finds a <em>property</em> on the <em>property list</em>[2] of <em>symbol</em> whose <em>property indicator</em> is <em>identical</em> to <em>indicator</em>, and returns its corresponding <em>property value</em>.  If there are multiple <em>properties</em>[1] with that <em>property indicator</em>, <code>get</code> uses the first such <em>property</em>.  If there is no <em>property</em> with that <em>property indicator</em>, <em>default</em> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get.htm#get)", "fourth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#fourth)", "getf": "```commonlisp\ngetf plist indicator &optional default => value\n(setf (getf place indicator &optional default) new-value)\n```\n\n<p><code>plist</code> &mdash; a <em>property list</em>. </p><p><code>place</code> &mdash; a <em>place</em>, the <em>value</em> of which is a <em>property list</em>. </p><p><code>indicator</code> &mdash; an <em>object</em>. </p><p><code>default</code> &mdash; an <em>object</em>. The default is <code>nil</code>. </p><p><code>value</code> &mdash; an <em>object</em>. </p><p><code>new-value</code> &mdash; an <em>object</em>. </p><p><code>getf</code> finds a <em>property</em> on the <em>plist</em> whose <em>property indicator</em> is <em>identical</em> to <em>indicator</em>, and returns its corresponding <em>property value</em>.  If there are multiple <em>properties</em>[1] with that <em>property indicator</em>, <code>getf</code> uses the first such <em>property</em>.  If there is no <em>property</em> with that <em>property indicator</em>, <em>default</em> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_getf.htm#getf)", "caaadr": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caaadr)", "gethash": "```commonlisp\ngethash key hash-table &optional default => value, present-p\n(setf (gethash key hash-table &optional default) new-value)\n```\n\n<p><code>key</code> &mdash; an <em>object</em>. </p><p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>default</code> &mdash; an <em>object</em>. The default is <code>nil</code>. </p><p><code>value</code> &mdash; an <em>object</em>. </p><p><code>present-p</code> &mdash; a <em>generalized boolean</em>. </p><p><em>Value</em> is the <em>object</em> in <em>hash-table</em> whose <em>key</em> is the <em>same</em> as <em>key</em> under the <em>hash-table</em>'s equivalence test. If there is no such entry, <em>value</em> is the <em>default</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_gethas.htm#gethash)", "ldb": "```commonlisp\nldb bytespec integer => byte\n(setf (ldb bytespec place) new-byte)\n```\n\n<p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>byte</code>, <code>new-byte</code> &mdash; a non-negative <em>integer</em>. </p><p><code>ldb</code> extracts and returns the <em>byte</em> of <em>integer</em> specified by <em>bytespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ldb.htm#ldb)", "ninth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#ninth)", "logical-pathname-translations": "```commonlisp\nlogical-pathname-translations host => translations\n(setf (logical-pathname-translations host) new-translations)\n```\n\n<p><code>host</code> &mdash; a <em>logical host designator</em>. </p><p><code>translations</code>, <code>new-translations</code> &mdash; a <em>list</em>. </p><p>Returns the host's <em>list</em> of translations. Each translation is a <em>list</em> of at least two elements: <em>from-wildcard</em> and <em>to-wildcard</em>. Any additional elements are <em>implementation-defined</em>. <em>From-wildcard</em> is a <em>logical pathname</em> whose host is <em>host</em>. <em>To-wildcard</em> is a <em>pathname</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logica.htm#logical-pathname-translations)", "mask-field": "```commonlisp\nmask-field bytespec integer => masked-integer\n(setf (mask-field bytespec place) new-masked-integer)\n```\n\n<p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>masked-integer</code>, <code>new-masked-integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>mask-field</code> performs a ``mask'' operation on <em>integer</em>. It returns an <em>integer</em> that has the same bits as <em>integer</em> in the <em>byte</em> specified by <em>bytespec</em>, but that has zero-bits everywhere else. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mask_f.htm#mask-field)", "macro-function": "```commonlisp\nmacro-function symbol &optional environment => function\n(setf (macro-function symbol &optional environment) new-function)\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p> <code>environment</code> &mdash; an <em>environment</em> <em>object</em>.  </p><p><code>function</code> &mdash; a <em>macro function</em> or <code>nil</code>. </p><p><code>new-function</code> &mdash; a <em>macro function</em>. </p><p>Determines whether <em>symbol</em> has a function definition as a macro in the specified <em>environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_macro_.htm#macro-function)", "readtable-case": "```commonlisp\nreadtable-case readtable => mode\n(setf (readtable-case readtable) mode)\n```\n\n<p><code>readtable</code> &mdash; a <em>readtable</em>. </p><p><code>mode</code> &mdash; a <em>case sensitivity mode</em>. </p><p><em>Accesses</em> the <em>readtable case</em> of <em>readtable</em>, which affects the way in which the <em>Lisp Reader</em> reads <em>symbols</em> and the way in which the <em>Lisp Printer</em> writes <em>symbols</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rdtabl.htm#readtable-case)", "nth": "```commonlisp\nnth n list => object\n(setf (nth n list) new-object)\n```\n\n<p><code>n</code> &mdash; a non-negative <em>integer</em>. </p><p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p><code>nth</code> locates the <em>n</em>th element of <em>list</em>, where the <em>car</em> of the <em>list</em> is the ``zeroth'' element.  Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_nth.htm#nth)", "second": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#second)", "rest": "```commonlisp\nrest list => tail\n(setf (rest list) new-tail)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>tail</code> &mdash; an <em>object</em>. </p><p><code>rest</code> performs the same operation as <code>cdr</code>, but mnemonically complements <code>first</code>. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rest.htm#rest)", "schar": "```commonlisp\nchar string index => character\nschar string index => character\n(setf (char string index) new-character)\n(setf (schar string index) new-character)\n```\n\n<p><code>string</code> &mdash; for <code>char</code>, a <em>string</em>; for <code>schar</code>, a <em>simple string</em>. </p><p><code>index</code> &mdash; a <em>valid array index</em> for the <em>string</em>. </p><p><code>character</code>, <code>new-character</code> &mdash; a <em>character</em>. </p><p><code>char</code> and <code>schar</code> <em>access</em> the <em>element</em> of <em>string</em> specified by <em>index</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_.htm#schar)", "row-major-aref": "```commonlisp\nrow-major-aref array index => element\n(setf (row-major-aref array index) new-element)\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p> <code>index</code> &mdash; a <em>valid array row-major index</em> for the <em>array</em>.  </p><p><code>element</code>, <code>new-element</code> &mdash; an <em>object</em>. </p><p>Considers <em>array</em> as a <em>vector</em> by viewing its <em>elements</em> in row-major order, and returns the <em>element</em> of that <em>vector</em> which is referred to by the given <em>index</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_row_ma.htm#row-major-aref)", "sbit": "```commonlisp\nbit bit-array &rest subscripts => bit\nsbit bit-array &rest subscripts => bit\n(setf (bit bit-array &rest subscripts) new-bit)\n(setf (sbit bit-array &rest subscripts) new-bit)\n```\n\n<p><code>bit-array</code> &mdash; for <code>bit</code>, a <em>bit array</em>; for <code>sbit</code>, a <em>simple bit array</em>. </p><p><code>subscripts</code> &mdash; a <em>list</em> of <em>valid array indices</em> for the <em>bit-array</em>. </p><p><code>bit</code> &mdash; a <em>bit</em>. </p><p><code>bit</code> and <code>sbit</code> <em>access</em> the <em>bit-array</em> <em>element</em> specified by <em>subscripts</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_sb.htm#sbit)", "sixth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#sixth)", "seventh": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#seventh)", "subseq": "```commonlisp\nsubseq sequence start &optional end => subsequence\n(setf (subseq sequence start &optional end) new-subsequence)\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The default for <em>end</em> is <code>nil</code>.   </p><p><code>subsequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>new-subsequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>subseq</code> creates a <em>sequence</em> that is a copy of the subsequence of <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_subseq.htm#subseq)", "svref": "```commonlisp\nsvref simple-vector index => element\n(setf (svref simple-vector index) new-element)\n```\n\n<p><code>simple-vector</code> &mdash; a <em>simple vector</em>. </p><p><code>index</code> &mdash; a <em>valid array index</em> for the <em>simple-vector</em>. </p><p><code>element</code>, <code>new-element</code> &mdash; an <em>object</em> (whose <em>type</em> is a <em>subtype</em> of the <em>array element type</em> of the <em>simple-vector</em>). </p><p><em>Accesses</em> the <em>element</em> of <em>simple-vector</em> specified by <em>index</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_svref.htm#svref)", "symbol-function": "```commonlisp\nsymbol-function symbol => contents\n(setf (symbol-function symbol) new-contents)\n```\n\n<p> <code>symbol</code> &mdash; a <em>symbol</em>.  </p><p><code>contents</code> &mdash;   If the <em>symbol</em> is globally defined as a <em>macro</em> or a <em>special operator</em>, an <em>object</em> of <em>implementation-dependent</em> nature and identity is returned. If the <em>symbol</em> is not globally defined as either a <em>macro</em> or a <em>special operator</em>, and if the <em>symbol</em> is <em>fbound</em>, a <em>function</em> <em>object</em> is returned.  </p><p> <code>new-contents</code> &mdash; a <em>function</em>.  </p><p><em>Accesses</em> the <em>symbol</em>'s <em>function cell</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symb_1.htm#symbol-function)", "tenth": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#tenth)", "symbol-value": "```commonlisp\nsymbol-value symbol => value\n(setf (symbol-value symbol) new-value)\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em> that must have a <em>value</em>. </p><p><code>value</code>, <code>new-value</code> &mdash; an <em>object</em>. </p><p><em>Accesses</em> the <em>symbol</em>'s <em>value cell</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symb_5.htm#symbol-value)", "symbol-plist": "```commonlisp\nsymbol-plist symbol => plist\n(setf (symbol-plist symbol) new-plist)\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>plist</code>, <code>new-plist</code> &mdash; a <em>property list</em>. </p><p><em>Accesses</em> the <em>property list</em> of <em>symbol</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symb_4.htm#symbol-plist)", "third": "```commonlisp\nfirst list => object\nsecond list => object\nthird list => object\nfourth list => object\nfifth list => object\nsixth list => object\nseventh list => object\neighth list => object\nninth list => object\ntenth list => object\n(setf (first list) new-object)\n(setf (second list) new-object)\n(setf (third list) new-object)\n(setf (fourth list) new-object)\n(setf (fifth list) new-object)\n(setf (sixth list) new-object)\n(setf (seventh list) new-object)\n(setf (eighth list) new-object)\n(setf (ninth list) new-object)\n(setf (tenth list) new-object)\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>object</code>, <code>new-object</code> &mdash; an <em>object</em>. </p><p>The functions <code>first</code>, <code>second</code>, <code>third</code>, <code>fourth</code>, <code>fifth</code>, <code>sixth</code>, <code>seventh</code>, <code>eighth</code>, <code>ninth</code>, and <code>tenth</code> <em>access</em> the first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth <em>elements</em> of <em>list</em>, respectively. Specifically, </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_firstc.htm#third)", "standard-object": "<p><code>standard-object</code>, <code>t</code> </p><p>The <em>class</em> <code>standard-object</code> is an <em>instance</em> of <code>standard-class</code> and is a <em>superclass</em> of every <em>class</em> that is an <em>instance</em> of <code>standard-class</code> except itself. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_std_ob.htm#standard-object)", "standard": "\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/07_ffb.htm#standard)", "structure-object": "<p><code>structure-object</code>, <code>t</code>  </p><p>The <em>class</em> <code>structure-object</code> is an <em>instance</em> of <code>structure-class</code> and is a <em>superclass</em> of every <em>class</em> that is an <em>instance</em> of <code>structure-class</code> except itself, and is a <em>superclass</em> of every <em>class</em> that is defined by <code>defstruct</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_stu_ob.htm#structure-object)", "arithmetic-error": "<p><code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>arithmetic-error</code> consists of error conditions that occur during arithmetic operations. The operation and operands are initialized with the initialization arguments named :<code>operation</code> and <code>:operands</code> to <code>make-condition</code>, and are <em>accessed</em> by the functions <code>arithmetic-error-operation</code> and <code>arithmetic-error-operands</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_arithm.htm#arithmetic-error)", "condition": "<p><code>condition</code>, <code>t</code> </p><p>All types of <em>conditions</em>, whether error or non-error, must inherit from this <em>type</em>.     </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_cnd.htm#condition)", "cell-error": "<p><code>cell-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>cell-error</code> consists of error conditions that occur during a location <em>access</em>. The name of the offending cell is initialized by the :<code>name</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>cell-error-name</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_cell_e.htm#cell-error)", "control-error": "<p><code>control-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>control-error</code> consists of error conditions that result from invalid dynamic transfers of control in a program. The errors that result from giving <code>throw</code> a tag that is not active or from giving <code>go</code> or <code>return-from</code> a tag that is no longer dynamically available are of <em>type</em> <code>control-error</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_contro.htm#control-error)", "division-by-zero": "<p><code>division-by-zero</code>, <code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>division-by-zero</code> consists of error conditions that occur because of division by zero. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_divisi.htm#division-by-zero)", "file-error": "<p><code>file-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>file-error</code> consists of error conditions that occur during an attempt to open or close a file, or during some low-level transactions with a file system. The ``offending pathname'' is initialized by the :<code>pathname</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>file-error-pathname</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_file_e.htm#file-error)", "caaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caaar)", "floating-point-inexact": "<p><code>floating-point-inexact</code>, <code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>floating-point-inexact</code> consists of error conditions that occur because of certain floating point traps. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_floa_1.htm#floating-point-inexact)", "caaaar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caaaar)", "floating-point-invalid-operation": "<p><code>floating-point-invalid-operation</code>, <code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>floating-point-invalid-operation</code> consists of error conditions that occur because of certain floating point traps. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_floati.htm#floating-point-invalid-operation)", "floating-point-overflow": "<p><code>floating-point-overflow</code>, <code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>floating-point-overflow</code> consists of error conditions that occur because of floating-point overflow. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_floa_2.htm#floating-point-overflow)", "parse-error": "<p><code>parse-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>parse-error</code> consists of error conditions that are related to parsing. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_parse_.htm#parse-error)", "package-error": "<p><code>package-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>package-error</code> consists of <em>error</em> <em>conditions</em> related to operations on <em>packages</em>. The offending <em>package</em> (or <em>package</em> <em>name</em>) is initialized by the :<code>package</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>package-error-package</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_pkg_er.htm#package-error)", "program-error": "<p><code>program-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>program-error</code> consists of error conditions related to incorrect program syntax. The errors that result from naming a <em>go tag</em> or a <em>block tag</em> that is not lexically apparent are of <em>type</em> <code>program-error</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_progra.htm#program-error)", "serious-condition": "<p><code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>All <em>conditions</em> serious enough to require interactive intervention if not handled should inherit from the <em>type</em> <code>serious-condition</code>. This condition type is provided primarily so that it may be included as a <em>superclass</em> of other <em>condition</em> <em>types</em>; it is not intended to be signaled directly. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_seriou.htm#serious-condition)", "print-not-readable": "<p><code>print-not-readable</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>print-not-readable</code> consists of error conditions that occur during output while <code>*print-readably*</code> is <em>true</em>, as a result of attempting to write a printed representation with the <em>Lisp printer</em> that would not be correctly read back with the <em>Lisp reader</em>. The object which could not be printed is initialized by the :<code>object</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>print-not-readable-object</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_pr_not.htm#print-not-readable)", "caar": "```commonlisp\ncar x => object\ncdr x => object\ncaar x => object\ncadr x => object\ncdar x => object\ncddr x => object\ncaaar x => object\ncaadr x => object\ncadar x => object\ncaddr x => object\ncdaar x => object\ncdadr x => object\ncddar x => object\ncdddr x => object\ncaaaar x => object\ncaaadr x => object\ncaadar x => object\ncaaddr x => object\ncadaar x => object\ncadadr x => object\ncaddar x => object\ncadddr x => object\ncdaaar x => object\ncdaadr x => object\ncdadar x => object\ncdaddr x => object\ncddaar x => object\ncddadr x => object\ncdddar x => object\ncddddr x => object\n(setf (car x) new-object)\n(setf (cdr x) new-object)\n(setf (caar x) new-object)\n(setf (cadr x) new-object)\n(setf (cdar x) new-object)\n(setf (cddr x) new-object)\n(setf (caaar x) new-object)\n(setf (caadr x) new-object)\n(setf (cadar x) new-object)\n(setf (caddr x) new-object)\n(setf (cdaar x) new-object)\n(setf (cdadr x) new-object)\n(setf (cddar x) new-object)\n(setf (cdddr x) new-object)\n(setf (caaaar x) new-object)\n(setf (caaadr x) new-object)\n(setf (caadar x) new-object)\n(setf (caaddr x) new-object)\n(setf (cadaar x) new-object)\n(setf (cadadr x) new-object)\n(setf (caddar x) new-object)\n(setf (cadddr x) new-object)\n(setf (cdaaar x) new-object)\n(setf (cdaadr x) new-object)\n(setf (cdadar x) new-object)\n(setf (cdaddr x) new-object)\n(setf (cddaar x) new-object)\n(setf (cddadr x) new-object)\n(setf (cdddar x) new-object)\n(setf (cddddr x) new-object)\n```\n\n<p><code>x</code> &mdash; a <em>list</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>new-object</code> &mdash; an <em>object</em>. </p><p>If <em>x</em> is a <em>cons</em>, <code>car</code> returns the <em>car</em> of that <em>cons</em>. If <em>x</em> is <code>nil</code>, <code>car</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_car_c.htm#caar)", "simple-type-error": "<p><code>simple-type-error</code>, <code>simple-condition</code>, <code>type-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code>  </p><p><em>Conditions</em> of <em>type</em> <code>simple-type-error</code> are like <em>conditions</em> of <em>type</em> <code>type-error</code>, except that they provide an alternate mechanism for specifying how the <em>condition</em> is to be <em>reported</em>; see the <em>type</em> <code>simple-condition</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_smp_tp.htm#simple-type-error)", "simple-error": "<p><code>simple-error</code>, <code>simple-condition</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code>  </p><p>The <em>type</em> <code>simple-error</code> consists of <em>conditions</em> that are signaled by <code>error</code> or <code>cerror</code> when a <em>format control</em> is supplied as the function's first argument. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_smp_er.htm#simple-error)", "simple-condition": "<p><code>simple-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>simple-condition</code> represents <em>conditions</em> that are signaled by <code>signal</code> whenever a <em>format-control</em> is supplied as the function's first argument.  The <em>format control</em> and <em>format arguments</em> are initialized with the initialization arguments named :<code>format-control</code>  and <code>:format-arguments</code> to <code>make-condition</code>, and are <em>accessed</em> by the <em>functions</em>  <code>simple-condition-format-control</code>  and <code>simple-condition-format-arguments</code>. If format arguments are not supplied to <code>make-condition</code>, <code>nil</code> is used as a default. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_smp_cn.htm#simple-condition)", "simple-warning": "<p><code>simple-warning</code>, <code>simple-condition</code>, <code>warning</code>, <code>condition</code>, <code>t</code>  </p><p>The <em>type</em> <code>simple-warning</code> represents <em>conditions</em> that are signaled by <code>warn</code> whenever a  <em>format control</em>  is supplied as the function's first argument. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_smp_wa.htm#simple-warning)", "stream-error": "<p><code>stream-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>stream-error</code> consists of error conditions that are related to receiving input from or sending output to a <em>stream</em>. The ``offending stream'' is initialized by the :<code>stream</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>stream-error-stream</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_stm_er.htm#stream-error)", "style-warning": "<p><code>style-warning</code>, <code>warning</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>style-warning</code> includes those <em>conditions</em> that represent <em>situations</em> involving <em>code</em> that is <em>conforming code</em> but that is nevertheless considered to be faulty or substandard. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_style_.htm#style-warning)", "storage-condition": "<p><code>storage-condition</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>storage-condition</code> consists of serious conditions that relate to problems with memory management that are potentially due to <em>implementation-dependent</em> limits rather than semantic errors in <em>conforming programs</em>, and that typically warrant entry to the debugger if not handled. Depending on the details of the <em>implementation</em>, these might include such problems as stack overflow, memory region overflow, and storage exhausted. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_storag.htm#storage-condition)", "type-error": "<p><code>type-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>type-error</code> represents a situation in which an <em>object</em> is not of the expected type. The ``offending datum'' and ``expected type'' are initialized by the initialization arguments named :<code>datum</code> and <code>:expected-type</code> to <code>make-condition</code>, and are <em>accessed</em> by the functions <code>type-error-datum</code> and <code>type-error-expected-type</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_tp_err.htm#type-error)", "unbound-slot": "<p><code>unbound-slot</code>, <code>cell-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>object</em> having the unbound slot is initialized by the :<code>instance</code>initialization argument to <code>make-condition</code>, and is <em>accessed</em> by the <em>function</em> <code>unbound-slot-instance</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_unboun.htm#unbound-slot)", "undefined-function": "<p><code>undefined-function</code>, <code>cell-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>undefined-function</code> consists of <em>error</em> <em>conditions</em> that represent attempts to <em>read</em> the definition of an <em>undefined function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_undefi.htm#undefined-function)", "warning": "<p><code>warning</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>warning</code> consists of all types of warnings. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_warnin.htm#warning)", "reader-error": "<p><code>reader-error</code>, <code>parse-error</code>, <code>stream-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>reader-error</code> consists of error conditions that are related to tokenization and parsing done by the <em>Lisp reader</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_rder_e.htm#reader-error)", "array-dimension-limit": "<p>A positive  <em>fixnum</em>,  the exact magnitude of which is <em>implementation-dependent</em>, but which is not less than <code>1024</code>. </p><p>The upper exclusive bound on each individual <em>dimension</em> of an <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ar_dim.htm#array-dimension-limit)", "array-total-size-limit": "<p>A positive  <em>fixnum</em>,  the exact magnitude of which is <em>implementation-dependent</em>, but which is not less than <code>1024</code>. </p><p>The upper exclusive bound on the <em>array total size</em> of an <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ar_tot.htm#array-total-size-limit)", "unbound-variable": "<p><code>unbound-variable</code>, <code>cell-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>unbound-variable</code> consists of <em>error</em> <em>conditions</em> that represent attempts to <em>read</em> the <em>value</em> of an <em>unbound variable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_unbo_1.htm#unbound-variable)", "array-rank-limit": "<p>A positive  <em>fixnum</em>,  the exact magnitude of which is <em>implementation-dependent</em>, but which is not less than <code>8</code>. </p><p>The upper exclusive bound on the <em>rank</em> of an <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ar_ran.htm#array-rank-limit)", "boole-andc2": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-andc2)", "boole-c2": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-c2)", "boole-clr": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-clr)", "boole-2": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-2)", "boole-eqv": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-eqv)", "boole-ior": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-ior)", "boole-nand": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-nand)", "boole-nor": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-nor)", "end-of-file": "<p><code>end-of-file</code>, <code>stream-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>end-of-file</code> consists of error conditions related to read operations that are done on <em>streams</em> that have no more data. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_end_of.htm#end-of-file)", "boole-orc2": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-orc2)", "boole-andc1": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-andc1)", "call-arguments-limit": "<p>An integer not smaller than <code>50</code> and at least as great as the <em>value</em> of <code>lambda-parameters-limit</code>, the exact magnitude of which is <em>implementation-dependent</em>. </p><p>The upper exclusive bound on the number of <em>arguments</em> that may be passed to a <em>function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_call_a.htm#call-arguments-limit)", "boole-c1": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-c1)", "boole-xor": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-xor)", "char-code-limit": "<p>A non-negative <em>integer</em>, the exact magnitude of which is <em>implementation-dependent</em>, but which is not less than <code>96</code> (the number of <em>standard characters</em>). </p><p>The upper exclusive bound on the <em>value</em> returned by the <em>function</em> <code>char-code</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_char_c.htm#char-code-limit)", "boole-and": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-and)", "double-float-negative-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#double-float-negative-epsilon)", "internal-time-units-per-second": "<p>A positive <em>integer</em>, the magnitude of which is <em>implementation-dependent</em>. </p><p>The number of <em>internal time units</em> in one second. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_intern.htm#internal-time-units-per-second)", "double-float-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#double-float-epsilon)", "lambda-list-keywords": "<p>a <em>list</em>, the <em>elements</em> of which are <em>implementation-dependent</em>, but which must contain at least the <em>symbols</em> <code>&amp;allow-other-keys</code>, <code>&amp;aux</code>, <code>&amp;body</code>, <code>&amp;environment</code>, <code>&amp;key</code>, <code>&amp;optional</code>, <code>&amp;rest</code>, and <code>&amp;whole</code>. </p><p>A <em>list</em> of all the <em>lambda list keywords</em> used in the <em>implementation</em>, including the additional ones used only by <em>macro</em> definition <em>forms</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_lambda.htm#lambda-list-keywords)", "boole-1": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-1)", "lambda-parameters-limit": "<p><em>implementation-dependent</em>, but not smaller than <code>50</code>. </p><p>A positive <em>integer</em> that is the upper exclusive bound on the number of <em>parameter</em> <em>names</em> that can appear in a single <em>lambda list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_lamb_1.htm#lambda-parameters-limit)", "least-negative-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-double-float)", "boole-set": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-set)", "least-negative-normalized-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-normalized-double-float)", "least-negative-normalized-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-normalized-short-float)", "least-negative-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-single-float)", "least-positive-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-double-float)", "least-positive-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-long-float)", "least-positive-normalized-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-normalized-double-float)", "least-negative-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-short-float)", "least-positive-normalized-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-normalized-long-float)", "long-float-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#long-float-epsilon)", "least-negative-normalized-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-normalized-long-float)", "least-negative-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-long-float)", "long-float-negative-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#long-float-negative-epsilon)", "least-positive-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-short-float)", "least-positive-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-single-float)", "most-negative-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-negative-single-float)", "most-negative-fixnum": "<p><em>implementation-dependent</em>. </p><p><code>most-positive-fixnum</code> is that <em>fixnum</em> closest in value to positive infinity provided by the implementation,  and greater than or equal to both 2^15 - 1 and <code>array-dimension-limit</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_p.htm#most-negative-fixnum)", "most-positive-fixnum": "<p><em>implementation-dependent</em>. </p><p><code>most-positive-fixnum</code> is that <em>fixnum</em> closest in value to positive infinity provided by the implementation,  and greater than or equal to both 2^15 - 1 and <code>array-dimension-limit</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_p.htm#most-positive-fixnum)", "most-negative-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-negative-double-float)", "most-negative-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-negative-long-float)", "most-negative-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-negative-short-float)", "floating-point-underflow": "<p><code>floating-point-underflow</code>, <code>arithmetic-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>floating-point-underflow</code> consists of error conditions that occur because of floating-point underflow. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/e_floa_3.htm#floating-point-underflow)", "most-positive-double-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-positive-double-float)", "multiple-values-limit": "<p>An <em>integer</em> not smaller than <code>20</code>, the exact magnitude of which is <em>implementation-dependent</em>. </p><p>The upper exclusive bound on the number of <em>values</em> that may be returned from a <em>function</em>,  bound or assigned by <code>multiple-value-bind</code> or <code>multiple-value-setq</code>, or passed as a first argument to <code>nth-value</code>. (If these individual limits might differ, the minimum value is used.)  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_multip.htm#multiple-values-limit)", "short-float-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#short-float-epsilon)", "pi": "<p>an <em>implementation-dependent</em> <em>long float</em>. </p><p>The best <em>long float</em> approximation to the mathematical constant &lt;PI&gt;. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pi.htm#pi)", "short-float-negative-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#short-float-negative-epsilon)", "least-positive-normalized-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-normalized-short-float)", "least-positive-normalized-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-positive-normalized-single-float)", "most-positive-long-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-positive-long-float)", "single-float-negative-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#single-float-negative-epsilon)", "single-float-epsilon": "<p><em>implementation-dependent</em>. </p><p>The value of each of the constants <code>short-float-epsilon</code>, <code>single-float-epsilon</code>, <code>double-float-epsilon</code>, and <code>long-float-epsilon</code> is the smallest positive <em>float</em> &lt;EPSILON&gt; of the given format, such that the following expression is <em>true</em> when evaluated: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_short_.htm#single-float-epsilon)", "compilation-speed": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#compilation-speed)", "declaration": "```commonlisp\n(declaration name*) \n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><em>proclamation</em> only </p><p>Advises the compiler that each <em>name</em> is a valid but potentially non-standard declaration name. The purpose of this is to tell one compiler not to issue warnings for declarations meant for another compiler or other program processor. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_declar.htm#declaration)", "debug": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#debug)", "ignore": "```commonlisp\n(ignore {var | (function fn)}*) \n(ignorable {var | (function fn)}*) \n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>fn</code> &mdash; a <em>function</em> <em>name</em>. </p><p><em>declaration</em> </p><p> The <code>ignore</code> and <code>ignorable</code> declarations refer to <em>for-value</em> <em>references</em> to <em>variable</em> <em>bindings</em> for the <em>vars</em> and to <em>function</em> <em>bindings</em> for the <em>fns</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_ignore.htm#ignore)", "ftype": "```commonlisp\n(ftype type function-name*) \n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p><code>type</code> &mdash; a <em>type specifier</em>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Specifies that the <em>functions</em> named by <em>function-names</em> are of the functional type <em>type</em>. For example: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_ftype.htm#ftype)", "least-negative-normalized-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#least-negative-normalized-single-float)", "dynamic-extent": "```commonlisp\n(dynamic-extent [[var* | (function fn)*]]) \n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>fn</code> &mdash; a <em>function</em> <em>name</em>. </p><p><em>declaration</em> </p><p>In some containing <em>form</em>, <em>F</em>, this declaration asserts for each <em>vari</em> (which need not be bound by <em>F</em>), and for each <em>value</em> <em>vij</em> that <em>vari</em> takes on, and for each <em>object</em> <em>xijk</em> that is an <em>otherwise inaccessible part</em> of <em>vij</em> at any time when <em>vij</em> becomes the value of <em>vari</em>, that just after the execution of <em>F</em> terminates, <em>xijk</em> is either <em>inaccessible</em> (if <em>F</em> established a <em>binding</em> for <em>vari</em>) or still an <em>otherwise inaccessible part</em> of the current value of <em>vari</em> (if <em>F</em> did not establish a <em>binding</em> for <em>vari</em>).  The same relation holds for each <em>fni</em>, except that the <em>bindings</em> are in the <em>function</em> <em>namespace</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_dynami.htm#dynamic-extent)", "ignorable": "```commonlisp\n(ignore {var | (function fn)}*) \n(ignorable {var | (function fn)}*) \n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>fn</code> &mdash; a <em>function</em> <em>name</em>. </p><p><em>declaration</em> </p><p> The <code>ignore</code> and <code>ignorable</code> declarations refer to <em>for-value</em> <em>references</em> to <em>variable</em> <em>bindings</em> for the <em>vars</em> and to <em>function</em> <em>bindings</em> for the <em>fns</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_ignore.htm#ignorable)", "optimize": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#optimize)", "inline": "```commonlisp\n(inline function-name*) \n(notinline function-name*) \n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p><code>inline</code> specifies that it is desirable for the compiler to produce inline calls to the <em>functions</em> named by <em>function-names</em>; that is, the code for a specified <em>function-name</em>  should be integrated into the calling routine, appearing ``in line'' in place of a procedure call. A compiler is free to ignore this declaration. <code>inline</code> declarations never apply to variable <em>bindings</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_inline.htm#inline)", "special": "```commonlisp\n(special var*) \n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Specifies that all of the <em>vars</em> named are dynamic. This specifier affects variable <em>bindings</em> and affects references. All variable <em>bindings</em> affected are made to be dynamic <em>bindings</em>, and affected variable references refer to the current dynamic <em>binding</em>. For example: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_specia.htm#special)", "safety": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#safety)", "speed": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#speed)", "space": "```commonlisp\n(optimize {quality | (quality value)}*) \n```\n\n<p><code>quality</code> &mdash; an <em>optimize quality</em>. </p><p><code>value</code> &mdash; one of the <em>integers</em> <code>0</code>, <code>1</code>, <code>2</code>, or <code>3</code>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Advises the compiler that each <em>quality</em> should be given attention according to the specified corresponding <em>value</em>. Each <em>quality</em> must be a <em>symbol</em> naming an <em>optimize quality</em>; the names and meanings of the standard <em>optimize qualities</em> are shown in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_optimi.htm#space)", "notinline": "```commonlisp\n(inline function-name*) \n(notinline function-name*) \n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p><code>inline</code> specifies that it is desirable for the compiler to produce inline calls to the <em>functions</em> named by <em>function-names</em>; that is, the code for a specified <em>function-name</em>  should be integrated into the calling routine, appearing ``in line'' in place of a procedure call. A compiler is free to ignore this declaration. <code>inline</code> declarations never apply to variable <em>bindings</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/d_inline.htm#notinline)", "1+": "```commonlisp\n1+ number => successor\n1- number => predecessor\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>successor</code>, <code>predecessor</code> &mdash; a <em>number</em>. </p><p><code>1+</code> returns a <em>number</em> that is one more than its argument <em>number</em>. <code>1-</code> returns a <em>number</em> that is one less than its argument <em>number</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_1pl_1_.htm#1PL)", "<": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#LT)", "1-": "```commonlisp\n1+ number => successor\n1- number => predecessor\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>successor</code>, <code>predecessor</code> &mdash; a <em>number</em>. </p><p><code>1+</code> returns a <em>number</em> that is one more than its argument <em>number</em>. <code>1-</code> returns a <em>number</em> that is one less than its argument <em>number</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_1pl_1_.htm#1-)", "abs": "```commonlisp\nabs number => absolute-value\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>absolute-value</code> &mdash; a non-negative <em>real</em>. </p><p><code>abs</code> returns the absolute value of <em>number</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_abs.htm#abs)", "acons": "```commonlisp\nacons key datum alist => new-alist\n```\n\n<p><code>key</code> &mdash; an <em>object</em>. </p><p><code>datum</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>new-alist</code> &mdash; an <em>association list</em>. </p><p>Creates a <em>fresh</em> <em>cons</em>, the <em>cdr</em> of which is <em>alist</em> and the <em>car</em> of which is another <em>fresh</em> <em>cons</em>, the <em>car</em> of which is <em>key</em> and the <em>cdr</em> of which is <em>datum</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_acons.htm#acons)", "=": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#EQ)", "/=": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#SLEQ)", "acosh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#acosh)", "<=": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#LTEQ)", ">=": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#GTEQ)", "adjustable-array-p": "```commonlisp\nadjustable-array-p array => generalized-boolean\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns true if and only if <code>adjust-array</code> could return a <em>value</em> which is <em>identical</em> to <em>array</em> when given that <em>array</em> as its first <em>argument</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_adju_1.htm#adjustable-array-p)", "acos": "```commonlisp\nasin number => radians\nacos number => radians\natan number1 &optional number2 => radians\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>number1</code> &mdash; a <em>number</em> if <em>number2</em> is not supplied, or a <em>real</em> if <em>number2</em> is supplied. </p><p><code>number2</code> &mdash; a <em>real</em>. </p><p><code>radians</code> &mdash; a <em>number</em> (of radians). </p><p><code>asin</code>, <code>acos</code>, and <code>atan</code> compute the arc sine, arc cosine, and arc tangent respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_asin_.htm#acos)", "adjoin": "```commonlisp\nadjoin item list &key key test test-not => new-list\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>new-list</code> &mdash; a <em>list</em>. </p><p>Tests whether <em>item</em> is the same as an existing element of <em>list</em>. If the <em>item</em> is not an existing element, <code>adjoin</code> adds it to <em>list</em> (as if by <code>cons</code>) and returns the resulting <em>list</em>; otherwise, nothing is added and the original <em>list</em> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_adjoin.htm#adjoin)", "alpha-char-p": "```commonlisp\nalpha-char-p character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>character</em> is an <em>alphabetic</em>[1] <em>character</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_alpha_.htm#alpha-char-p)", "alphanumericp": "```commonlisp\nalphanumericp character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>character</em> is an <em>alphabetic</em>[1] <em>character</em> or a <em>numeric</em> <em>character</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_alphan.htm#alphanumericp)", ">": "```commonlisp\n= &rest numbers+ => generalized-boolean\n/= &rest numbers+ => generalized-boolean\n< &rest numbers+ => generalized-boolean\n> &rest numbers+ => generalized-boolean\n<= &rest numbers+ => generalized-boolean\n>= &rest numbers+ => generalized-boolean\n```\n\n<p><code>number</code> &mdash; for <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>: a <em>real</em>; for <code>=</code>, <code>/=</code>: a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>=</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> perform arithmetic comparisons on their arguments as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq_sle.htm#GT)", "adjust-array": "```commonlisp\nadjust-array array new-dimensions &key element-type initial-element initial-contents fill-pointer displaced-to displaced-index-offset\n => adjusted-array\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>new-dimensions</code> &mdash; a <em>valid array dimension</em> or a <em>list</em> of <em>valid array dimensions</em>. </p><p><code>element-type</code> &mdash; a <em>type specifier</em>. </p><p><code>initial-element</code> &mdash; an <em>object</em>. <em>Initial-element</em> must not be supplied if either <em>initial-contents</em> or <em>displaced-to</em> is supplied. </p><p><code>initial-contents</code> &mdash; an <em>object</em>. If <em>array</em> has rank greater than zero, then <em>initial-contents</em> is composed of nested <em>sequences</em>, the depth of which must equal the rank of <em>array</em>. Otherwise, <em>array</em> is zero-dimensional and <em>initial-contents</em> supplies the single element. <em>initial-contents</em> must not be supplied if either <em>initial-element</em> or <em>displaced-to</em> is given. </p><p><code>fill-pointer</code> &mdash; a <em>valid fill pointer</em> for the <em>array</em> to be created, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>displaced-to</code> &mdash; an <em>array</em> or <code>nil</code>. <em>initial-elements</em> and <em>initial-contents</em> must not be supplied if <em>displaced-to</em> is supplied. </p><p> <code>displaced-index-offset</code> &mdash; an <em>object</em> of <em>type</em> <code>(fixnum 0 </code><em>n</em><code>)</code> where <em>n</em> is <code>(array-total-size </code><em>displaced-to</em><code>)</code>. <em>displaced-index-offset</em> may be supplied only if <em>displaced-to</em> is supplied.  </p><p><code>adjusted-array</code> &mdash; an <em>array</em>. </p><p><code>adjust-array</code> changes the dimensions or elements of <em>array</em>. The result is an <em>array</em> of the same <em>type</em> and rank as <em>array</em>, that is either the modified <em>array</em>, or a newly created <em>array</em> to which <em>array</em> can be displaced, and that has the given <em>new-dimensions</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_adjust.htm#adjust-array)", "append": "```commonlisp\nappend &rest lists => result\n```\n\n<p> <code>list</code> &mdash; each must be a <em>proper list</em> except the last, which may be any <em>object</em>.  </p><p><code>result</code> &mdash; an <em>object</em>. This will be a <em>list</em> unless the last <em>list</em> was not a <em>list</em> and all preceding <em>lists</em> were <em>null</em>. </p><p><code>append</code> returns a new <em>list</em> that is the concatenation of the copies. <em>lists</em> are left unchanged; the <em>list structure</em> of each of <em>lists</em> except the last is copied. The last argument is not copied; it becomes the <em>cdr</em> of the final <em>dotted pair</em> of the concatenation of the preceding <em>lists</em>, or is returned directly if there are no preceding <em>non-empty</em> <em>lists</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_append.htm#append)", "apply": "```commonlisp\napply function &rest args+ => result*\n```\n\n<p> <code>function</code> &mdash; a <em>function designator</em>.  </p><p><code>args</code> &mdash; a <em>spreadable argument list designator</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by <em>function</em>. </p><p><em>Applies</em> the <em>function</em> to the <em>args</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_apply.htm#apply)", "arithmetic-error-operands": "```commonlisp\narithmetic-error-operands condition => operands\narithmetic-error-operation condition => operation\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>arithmetic-error</code>. </p><p><code>operands</code> &mdash; a <em>list</em>. </p><p><code>operation</code> &mdash; a <em>function designator</em>. </p><p><code>arithmetic-error-operands</code> returns a <em>list</em> of the operands which were used in the offending call to the operation that signaled the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_arithm.htm#arithmetic-error-operands)", "array-dimension": "```commonlisp\narray-dimension array axis-number => dimension\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>axis-number</code> &mdash; an <em>integer</em> greater than or equal to zero and less than the <em>rank</em> of the <em>array</em>. </p><p><code>dimension</code> &mdash; a non-negative <em>integer</em>. </p><p><code>array-dimension</code> returns the <em>axis-number</em> <em>dimension</em>[1] of <em>array</em>. (Any <em>fill pointer</em> is ignored.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_dim.htm#array-dimension)", "apropos": "```commonlisp\napropos string &optional package => <no values>\napropos-list string &optional package => symbols\n```\n\n<p><code>string</code> &mdash; a <em>string designator</em>. </p><p><code>package</code> &mdash; a <em>package designator</em> or <code>nil</code>. The default is <code>nil</code>. </p><p><code>symbols</code> &mdash; a <em>list</em> of <em>symbols</em>. </p><p>These functions search for <em>interned</em> <em>symbols</em> whose <em>names</em> contain the substring <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_apropo.htm#apropos)", "apropos-list": "```commonlisp\napropos string &optional package => <no values>\napropos-list string &optional package => symbols\n```\n\n<p><code>string</code> &mdash; a <em>string designator</em>. </p><p><code>package</code> &mdash; a <em>package designator</em> or <code>nil</code>. The default is <code>nil</code>. </p><p><code>symbols</code> &mdash; a <em>list</em> of <em>symbols</em>. </p><p>These functions search for <em>interned</em> <em>symbols</em> whose <em>names</em> contain the substring <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_apropo.htm#apropos-list)", "array-dimensions": "```commonlisp\narray-dimensions array => dimensions\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>dimensions</code> &mdash; a <em>list</em> of <em>integers</em>. </p><p>Returns a <em>list</em> of the <em>dimensions</em> of <em>array</em>. (If <em>array</em> is a <em>vector</em> with a <em>fill pointer</em>, that <em>fill pointer</em> is ignored.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_d_1.htm#array-dimensions)", "arithmetic-error-operation": "```commonlisp\narithmetic-error-operands condition => operands\narithmetic-error-operation condition => operation\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>arithmetic-error</code>. </p><p><code>operands</code> &mdash; a <em>list</em>. </p><p><code>operation</code> &mdash; a <em>function designator</em>. </p><p><code>arithmetic-error-operands</code> returns a <em>list</em> of the operands which were used in the offending call to the operation that signaled the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_arithm.htm#arithmetic-error-operation)", "array-element-type": "```commonlisp\narray-element-type array => typespec\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p> Returns a <em>type specifier</em> which represents the <em>actual array element type</em> of the array, which is the set of <em>objects</em> that such an <em>array</em> can hold. (Because of <em>array</em> <em>upgrading</em>, this <em>type specifier</em> can in some cases denote a <em>supertype</em> of the <em>expressed array element type</em> of the <em>array</em>.)  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_ele.htm#array-element-type)", "array-has-fill-pointer-p": "```commonlisp\narray-has-fill-pointer-p array => generalized-boolean\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>array</em> has a <em>fill pointer</em>; otherwise returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_has.htm#array-has-fill-pointer-p)", "arrayp": "```commonlisp\narrayp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>array</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_arrayp.htm#arrayp)", "array-in-bounds-p": "```commonlisp\narray-in-bounds-p array &rest subscripts => generalized-boolean\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>subscripts</code> &mdash; a list of <em>integers</em> of length equal to the <em>rank</em> of the <em>array</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if the <em>subscripts</em> are all in bounds for <em>array</em>; otherwise returns <em>false</em>. (If <em>array</em> is a <em>vector</em> with a <em>fill pointer</em>, that <em>fill pointer</em> is ignored.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_in_.htm#array-in-bounds-p)", "array-displacement": "```commonlisp\narray-displacement array => displaced-to, displaced-index-offset\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>displaced-to</code> &mdash; an <em>array</em> or <code>nil</code>. </p><p><code>displaced-index-offset</code> &mdash; a non-negative <em>fixnum</em>. </p><p>If the <em>array</em> is a <em>displaced array</em>, returns the <em>values</em> of the <code>:displaced-to</code> and <code>:displaced-index-offset</code> options for the <em>array</em> (see the <em>functions</em> <code>make-array</code> and <code>adjust-array</code>). If the <em>array</em> is not a <em>displaced array</em>, <code>nil</code> and <code>0</code> are returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_dis.htm#array-displacement)", "array-rank": "```commonlisp\narray-rank array => rank\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>rank</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the number of <em>dimensions</em> of <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_ran.htm#array-rank)", "asin": "```commonlisp\nasin number => radians\nacos number => radians\natan number1 &optional number2 => radians\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>number1</code> &mdash; a <em>number</em> if <em>number2</em> is not supplied, or a <em>real</em> if <em>number2</em> is supplied. </p><p><code>number2</code> &mdash; a <em>real</em>. </p><p><code>radians</code> &mdash; a <em>number</em> (of radians). </p><p><code>asin</code>, <code>acos</code>, and <code>atan</code> compute the arc sine, arc cosine, and arc tangent respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_asin_.htm#asin)", "array-row-major-index": "```commonlisp\narray-row-major-index array &rest subscripts => index\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>subscripts</code> &mdash; a <em>list</em> of <em>valid array indices</em> for the <em>array</em>. </p><p><code>index</code> &mdash; a <em>valid array row-major index</em> for the <em>array</em>. </p><p>Computes the position according to the row-major ordering of <em>array</em> for the element that is specified by <em>subscripts</em>, and returns the offset of the element in the computed position from the beginning of <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_row.htm#array-row-major-index)", "ash": "```commonlisp\nash integer count => shifted-integer\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>count</code> &mdash; an <em>integer</em>. </p><p><code>shifted-integer</code> &mdash; an <em>integer</em>. </p><p><code>ash</code> performs the arithmetic shift operation on the binary representation of <em>integer</em>, which is treated as if it were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ash.htm#ash)", "array-total-size": "```commonlisp\narray-total-size array => size\n```\n\n<p><code>array</code> &mdash; an <em>array</em>. </p><p><code>size</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the <em>array total size</em> of the <em>array</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ar_tot.htm#array-total-size)", "asinh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#asinh)", "assoc-if": "```commonlisp\nassoc item alist &key key test test-not => entry\nassoc-if predicate alist &key key => entry\nassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of <em>alist</em>, or <code>nil</code>. </p><p><code>assoc</code>, <code>assoc-if</code>, and <code>assoc-if-not</code> return the first <em>cons</em> in <em>alist</em> whose <em>car</em> <em>satisfies the test</em>, or <code>nil</code> if no such <em>cons</em> is found.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_assocc.htm#assoc-if)", "assoc": "```commonlisp\nassoc item alist &key key test test-not => entry\nassoc-if predicate alist &key key => entry\nassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of <em>alist</em>, or <code>nil</code>. </p><p><code>assoc</code>, <code>assoc-if</code>, and <code>assoc-if-not</code> return the first <em>cons</em> in <em>alist</em> whose <em>car</em> <em>satisfies the test</em>, or <code>nil</code> if no such <em>cons</em> is found.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_assocc.htm#assoc)", "bit-eqv": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-eqv)", "atan": "```commonlisp\nasin number => radians\nacos number => radians\natan number1 &optional number2 => radians\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>number1</code> &mdash; a <em>number</em> if <em>number2</em> is not supplied, or a <em>real</em> if <em>number2</em> is supplied. </p><p><code>number2</code> &mdash; a <em>real</em>. </p><p><code>radians</code> &mdash; a <em>number</em> (of radians). </p><p><code>asin</code>, <code>acos</code>, and <code>atan</code> compute the arc sine, arc cosine, and arc tangent respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_asin_.htm#atan)", "bit-andc2": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-andc2)", "assoc-if-not": "```commonlisp\nassoc item alist &key key test test-not => entry\nassoc-if predicate alist &key key => entry\nassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of <em>alist</em>, or <code>nil</code>. </p><p><code>assoc</code>, <code>assoc-if</code>, and <code>assoc-if-not</code> return the first <em>cons</em> in <em>alist</em> whose <em>car</em> <em>satisfies the test</em>, or <code>nil</code> if no such <em>cons</em> is found.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_assocc.htm#assoc-if-not)", "atanh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#atanh)", "bit-ior": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-ior)", "bit-nand": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-nand)", "bit-vector-p": "```commonlisp\nbit-vector-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>bit-vector</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_vec.htm#bit-vector-p)", "bit-andc1": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-andc1)", "bit-orc2": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-orc2)", "boole": "```commonlisp\nboole op integer-1 integer-2 => result-integer\n```\n\n<p><code>Op</code> &mdash; a <em>bit-wise logical operation specifier</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p><code>boole</code> performs bit-wise logical operations on <em>integer-1</em> and <em>integer-2</em>, which are treated as if they were binary and in two's complement representation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_boole.htm#boole)", "both-case-p": "```commonlisp\nupper-case-p character => generalized-boolean\nlower-case-p character => generalized-boolean\nboth-case-p character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These functions test the case of a given <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upper_.htm#both-case-p)", "bit-orc1": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-orc1)", "bit-not": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-not)", "bit-xor": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-xor)", "boundp": "```commonlisp\nboundp symbol => generalized-boolean\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>symbol</em> is <em>bound</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_boundp.htm#boundp)", "break": "```commonlisp\nbreak &optional format-control &rest format-arguments => nil\n```\n\n<p> <code>format-control</code> &mdash; a <em>format control</em>.  The default is <em>implementation-dependent</em>. </p><p><code>format-arguments</code> &mdash; <em>format arguments</em> for the <em>format-control</em>. </p><p><code>break</code> <em>formats</em> <em>format-control</em> and <em>format-arguments</em> and then goes directly into the debugger without allowing any possibility of interception by programmed error-handling facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_break.htm#break)", "broadcast-stream-streams": "```commonlisp\nbroadcast-stream-streams broadcast-stream => streams\n```\n\n<p><code>broadcast-stream</code> &mdash; a <em>broadcast stream</em>. </p><p><code>streams</code> &mdash; a <em>list</em> of <em>streams</em>. </p><p>Returns a <em>list</em> of output <em>streams</em> that constitute all the <em>streams</em> to which the <em>broadcast-stream</em> is broadcasting. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_broadc.htm#broadcast-stream-streams)", "butlast": "```commonlisp\nbutlast list &optional n => result-list\nnbutlast list &optional n => result-list\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> but must not be a <em>circular list</em>.  </p><p> <code>n</code> &mdash; a non-negative <em>integer</em>.  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>butlast</code> returns a copy of <em>list</em> from which the last <em>n</em>  conses  have been omitted. If <em>n</em> is not supplied, its value is 1. If there are fewer than <em>n</em>  conses  in <em>list</em>, <code>nil</code> is returned and, in the case of <code>nbutlast</code>, <em>list</em> is not modified. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_butlas.htm#butlast)", "bit-and": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-and)", "byte-position": "```commonlisp\nbyte size position => bytespec\nbyte-size bytespec => size\nbyte-position bytespec => position\n```\n\n<p><code>size</code>, <code>position</code> &mdash; a non-negative <em>integer</em>. </p><p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>byte</code> returns a <em>byte specifier</em> that indicates a <em>byte</em> of width <em>size</em> and whose bits have weights 2^<em>position</em> + <em>size</em> - 1 through 2^<em>position</em>, and whose representation is <em>implementation-dependent</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_by_by.htm#byte-position)", "ceiling": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#ceiling)", "byte-size": "```commonlisp\nbyte size position => bytespec\nbyte-size bytespec => size\nbyte-position bytespec => position\n```\n\n<p><code>size</code>, <code>position</code> &mdash; a non-negative <em>integer</em>. </p><p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>byte</code> returns a <em>byte specifier</em> that indicates a <em>byte</em> of width <em>size</em> and whose bits have weights 2^<em>position</em> + <em>size</em> - 1 through 2^<em>position</em>, and whose representation is <em>implementation-dependent</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_by_by.htm#byte-size)", "cell-error-name": "```commonlisp\ncell-error-name condition => name\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>cell-error</code>. </p><p><code>name</code> &mdash; an <em>object</em>. </p><p>Returns the <em>name</em> of the offending cell involved in the <em>situation</em> represented by <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cell_e.htm#cell-error-name)", "byte": "```commonlisp\nbyte size position => bytespec\nbyte-size bytespec => size\nbyte-position bytespec => position\n```\n\n<p><code>size</code>, <code>position</code> &mdash; a non-negative <em>integer</em>. </p><p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>byte</code> returns a <em>byte specifier</em> that indicates a <em>byte</em> of width <em>size</em> and whose bits have weights 2^<em>position</em> + <em>size</em> - 1 through 2^<em>position</em>, and whose representation is <em>implementation-dependent</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_by_by.htm#byte)", "cerror": "```commonlisp\ncerror continue-format-control datum &rest arguments => nil\n```\n\n<p> <code>Continue-format-control</code> &mdash; a <em>format control</em>.  </p><p><code>datum</code>, <code>arguments</code> &mdash; <em>designators</em> for a <em>condition</em> of default type <code>simple-error</code>. </p><p><code>cerror</code> effectively invokes <code>error</code> on the <em>condition</em> named by <em>datum</em>. As with any function that implicitly calls <code>error</code>, if the <em>condition</em> is not handled, <code>(invoke-debugger </code><em>condition</em><code>)</code> is executed. While signaling is going on, and while in the debugger if it is reached, it is possible to continue code execution (i.e., to return from <code>cerror</code>) using the <code>continue</code> <em>restart</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cerror.htm#cerror)", "bit-nor": "```commonlisp\nbit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array\nbit-not bit-array &optional opt-arg => resulting-bit-array\n```\n\n<p><code>bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code> &mdash; a <em>bit array</em>. </p><p><code>Opt-arg</code> &mdash; a <em>bit array</em>, or <code>t</code>, or <code>nil</code>. The default is <code>nil</code>. </p><p><code>Bit-array</code>, <code>bit-array1</code>, <code>bit-array2</code>, and <code>opt-arg</code> (if an <code>array</code>) must all be of the same <code>rank</code> and <code>dimensions</code>. </p><p><code>resulting-bit-array</code> &mdash; a <em>bit array</em>. </p><p>These functions perform bit-wise logical operations on <em>bit-array1</em> and <em>bit-array2</em> and return an <em>array</em> of matching <em>rank</em> and <em>dimensions</em>, such that any given bit of the result is produced by operating on corresponding bits from each of the arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_bt_and.htm#bit-nor)", "char-code": "```commonlisp\nchar-code character => code\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>code</code> &mdash; a <em>character code</em>. </p><p><code>char-code</code> returns the <em>code</em> <em>attribute</em> of <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_c.htm#char-code)", "char<=": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charLTEQ)", "char<": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charLT)", "char>=": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charGTEQ)", "characterp": "```commonlisp\ncharacterp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>character</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chp.htm#characterp)", "char-downcase": "```commonlisp\nchar-upcase character => corresponding-character\nchar-downcase character => corresponding-character\n```\n\n<p><code>character</code>, <code>corresponding-character</code> &mdash; a <em>character</em>. </p><p>If <em>character</em> is a <em>lowercase</em> <em>character</em>, <code>char-upcase</code> returns the corresponding <em>uppercase</em> <em>character</em>. Otherwise, <code>char-upcase</code> just returns the given <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_u.htm#char-downcase)", "char-int": "```commonlisp\nchar-int character => integer\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p> Returns a non-negative <em>integer</em> encoding the <em>character</em> object. The manner in which the <em>integer</em> is computed is <em>implementation-dependent</em>. In contrast to <code>sxhash</code>, the result is not guaranteed to be independent of the particular <em>Lisp image</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_i.htm#char-int)", "char-name": "```commonlisp\nchar-name character => name\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>name</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p>Returns a <em>string</em> that is the <em>name</em> of the <em>character</em>, or <code>nil</code> if the <em>character</em> has no <em>name</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_n.htm#char-name)", "char=": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charEQ)", "char>": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charGT)", "char-upcase": "```commonlisp\nchar-upcase character => corresponding-character\nchar-downcase character => corresponding-character\n```\n\n<p><code>character</code>, <code>corresponding-character</code> &mdash; a <em>character</em>. </p><p>If <em>character</em> is a <em>lowercase</em> <em>character</em>, <code>char-upcase</code> returns the corresponding <em>uppercase</em> <em>character</em>. Otherwise, <code>char-upcase</code> just returns the given <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_char_u.htm#char-upcase)", "char-greaterp": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-greaterp)", "char-not-greaterp": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-not-greaterp)", "char/=": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#charSLEQ)", "class-of": "```commonlisp\nclass-of object => class\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>class</code> &mdash; a <em>class</em> <em>object</em>. </p><p>Returns the <em>class</em> of which the <em>object</em> is a <em>direct instance</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_clas_1.htm#class-of)", "cis": "```commonlisp\ncis radians => number\n```\n\n<p><code>radians</code> &mdash; a <em>real</em>. </p><p><code>number</code> &mdash; a <em>complex</em>. </p><p><code>cis</code> returns the value of <em>e</em>^i* <em>radians</em>, which is a <em>complex</em> in which the real part is equal to the cosine of <em>radians</em>, and the imaginary part is equal to the sine of <em>radians</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cis.htm#cis)", "clear-input": "```commonlisp\nclear-input &optional input-stream => nil\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p>Clears any available input from <em>input-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_clear_.htm#clear-input)", "clear-output": "```commonlisp\nfinish-output &optional output-stream => nil\nforce-output &optional output-stream => nil\nclear-output &optional output-stream => nil\n```\n\n<p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>finish-output</code>, <code>force-output</code>, and <code>clear-output</code> exercise control over the internal handling of buffered stream output. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_finish.htm#clear-output)", "char-lessp": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-lessp)", "char-not-lessp": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-not-lessp)", "clrhash": "```commonlisp\nclrhash hash-table => hash-table\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p>Removes all entries from <em>hash-table</em>, and then returns that empty <em>hash table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_clrhas.htm#clrhash)", "close": "```commonlisp\nclose stream &key abort => result\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em> (either <em>open</em> or <em>closed</em>). </p><p><code>abort</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p> <code>result</code> &mdash; <code>t</code> if the <em>stream</em> was <em>open</em> at the time it was received as an <em>argument</em>, or <em>implementation-dependent</em> otherwise.  </p><p><code>close</code> closes <em>stream</em>. Closing a <em>stream</em> means that it may no longer be used in input or output operations. The act of <em>closing</em> a <em>file stream</em> ends the association between the <em>stream</em> and its associated <em>file</em>; the transaction with the <em>file system</em> is terminated, and input/output may no longer be performed on the <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_close.htm#close)", "char-equal": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-equal)", "code-char": "```commonlisp\ncode-char code => char-p\n```\n\n<p><code>code</code> &mdash; a <em>character code</em>. </p><p><code>char-p</code> &mdash; a <em>character</em> or <code>nil</code>. </p><p>Returns a <em>character</em> with the <em>code</em> <em>attribute</em> given by <em>code</em>. If no such <em>character</em> exists and one cannot be created, <code>nil</code> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_code_c.htm#code-char)", "char-not-equal": "```commonlisp\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These predicates compare <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chareq.htm#char-not-equal)", "compile-file-pathname": "```commonlisp\ncompile-file-pathname input-file &key output-file &allow-other-keys => pathname\n```\n\n<p><code>input-file</code> &mdash; a <em>pathname designator</em>. (Default fillers for unspecified components are taken from <code>*default-pathname-defaults*</code>.) </p><p><code>output-file</code> &mdash; a <em>pathname designator</em>. The default is <em>implementation-defined</em>. </p><p><code>pathname</code> &mdash; a <em>pathname</em>. </p><p>Returns the <em>pathname</em> that <code>compile-file</code> would write into, if given the same arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cmp__1.htm#compile-file-pathname)", "coerce": "```commonlisp\ncoerce object result-type => result\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>result-type</code> &mdash; a <em>type specifier</em>. </p><p><code>result</code> &mdash; an <em>object</em>, of <em>type</em> <em>result-type</em> except in situations described in Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals). </p><p><em>Coerces</em> the <em>object</em> to <em>type</em> <em>result-type</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_coerce.htm#coerce)", "compiled-function-p": "```commonlisp\ncompiled-function-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>compiled-function</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cmpd_f.htm#compiled-function-p)", "compile": "```commonlisp\ncompile name &optional definition => function, warnings-p, failure-p\n```\n\n<p><code>name</code> &mdash; a <em>function name</em>, or <code>nil</code>. </p><p><code>definition</code> &mdash; a <em>lambda expression</em> or a <em>function</em>. The default is the function definition of <em>name</em> if it names a <em>function</em>, or the <em>macro function</em> of <em>name</em> if it names a <em>macro</em>. The consequences are undefined if no <em>definition</em> is supplied when the <em>name</em> is <code>nil</code>. </p><p><code>function</code> &mdash; the <em>function-name</em>,  or a <em>compiled function</em>.  </p><p><code>warnings-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>failure-p</code> &mdash; a <em>generalized boolean</em>. </p><p>Compiles an <em>interpreted function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cmp.htm#compile)", "complexp": "```commonlisp\ncomplexp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>complex</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_comp_3.htm#complexp)", "compile-file": "```commonlisp\ncompile-file input-file &key output-file verbose print external-format\n => output-truename, warnings-p, failure-p\n```\n\n<p><code>input-file</code> &mdash; a <em>pathname designator</em>. (Default fillers for unspecified components are taken from <code>*default-pathname-defaults*</code>.) </p><p><code>output-file</code> &mdash; a <em>pathname designator</em>. The default is <em>implementation-defined</em>. </p><p> <code>verbose</code> &mdash; a <em>generalized boolean</em>. The default is the <em>value</em> of <code>*compile-verbose*</code>. </p><p><code>print</code> &mdash; a <em>generalized boolean</em>. The default is the <em>value</em> of <code>*compile-print*</code>.  </p><p> <code>external-format</code> &mdash; an <em>external file format designator</em>. The default is <code>:default</code>.  </p><p><code>output-truename</code> &mdash; a <em>pathname</em> (the <code>truename</code> of the output <em>file</em>), or <code>nil</code>. </p><p><code>warnings-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>failure-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>compile-file</code> transforms the contents of the file specified by <em>input-file</em> into <em>implementation-dependent</em> binary data which are placed in the file specified by <em>output-file</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cmp_fi.htm#compile-file)", "compute-restarts": "```commonlisp\ncompute-restarts &optional condition => restarts\n```\n\n<p> <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.  </p><p><code>restarts</code> &mdash; a <em>list</em> of <em>restarts</em>. </p><p><code>compute-restarts</code> uses the dynamic state of the program to compute a <em>list</em> of the <em>restarts</em> which are currently active. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_comp_1.htm#compute-restarts)", "complement": "```commonlisp\ncomplement function => complement-function\n```\n\n<p><code>function</code> &mdash; a <em>function</em>. </p><p><code>complement-function</code> &mdash; a <em>function</em>. </p><p>Returns a <em>function</em> that takes the same <em>arguments</em> as <em>function</em>, and has the same side-effect behavior as <em>function</em>, but returns only a single value: a <em>generalized boolean</em> with the opposite truth value of that which would be returned as the <em>primary value</em> of <em>function</em>. That is, when the <em>function</em> would have returned <em>true</em> as its <em>primary value</em> the <em>complement-function</em> returns <em>false</em>, and when the <em>function</em> would have returned <em>false</em> as its <em>primary value</em> the <em>complement-function</em> returns <em>true</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_comple.htm#complement)", "consp": "```commonlisp\nconsp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>cons</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_consp.htm#consp)", "conjugate": "```commonlisp\nconjugate number => conjugate\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>conjugate</code> &mdash; a <em>number</em>. </p><p>Returns the complex conjugate of <em>number</em>. The conjugate of a  <em>real</em>  number is itself. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_conjug.htm#conjugate)", "concatenated-stream-streams": "```commonlisp\nconcatenated-stream-streams concatenated-stream => streams\n```\n\n<p><code>concatenated-stream</code>  &mdash;  a <code>concatenated stream</code>. </p><p><code>streams</code> &mdash; a <em>list</em> of <em>input</em> <em>streams</em>. </p><p>Returns a <em>list</em> of <em>input</em> <em>streams</em> that constitute the ordered set of <em>streams</em> the <em>concatenated-stream</em> still has to read from, starting with the current one it is reading from. The list may be <em>empty</em> if no more <em>streams</em> remain to be read. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_conc_1.htm#concatenated-stream-streams)", "concatenate": "```commonlisp\nconcatenate result-type &rest sequences => result-sequence\n```\n\n<p> <code>result-type</code> &mdash; a <code>sequence</code> <em>type specifier</em>.  </p><p><code>sequences</code> &mdash; a <em>sequence</em>. </p><p><code>result-sequence</code> &mdash; a <em>proper sequence</em> of <em>type</em> <em>result-type</em>. </p><p><code>concatenate</code> returns a <em>sequence</em> that contains all the individual elements of all the <em>sequences</em> in the order that they are supplied. The <em>sequence</em> is of type <em>result-type</em>, which must be a <em>subtype</em> of <em>type</em> <code>sequence</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_concat.htm#concatenate)", "constantly": "```commonlisp\nconstantly value => function\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p><code>function</code> &mdash; a <em>function</em>. </p><p><code>constantly</code> returns a <em>function</em> that accepts any number of arguments, that has no side-effects, and that always returns <em>value</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cons_1.htm#constantly)", "copy-alist": "```commonlisp\ncopy-alist alist => new-alist\n```\n\n<p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>new-alist</code> &mdash; an <em>association list</em>. </p><p><code>copy-alist</code> returns a <em>copy</em> of <em>alist</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_ali.htm#copy-alist)", "copy-list": "```commonlisp\ncopy-list list => copy\n```\n\n<p><code>list</code> &mdash; a <em>proper list</em> or a <em>dotted list</em>. </p><p><code>copy</code> &mdash; a <em>list</em>. </p><p>Returns a <em>copy</em> of <em>list</em>. If <em>list</em> is a <em>dotted list</em>, the resulting <em>list</em> will also be a <em>dotted list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_lis.htm#copy-list)", "copy-pprint-dispatch": "```commonlisp\ncopy-pprint-dispatch &optional table => new-table\n```\n\n<p><code>table</code> &mdash; a <em>pprint dispatch table</em>, or <code>nil</code>. </p><p><code>new-table</code> &mdash; a <em>fresh</em> <em>pprint dispatch table</em>. </p><p>Creates and returns a copy of the specified <em>table</em>, or of the <em>value</em> of <code>*print-pprint-dispatch*</code> if no <em>table</em> is specified, or of the initial <em>value</em> of <code>*print-pprint-dispatch*</code> if <code>nil</code> is specified. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_ppr.htm#copy-pprint-dispatch)", "constantp": "```commonlisp\nconstantp form &optional environment => generalized-boolean\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>form</em> can be determined by the <em>implementation</em> to be a <em>constant form</em> in the indicated <em>environment</em>; otherwise, it returns <em>false</em> indicating either that the <em>form</em> is not a <em>constant form</em> or that it cannot be determined whether or not <em>form</em> is a <em>constant form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_consta.htm#constantp)", "copy-seq": "```commonlisp\ncopy-seq sequence => copied-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>copied-sequence</code> &mdash; a <em>proper sequence</em>. </p><p>Creates a copy of <em>sequence</em>. The <em>elements</em> of the new <em>sequence</em> are the <em>same</em> as the corresponding <em>elements</em> of the given <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_seq.htm#copy-seq)", "copy-readtable": "```commonlisp\ncopy-readtable &optional from-readtable to-readtable => readtable\n```\n\n<p><code>from-readtable</code> &mdash; a <em>readtable designator</em>. The default is the <em>current readtable</em>. </p><p><code>to-readtable</code> &mdash; a <em>readtable</em> or <code>nil</code>. The default is <code>nil</code>. </p><p><code>readtable</code> &mdash; the <em>to-readtable</em> if it is <em>non-nil</em>, or else a <em>fresh</em> <em>readtable</em>. </p><p><code>copy-readtable</code> copies <em>from-readtable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_rdt.htm#copy-readtable)", "copy-structure": "```commonlisp\ncopy-structure structure => copy\n```\n\n<p><code>structure</code> &mdash; a <em>structure</em>. </p><p><code>copy</code> &mdash; a copy of the <em>structure</em>. </p><p>Returns a <em>copy</em>[6] of the <em>structure</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_stu.htm#copy-structure)", "cos": "```commonlisp\nsin radians => number\ncos radians => number\ntan radians => number\n```\n\n<p><code>radians</code> &mdash; a <em>number</em> given in radians. </p><p><code>number</code> &mdash; a <em>number</em>. </p><p><code>sin</code>, <code>cos</code>, and <code>tan</code> return the sine, cosine, and tangent, respectively, of <em>radians</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sin_c.htm#cos)", "cosh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#cosh)", "count-if-not": "```commonlisp\ncount item sequence &key from-end start end key test test-not => n\ncount-if predicate sequence &key from-end start end key => n\ncount-if-not predicate sequence &key from-end start end key => n\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>n</code> &mdash; a non-negative <em>integer</em> less than or equal to the <em>length</em> of <em>sequence</em>. </p><p><code>count</code>, <code>count-if</code>, and <code>count-if-not</code> count and return the number of <em>elements</em> in the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfy the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_countc.htm#count-if-not)", "copy-symbol": "```commonlisp\ncopy-symbol symbol &optional copy-properties => new-symbol\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>copy-properties</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>new-symbol</code> &mdash; a <em>fresh</em>, <em>uninterned</em> <em>symbol</em>. </p><p><code>copy-symbol</code> returns a <em>fresh</em>, <em>uninterned</em> <em>symbol</em>, the <em>name</em> of which is <code>string=</code> to and possibly the <em>same</em> as the <em>name</em> of the given <em>symbol</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_sym.htm#copy-symbol)", "copy-tree": "```commonlisp\ncopy-tree tree => new-tree\n```\n\n<p><code>tree</code> &mdash; a <em>tree</em>. </p><p><code>new-tree</code> &mdash; a <em>tree</em>. </p><p>Creates a <em>copy</em> of a <em>tree</em> of <em>conses</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_cp_tre.htm#copy-tree)", "count-if": "```commonlisp\ncount item sequence &key from-end start end key test test-not => n\ncount-if predicate sequence &key from-end start end key => n\ncount-if-not predicate sequence &key from-end start end key => n\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>n</code> &mdash; a non-negative <em>integer</em> less than or equal to the <em>length</em> of <em>sequence</em>. </p><p><code>count</code>, <code>count-if</code>, and <code>count-if-not</code> count and return the number of <em>elements</em> in the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfy the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_countc.htm#count-if)", "decode-universal-time": "```commonlisp\ndecode-universal-time universal-time &optional time-zone\n => second, minute, hour, date, month, year, day, daylight-p, zone\n```\n\n<p><code>universal-time</code> &mdash; a <em>universal time</em>. </p><p> <code>time-zone</code> &mdash; a <em>time zone</em>.  </p><p><code>second</code>, <code>minute</code>, <code>hour</code>, <code>date</code>, <code>month</code>, <code>year</code>, <code>day</code>, <code>daylight-p</code>, <code>zone</code> &mdash; a <em>decoded time</em>. </p><p>Returns the <em>decoded time</em> represented by the given <em>universal time</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_un.htm#decode-universal-time)", "decode-float": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#decode-float)", "count": "```commonlisp\ncount item sequence &key from-end start end key test test-not => n\ncount-if predicate sequence &key from-end start end key => n\ncount-if-not predicate sequence &key from-end start end key => n\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>n</code> &mdash; a non-negative <em>integer</em> less than or equal to the <em>length</em> of <em>sequence</em>. </p><p><code>count</code>, <code>count-if</code>, and <code>count-if-not</code> count and return the number of <em>elements</em> in the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfy the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_countc.htm#count)", "delete-duplicates": "```commonlisp\nremove-duplicates sequence &key from-end test test-not start end key\n => result-sequence\ndelete-duplicates sequence &key from-end test test-not start end key\n => result-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove-duplicates</code> returns a modified copy of <em>sequence</em> from which any element that matches another element occurring in <em>sequence</em> has been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_dup.htm#delete-duplicates)", "delete-file": "```commonlisp\ndelete-file filespec => t\n```\n\n<p> <code>filespec</code> &mdash; a <em>pathname designator</em>.  </p><p>Deletes the <em>file</em> specified by <em>filespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_del_fi.htm#delete-file)", "delete-package": "```commonlisp\ndelete-package package => generalized-boolean\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>delete-package</code> deletes <em>package</em> from all package system data structures. If the operation is successful, <code>delete-package</code> returns true, otherwise <code>nil</code>. The effect of <code>delete-package</code> is that the name and nicknames of <em>package</em> cease to be recognized package names. The package <em>object</em> is still a <em>package</em> (i.e., <code>packagep</code> is <em>true</em> of it) but <code>package-name</code> returns <code>nil</code>. The consequences of deleting the <code>COMMON-LISP</code> package or the <code>KEYWORD</code> package are undefined. The consequences of invoking any other package operation on <em>package</em> once it has been deleted are unspecified. In particular, the consequences of invoking <code>find-symbol</code>, <code>intern</code> and other functions that look for a symbol name in a <em>package</em> are unspecified if they are called with <code>*package*</code> bound to the deleted <em>package</em> or with the deleted <em>package</em> as an argument. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_del_pk.htm#delete-package)", "denominator": "```commonlisp\nnumerator rational => numerator\ndenominator rational => denominator\n```\n\n<p><code>rational</code> &mdash; a <em>rational</em>. </p><p><code>numerator</code> &mdash; an <em>integer</em>. </p><p><code>denominator</code> &mdash; a positive <em>integer</em>. </p><p><code>numerator</code> and <code>denominator</code> reduce <em>rational</em> to canonical form and compute the numerator or denominator of that number. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_numera.htm#denominator)", "delete": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#delete)", "delete-if": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#delete-if)", "digit-char": "```commonlisp\n```\n\n<p><code>weight</code> &mdash; a non-negative <em>integer</em>. </p><p><code>radix</code> &mdash; a <em>radix</em>. The default is <code>10</code>. </p><p><code>char</code> &mdash; a <em>character</em> or <em>false</em>. </p><p>If <em>weight</em> is less than <em>radix</em>, <code>digit-char</code> returns a <em>character</em> which has that <em>weight</em> when considered as a digit in the specified radix. If the resulting <em>character</em> is to be an <em>alphabetic</em>[1] <em>character</em>, it will be an uppercase <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_digit_.htm#digit-char)", "delete-if-not": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#delete-if-not)", "deposit-field": "```commonlisp\ndeposit-field newbyte bytespec integer => result-integer\n```\n\n<p><code>newbyte</code> &mdash; an <em>integer</em>. </p><p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>Replaces a field of bits within <em>integer</em>; specifically, returns an <em>integer</em> that contains the bits of <em>newbyte</em> within the <em>byte</em> specified by <em>bytespec</em>, and elsewhere contains the bits of <em>integer</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_deposi.htm#deposit-field)", "describe": "```commonlisp\ndescribe object &optional stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p> <code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>.  </p><p><code>describe</code> displays information about <em>object</em>  to <em>stream</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_descri.htm#describe)", "digit-char-p": "```commonlisp\ndigit-char-p char &optional radix => weight\n```\n\n<p><code>char</code> &mdash; a <em>character</em>. </p><p><code>radix</code> &mdash; a <em>radix</em>. The default is <code>10</code>. </p><p><code>weight</code> &mdash; either a non-negative <em>integer</em> less than <em>radix</em>, or <em>false</em>. </p><p>Tests whether <em>char</em> is a digit in the specified <em>radix</em> (i.e., with a weight less than <em>radix</em>). If it is a digit in that <em>radix</em>, its weight is returned as an <em>integer</em>; otherwise <code>nil</code> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_digi_1.htm#digit-char-p)", "directory": "```commonlisp\ndirectory pathspec &key => pathnames\n```\n\n<p> <code>pathspec</code> &mdash; a <em>pathname designator</em>, which may contain <em>wild</em> components.  </p><p><code>pathnames</code> &mdash; a <em>list</em> of  <em>physical pathnames</em>.  </p><p>Determines which, if any, <em>files</em> that are present in the file system have names matching <em>pathspec</em>, and returns a  <em>fresh</em>  <em>list</em> of <em>pathnames</em> corresponding to the <em>truenames</em> of those <em>files</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dir.htm#directory)", "dpb": "```commonlisp\ndpb newbyte bytespec integer => result-integer\n```\n\n<p><code>newbyte</code> &mdash; an <em>integer</em>. </p><p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p><code>dpb</code> (deposit byte) is used to replace a field of bits within <em>integer</em>. <code>dpb</code> returns an <em>integer</em> that is the same as <em>integer</em> except in the bits specified by <em>bytespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dpb.htm#dpb)", "disassemble": "```commonlisp\ndisassemble fn => nil\n```\n\n<p> <code>fn</code> &mdash; an <em>extended function designator</em> or a <em>lambda expression</em>.  </p><p>The <em>function</em> <code>disassemble</code> is a debugging aid that composes symbolic instructions or expressions in some <em>implementation-dependent</em> language which represent the code used to produce the <em>function</em> which is or is named by the argument <em>fn</em>. The result is displayed to <em>standard output</em> in an <em>implementation-dependent</em> format. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_disass.htm#disassemble)", "echo-stream-input-stream": "```commonlisp\necho-stream-input-stream echo-stream => input-stream\necho-stream-output-stream echo-stream => output-stream\n```\n\n<p><code>echo-stream</code> &mdash; an <em>echo stream</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>echo-stream-input-stream</code> returns the <em>input</em> <em>stream</em> from which <em>echo-stream</em> receives input. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_echo_s.htm#echo-stream-input-stream)", "dribble": "```commonlisp\ndribble &optional pathname => implementation-dependent\n```\n\n<p><code>pathname</code> &mdash; a <em>pathname designator</em>. </p><p>Either <em>binds</em> <code>*standard-input*</code> and <code>*standard-output*</code> or takes other appropriate action, so as to send a record of the input/output interaction to a file named by <em>pathname</em>. <code>dribble</code> is intended to create a readable record of an interactive session. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dribbl.htm#dribble)", "directory-namestring": "```commonlisp\nnamestring pathname => namestring\nfile-namestring pathname => namestring\ndirectory-namestring pathname => namestring\nhost-namestring pathname => namestring\nenough-namestring pathname &optional defaults => namestring\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>defaults</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p><code>namestring</code> &mdash; a <em>string</em> or <code>nil</code>.  </p><p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_namest.htm#directory-namestring)", "echo-stream-output-stream": "```commonlisp\necho-stream-input-stream echo-stream => input-stream\necho-stream-output-stream echo-stream => output-stream\n```\n\n<p><code>echo-stream</code> &mdash; an <em>echo stream</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>echo-stream-input-stream</code> returns the <em>input</em> <em>stream</em> from which <em>echo-stream</em> receives input. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_echo_s.htm#echo-stream-output-stream)", "encode-universal-time": "```commonlisp\nencode-universal-time second minute hour date month year &optional time-zone\n => universal-time\n```\n\n<p><code>second</code>, <code>minute</code>, <code>hour</code>, <code>date</code>, <code>month</code>, <code>year</code>, <code>time-zone</code> &mdash; the corresponding parts of a <em>decoded time</em>. (Note that some of the nine values in a full <em>decoded time</em> are redundant, and so are not used as inputs to this function.) </p><p><code>universal-time</code> &mdash; a <em>universal time</em>. </p><p><code>encode-universal-time</code> converts a time from Decoded Time format to a <em>universal time</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_encode.htm#encode-universal-time)", "endp": "```commonlisp\nendp list => generalized-boolean\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>list</em> is the <em>empty list</em>. Returns <em>false</em> if <em>list</em> is a <em>cons</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_endp.htm#endp)", "ensure-generic-function": "```commonlisp\nensure-generic-function function-name &key argument-precedence-order declare documentation environment generic-function-class lambda-list method-class method-combination\n => generic-function\n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p>The keyword arguments correspond to the <code>option</code> arguments of <code>defgeneric</code>, except that the <code>:method-class</code> and <code>:generic-function-class</code> arguments can be <code>class</code> <code>object</code>s as well as names. </p><p><code>Method-combination</code>  &mdash;  method combination object. </p><p><code>Environment</code>  &mdash;  the same as the <code>&amp;environment</code> argument to macro expansion functions and is used to distinguish between compile-time and run-time environments. </p><p> <code>generic-function</code> &mdash; a <em>generic function</em> <em>object</em>. </p><p>The <em>function</em> <code>ensure-generic-function</code> is used to define a globally named <em>generic function</em> with no <em>methods</em> or to specify or modify options and declarations that pertain to a globally named <em>generic function</em> as a whole. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ensure.htm#ensure-generic-function)", "enough-namestring": "```commonlisp\nnamestring pathname => namestring\nfile-namestring pathname => namestring\ndirectory-namestring pathname => namestring\nhost-namestring pathname => namestring\nenough-namestring pathname &optional defaults => namestring\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>defaults</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p><code>namestring</code> &mdash; a <em>string</em> or <code>nil</code>.  </p><p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_namest.htm#enough-namestring)", "ed": "```commonlisp\ned &optional x => implementation-dependent\n```\n\n<p> <code>x</code> &mdash; <code>nil</code>, a <em>pathname</em>, a <em>string</em>, or a <em>function name</em>.  The default is <code>nil</code>. </p><p><code>ed</code> invokes the editor if the <em>implementation</em> provides a resident editor. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ed.htm#ed)", "ensure-directories-exist": "```commonlisp\nensure-directories-exist pathspec &key verbose => pathspec, created\n```\n\n<p><code>pathspec</code> &mdash; a <em>pathname designator</em>. </p><p><code>verbose</code> &mdash; a <em>generalized boolean</em>. </p><p><code>created</code> &mdash; a <em>generalized boolean</em>. </p><p>Tests whether the directories containing the specified <em>file</em> actually exist, and attempts to create them if they do not. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ensu_1.htm#ensure-directories-exist)", "eq": "```commonlisp\neq x y => generalized-boolean\n```\n\n<p><code>x</code> &mdash; an <em>object</em>. </p><p><code>y</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if its <em>arguments</em> are the same, identical <em>object</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eq.htm#eq)", "equal": "```commonlisp\nequal x y => generalized-boolean\n```\n\n<p><code>x</code> &mdash; an <em>object</em>. </p><p><code>y</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>x</em> and <em>y</em> are structurally similar (isomorphic) <em>objects</em>. <em>Objects</em> are treated as follows by <code>equal</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_equal.htm#equal)", "eval": "```commonlisp\neval form => result*\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> <em>yielded</em> by the <em>evaluation</em> of <em>form</em>. </p><p>Evaluates <em>form</em> in the current <em>dynamic environment</em> and the <em>null lexical environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_eval.htm#eval)", "equalp": "```commonlisp\nequalp x y => generalized-boolean\n```\n\n<p><code>x</code> &mdash; an <em>object</em>. </p><p><code>y</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>x</em> and <em>y</em> are <code>equal</code>, or if they have components that are of the same <em>type</em> as each other and if those components are <code>equalp</code>; specifically, <code>equalp</code> returns <em>true</em> in the following cases: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_equalp.htm#equalp)", "evenp": "```commonlisp\nevenp integer => generalized-boolean\noddp integer => generalized-boolean\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>evenp</code> returns <em>true</em> if <em>integer</em> is even (divisible by two); otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_evenpc.htm#evenp)", "every": "```commonlisp\nevery predicate &rest sequences+ => generalized-boolean\nsome predicate &rest sequences+ => result\nnotevery predicate &rest sequences+ => generalized-boolean\nnotany predicate &rest sequences+ => generalized-boolean\n```\n\n<p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of as many <em>arguments</em> as there are <em>sequences</em>. </p><p><code>sequence</code> &mdash; a <em>sequence</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>every</code>, <code>some</code>, <code>notevery</code>, and <code>notany</code> test <em>elements</em> of <em>sequences</em> for satisfaction of a given <em>predicate</em>. The first argument to <em>predicate</em> is an <em>element</em> of the first <em>sequence</em>; each succeeding argument is an <em>element</em> of a succeeding <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_everyc.htm#every)", "fboundp": "```commonlisp\nfboundp name => generalized-boolean\n```\n\n<p> <code>name</code> &mdash; a <em>function name</em>.  </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>name</em> is <em>fbound</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fbound.htm#fboundp)", "file-author": "```commonlisp\nfile-author pathspec => author\n```\n\n<p> <code>pathspec</code> &mdash; a <em>pathname designator</em>.  </p><p><code>author</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p>Returns a <em>string</em> naming the author of the <em>file</em> specified by <em>pathspec</em>, or <code>nil</code> if the author's name cannot be determined. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_a.htm#file-author)", "fceiling": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#fceiling)", "exp": "```commonlisp\nexp number => result\nexpt base-number power-number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>base-number</code> &mdash; a <em>number</em>. </p><p><code>power-number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p><code>exp</code> and <code>expt</code> perform exponentiation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_exp_e.htm#exp)", "file-error-pathname": "```commonlisp\nfile-error-pathname condition => pathspec\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>file-error</code>. </p><p><code>pathspec</code> &mdash; a <em>pathname designator</em>. </p><p>Returns the ``offending pathname'' of a <em>condition</em> of <em>type</em> <code>file-error</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_e.htm#file-error-pathname)", "export": "```commonlisp\nexport symbols &optional package => t\n```\n\n<p><code>symbols</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>symbols</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>export</code> makes one or more <em>symbols</em> that are <em>accessible</em> in <em>package</em> (whether directly or by inheritance) be <em>external symbols</em> of that <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_export.htm#export)", "expt": "```commonlisp\nexp number => result\nexpt base-number power-number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>base-number</code> &mdash; a <em>number</em>. </p><p><code>power-number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p><code>exp</code> and <code>expt</code> perform exponentiation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_exp_e.htm#expt)", "file-length": "```commonlisp\nfile-length stream => length\n```\n\n<p><code>stream</code> &mdash; a <em>stream associated with a file</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em> or <code>nil</code>. </p><p><code>file-length</code> returns the length of <em>stream</em>, or <code>nil</code> if the length cannot be determined. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_l.htm#file-length)", "file-namestring": "```commonlisp\nnamestring pathname => namestring\nfile-namestring pathname => namestring\ndirectory-namestring pathname => namestring\nhost-namestring pathname => namestring\nenough-namestring pathname &optional defaults => namestring\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>defaults</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p><code>namestring</code> &mdash; a <em>string</em> or <code>nil</code>.  </p><p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_namest.htm#file-namestring)", "file-string-length": "```commonlisp\nfile-string-length stream object => length\n```\n\n<p><code>stream</code> &mdash; an <em>output</em> <em>character</em> <em>file stream</em>. </p><p><code>object</code> &mdash; a <em>string</em> or a <em>character</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>file-string-length</code> returns the difference between what <code>(file-position </code><em>stream</em><code>)</code> would be after writing <em>object</em> and its current value, or <code>nil</code> if this cannot be determined. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_s.htm#file-string-length)", "fill": "```commonlisp\nfill sequence item &key start end => sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>item</code> &mdash; a <em>sequence</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p>Replaces the <em>elements</em> of <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> with <em>item</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fill.htm#fill)", "ffloor": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#ffloor)", "file-write-date": "```commonlisp\nfile-write-date pathspec => date\n```\n\n<p> <code>pathspec</code> &mdash; a <em>pathname designator</em>.  </p><p><code>date</code> &mdash; a <em>universal time</em> or <code>nil</code>. </p><p>Returns a <em>universal time</em> representing the time at which the <em>file</em> specified by <em>pathspec</em> was last written (or created), or returns <code>nil</code> if such a time cannot be determined. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_w.htm#file-write-date)", "file-position": "```commonlisp\nfile-position stream => position\nfile-position stream position-spec => success-p\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>position-spec</code> &mdash; a <em>file position designator</em>. </p><p><code>position</code> &mdash; a <em>file position</em> or <code>nil</code>. </p><p><code>success-p</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns or changes the current position within a <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_file_p.htm#file-position)", "find-all-symbols": "```commonlisp\nfind-all-symbols string => symbols\n```\n\n<p><code>string</code> &mdash; a <em>string designator</em>. </p><p><code>symbols</code> &mdash; a <em>list</em> of <em>symbols</em>. </p><p><code>find-all-symbols</code> searches  every <em>registered package</em>  for <em>symbols</em> that have a <em>name</em> that is the <em>same</em> (under <code>string=</code>) as <em>string</em>. A <em>list</em> of all such <em>symbols</em> is returned. Whether or how the <em>list</em> is ordered is <em>implementation-dependent</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_a.htm#find-all-symbols)", "find-if-not": "```commonlisp\nfind item sequence &key from-end test test-not start end key => element\nfind-if predicate sequence &key from-end start end key => element\nfind-if-not predicate sequence &key from-end start end key => element\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>element</code> &mdash; an <em>element</em> of the <em>sequence</em>, or <code>nil</code>. </p><p><code>find</code>, <code>find-if</code>, and <code>find-if-not</code> each search for an <em>element</em> of the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfies the predicate</em> <em>predicate</em> or that <em>satisfies the test</em> <em>test</em> or <em>test-not</em>, as appropriate. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_.htm#find-if-not)", "find-if": "```commonlisp\nfind item sequence &key from-end test test-not start end key => element\nfind-if predicate sequence &key from-end start end key => element\nfind-if-not predicate sequence &key from-end start end key => element\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>element</code> &mdash; an <em>element</em> of the <em>sequence</em>, or <code>nil</code>. </p><p><code>find</code>, <code>find-if</code>, and <code>find-if-not</code> each search for an <em>element</em> of the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfies the predicate</em> <em>predicate</em> or that <em>satisfies the test</em> <em>test</em> or <em>test-not</em>, as appropriate. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_.htm#find-if)", "find-package": "```commonlisp\nfind-package name => package\n```\n\n<p> <code>name</code> &mdash; a <em>string designator</em> or a <em>package</em> <em>object</em>.  </p><p><code>package</code> &mdash; a <em>package</em> <em>object</em> or <code>nil</code>. </p><p>If <em>name</em> is a <em>string designator</em>, <code>find-package</code> locates and returns the <em>package</em> whose name or nickname is <em>name</em>. This search is case sensitive. If there is no such <em>package</em>, <code>find-package</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_p.htm#find-package)", "finish-output": "```commonlisp\nfinish-output &optional output-stream => nil\nforce-output &optional output-stream => nil\nclear-output &optional output-stream => nil\n```\n\n<p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>finish-output</code>, <code>force-output</code>, and <code>clear-output</code> exercise control over the internal handling of buffered stream output. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_finish.htm#finish-output)", "find-restart": "```commonlisp\nfind-restart identifier &optional condition\n restart  \n```\n\n<p><code>identifier</code> &mdash; a <em>non-nil</em> <em>symbol</em>, or a <em>restart</em>. </p><p> <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.  </p><p><code>restart</code> &mdash; a <em>restart</em> or <code>nil</code>. </p><p><code>find-restart</code> searches for a particular <em>restart</em> in the current <em>dynamic environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_r.htm#find-restart)", "find": "```commonlisp\nfind item sequence &key from-end test test-not start end key => element\nfind-if predicate sequence &key from-end start end key => element\nfind-if-not predicate sequence &key from-end start end key => element\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>element</code> &mdash; an <em>element</em> of the <em>sequence</em>, or <code>nil</code>. </p><p><code>find</code>, <code>find-if</code>, and <code>find-if-not</code> each search for an <em>element</em> of the <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> that <em>satisfies the predicate</em> <em>predicate</em> or that <em>satisfies the test</em> <em>test</em> or <em>test-not</em>, as appropriate. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_.htm#find)", "find-symbol": "```commonlisp\nfind-symbol string &optional package => symbol, status\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>symbol</code> &mdash; a <em>symbol</em> accessible in the <em>package</em>, or <code>nil</code>. </p><p><code>status</code> &mdash; one of <code>:inherited</code>, <code>:external</code>, <code>:internal</code>, or <code>nil</code>. </p><p><code>find-symbol</code> locates a <em>symbol</em> whose <em>name</em> is <em>string</em> in a <em>package</em>. If a <em>symbol</em> named <em>string</em> is found in <em>package</em>, directly or by inheritance, the <em>symbol</em> found is returned as the first value; the second value is as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_s.htm#find-symbol)", "force-output": "```commonlisp\nfinish-output &optional output-stream => nil\nforce-output &optional output-stream => nil\nclear-output &optional output-stream => nil\n```\n\n<p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>finish-output</code>, <code>force-output</code>, and <code>clear-output</code> exercise control over the internal handling of buffered stream output. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_finish.htm#force-output)", "floor": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#floor)", "floatp": "```commonlisp\nfloatp object\n generalized-boolean \n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>float</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floatp.htm#floatp)", "fmakunbound": "```commonlisp\nfmakunbound name => name\n```\n\n<p> <code>name</code> &mdash; a <em>function name</em>.  </p><p>Removes the <em>function</em> or <em>macro</em> definition, if any, of <em>name</em> in the <em>global environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fmakun.htm#fmakunbound)", "float-digits": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#float-digits)", "float-radix": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#float-radix)", "fround": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#fround)", "format": "```commonlisp\nformat destination control-string &rest args => result\n```\n\n<p><code>destination</code> &mdash; <code>nil</code>, <code>t</code>, a <em>stream</em>, or a <em>string</em> with a <em>fill pointer</em>. </p><p> <code>control-string</code> &mdash; a <em>format control</em>.  </p><p><code>args</code> &mdash; <em>format arguments</em> for <em>control-string</em>. </p><p><code>result</code> &mdash; if <em>destination</em> is <em>non-nil</em>, then <code>nil</code>; otherwise, a <em>string</em>. </p><p><code>format</code> produces formatted output by outputting the characters of <em>control-string</em> and observing that a <em>tilde</em> introduces a directive. The character after the tilde, possibly preceded by prefix parameters and modifiers, specifies what kind of formatting is desired. Most directives use one or more elements of <em>args</em> to create their output. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_format.htm#format)", "float-sign": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#float-sign)", "funcall": "```commonlisp\nfuncall function &rest args => result*\n```\n\n<p><code>function</code> &mdash; a <em>function designator</em>. </p><p><code>args</code> &mdash; <em>arguments</em> to the <em>function</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>function</em>. </p><p><code>funcall</code> applies <em>function</em> to <em>args</em>.  If <em>function</em> is a <em>symbol</em>, it is coerced to a <em>function</em> as if by finding its <em>functional value</em> in the <em>global environment</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_funcal.htm#funcall)", "ftruncate": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#ftruncate)", "fresh-line": "```commonlisp\nterpri &optional output-stream => nil\nfresh-line &optional output-stream => generalized-boolean\n```\n\n<p><code>output-stream</code>  &mdash;  an <code>output</code> <code>stream designator</code>. The default is <code>standard output</code>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>terpri</code> outputs a <em>newline</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_terpri.htm#fresh-line)", "float-precision": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#float-precision)", "function-lambda-expression": "```commonlisp\nfunction-lambda-expression function\n => lambda-expression, closure-p, name\n```\n\n<p><code>function</code> &mdash; a <em>function</em>. </p><p><code>lambda-expression</code> &mdash; a <em>lambda expression</em> or <code>nil</code>. </p><p><code>closure-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>name</code> &mdash; an <em>object</em>. </p><p>Returns information about <em>function</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fn_lam.htm#function-lambda-expression)", "functionp": "```commonlisp\nfunctionp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>function</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fnp.htm#functionp)", "gensym": "```commonlisp\ngensym &optional x => new-symbol\n```\n\n<p><code>x</code> &mdash; a <em>string</em> or a non-negative <em>integer</em>. Complicated defaulting behavior; see below. </p><p><code>new-symbol</code> &mdash; a <em>fresh</em>, <em>uninterned</em> <em>symbol</em>. </p><p>Creates and returns a <em>fresh</em>, <em>uninterned</em> <em>symbol</em>, as if by calling <code>make-symbol</code>. (The only difference between <code>gensym</code> and <code>make-symbol</code> is in how the <em>new-symbol</em>'s <em>name</em> is determined.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_gensym.htm#gensym)", "gcd": "```commonlisp\ngcd &rest integers => greatest-common-denominator\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>greatest-common-denominator</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the greatest common divisor of <em>integers</em>. If only one <em>integer</em> is supplied, its absolute value is returned. If no <em>integers</em> are given, <code>gcd</code> returns <code>0</code>, which is an identity for this operation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_gcd.htm#gcd)", "get-dispatch-macro-character": "```commonlisp\nget-dispatch-macro-character disp-char sub-char &optional readtable => function\nset-dispatch-macro-character disp-char sub-char new-function &optional readtable => t\n```\n\n<p><code>disp-char</code> &mdash; a <em>character</em>. </p><p><code>sub-char</code> &mdash; a <em>character</em>. </p><p> <code>readtable</code> &mdash; a <em>readtable designator</em>.  The default is the <em>current readtable</em>. </p><p><code>function</code> &mdash; a <em>function designator</em> or <code>nil</code>. </p><p><code>new-function</code> &mdash; a <em>function designator</em>. </p><p><code>set-dispatch-macro-character</code> causes <em>new-function</em> to be called when <em>disp-char</em> followed by <em>sub-char</em> is read. If <em>sub-char</em> is a lowercase letter, it is converted to its uppercase equivalent. It is an error if <em>sub-char</em> is one of the ten decimal digits. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set__1.htm#get-dispatch-macro-character)", "get-decoded-time": "```commonlisp\nget-universal-time <no arguments> => universal-time\nget-decoded-time <no arguments>\n => second, minute, hour, date, month, year, day, daylight-p, zone\n```\n\n<p><code>universal-time</code> &mdash; a <em>universal time</em>. </p><p><code>second</code>, <code>minute</code>, <code>hour</code>, <code>date</code>, <code>month</code>, <code>year</code>, <code>day</code>, <code>daylight-p</code>, <code>zone</code> &mdash; a <em>decoded time</em>. </p><p><code>get-universal-time</code> returns the current time, represented as a <em>universal time</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_un.htm#get-decoded-time)", "get-internal-real-time": "```commonlisp\nget-internal-real-time <no arguments> => internal-time\n```\n\n<p><code>internal-time</code> &mdash; a non-negative <em>integer</em>. </p><p><code>get-internal-real-time</code> returns as an <em>integer</em> the current time in <em>internal time units</em>, relative to an arbitrary time base. The difference between the values of two calls to this function is the amount of elapsed real time (i.e., clock time) between the two calls. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_in.htm#get-internal-real-time)", "gentemp": "```commonlisp\ngentemp &optional prefix package => new-symbol\n```\n\n<p><code>prefix</code> &mdash; a <em>string</em>. The default is <code>\"T\"</code>. </p><p><code>package</code> &mdash; a <em>package designator</em>. The default is the <em>current package</em>. </p><p><code>new-symbol</code> &mdash; a <em>fresh</em>, <em>interned</em> <em>symbol</em>. </p><p><code>gentemp</code> creates and returns a <em>fresh</em> <em>symbol</em>, <em>interned</em> in the indicated <em>package</em>. The <em>symbol</em> is guaranteed to be one that was not previously <em>accessible</em> in <em>package</em>. It is neither <em>bound</em> nor <em>fbound</em>, and has a <em>null</em> <em>property list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_gentem.htm#gentemp)", "get-internal-run-time": "```commonlisp\nget-internal-run-time <no arguments> => internal-time\n```\n\n<p><code>internal-time</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns as an <em>integer</em> the current run time in <em>internal time units</em>. The precise meaning of this quantity is <em>implementation-defined</em>; it may measure real time, run time, CPU cycles, or some other quantity. The intent is that the difference between the values of two calls to this function be the amount of time between the two calls during which computational effort was expended on behalf of the executing program. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get__1.htm#get-internal-run-time)", "get-output-stream-string": "```commonlisp\nget-output-stream-string string-output-stream => string\n```\n\n<p><code>string-output-stream</code> &mdash; a <em>stream</em>. </p><p><code>string</code> &mdash; a <em>string</em>. </p><p>Returns a <em>string</em> containing, in order, all the <em>characters</em> that have been output to <em>string-output-stream</em>. This operation clears any <em>characters</em> on <em>string-output-stream</em>, so the <em>string</em> contains only those <em>characters</em> which have been output since the last call to <code>get-output-stream-string</code> or since the creation of the <em>string-output-stream</em>, whichever occurred most recently. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_ou.htm#get-output-stream-string)", "get-setf-expansion": "```commonlisp\nget-setf-expansion place &optional environment\n => vars, vals, store-vars, writer-form, reader-form\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p> <code>environment</code> &mdash; an <em>environment</em> <em>object</em>.  </p><p><code>vars, vals, store-vars, writer-form, reader-form</code> &mdash; a <em>setf expansion</em>. </p><p>Determines five values constituting the <em>setf expansion</em> for <em>place</em> in <em>environment</em>; see Section 5.1.1.2 (Setf Expansions). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_se.htm#get-setf-expansion)", "get-universal-time": "```commonlisp\nget-universal-time <no arguments> => universal-time\nget-decoded-time <no arguments>\n => second, minute, hour, date, month, year, day, daylight-p, zone\n```\n\n<p><code>universal-time</code> &mdash; a <em>universal time</em>. </p><p><code>second</code>, <code>minute</code>, <code>hour</code>, <code>date</code>, <code>month</code>, <code>year</code>, <code>day</code>, <code>daylight-p</code>, <code>zone</code> &mdash; a <em>decoded time</em>. </p><p><code>get-universal-time</code> returns the current time, represented as a <em>universal time</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_un.htm#get-universal-time)", "get-macro-character": "```commonlisp\nget-macro-character char &optional readtable => function, non-terminating-p\nset-macro-character char new-function &optional non-terminating-p readtable => t\n```\n\n<p><code>char</code> &mdash; a <em>character</em>. </p><p><code>non-terminating-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p> <code>readtable</code> &mdash; a <em>readtable designator</em>.  The default is the <em>current readtable</em>. </p><p><code>function</code> &mdash; <code>nil</code>, or a <em>designator</em> for a <em>function</em> of two <em>arguments</em>. </p><p><code>new-function</code> &mdash; a <em>function designator</em>. </p><p><code>get-macro-character</code> returns as its <em>primary value</em>, <em>function</em>, the <em>reader macro function</em> associated with <em>char</em> in <em>readtable</em> (if any), or else <code>nil</code> if <em>char</em> is not a <em>macro character</em> in <em>readtable</em>. The <em>secondary value</em>, <em>non-terminating-p</em>, is <em>true</em> if <em>char</em> is a <em>non-terminating</em> <em>macro character</em>; otherwise, it is <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_ma.htm#get-macro-character)", "get-properties": "```commonlisp\nget-properties plist indicator-list => indicator, value, tail\n```\n\n<p> <code>plist</code> &mdash; a <em>property list</em>.  </p><p><code>indicator-list</code> &mdash; a <em>proper list</em> (of <em>indicators</em>). </p><p><code>indicator</code> &mdash; an <em>object</em> that is an <em>element</em> of <em>indicator-list</em>. </p><p><code>value</code> &mdash; an <em>object</em>. </p><p><code>tail</code> &mdash; a <em>list</em>. </p><p><code>get-properties</code> is used to look up any of several <em>property list</em> entries all at once. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_get_pr.htm#get-properties)", "hash-table-count": "```commonlisp\nhash-table-count hash-table => count\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>count</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the number of entries in the <em>hash-table</em>. If <em>hash-table</em> has just been created or newly cleared (see <code>clrhash</code>) the entry count is <code>0</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_1.htm#hash-table-count)", "graphic-char-p": "```commonlisp\n```\n\n<p><code>char</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>character</em> is a <em>graphic</em> <em>character</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_graphi.htm#graphic-char-p)", "hash-table-p": "```commonlisp\nhash-table-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>hash-table</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_t.htm#hash-table-p)", "hash-table-rehash-threshold": "```commonlisp\nhash-table-rehash-threshold hash-table => rehash-threshold\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p> <code>rehash-threshold</code> &mdash; a <em>real</em> of <em>type</em> <code>(real 0 1)</code>.  </p><p>Returns the current rehash threshold of <em>hash-table</em>, which is suitable for use in a call to <code>make-hash-table</code> in order to produce a <em>hash table</em> with state corresponding to the current state of the <em>hash-table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_3.htm#hash-table-rehash-threshold)", "hash-table-test": "```commonlisp\nhash-table-test hash-table => test\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>test</code> &mdash; a <em>function designator</em>. For the four <em>standardized</em> <em>hash table</em> test <em>functions</em> (see <code>make-hash-table</code>), the <em>test</em> value returned is always a <em>symbol</em>. If an <em>implementation</em> permits additional tests, it is <em>implementation-dependent</em> whether such tests are returned as <em>function</em> <em>objects</em> or <em>function names</em>. </p><p>Returns the test used for comparing <em>keys</em> in <em>hash-table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_5.htm#hash-table-test)", "hash-table-rehash-size": "```commonlisp\nhash-table-rehash-size hash-table => rehash-size\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>rehash-size</code> &mdash; a <em>real</em> of <em>type</em> <code>(or (integer 1 *) (float (1.0) *))</code>. </p><p>Returns the current rehash size of <em>hash-table</em>, suitable for use in a call to <code>make-hash-table</code> in order to produce a <em>hash table</em> with state corresponding to the current state of the <em>hash-table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_2.htm#hash-table-rehash-size)", "hash-table-size": "```commonlisp\nhash-table-size hash-table => size\n```\n\n<p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>size</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the current size of <em>hash-table</em>, which is suitable for use in a call to <code>make-hash-table</code> in order to produce a <em>hash table</em> with state corresponding to the current state of the <em>hash-table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_hash_4.htm#hash-table-size)", "imagpart": "```commonlisp\nrealpart number => real\nimagpart number => real\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>real</code> &mdash; a <em>real</em>. </p><p><code>realpart</code> and <code>imagpart</code> return the real and imaginary parts of <em>number</em> respectively. If <em>number</em> is  <em>real</em>,  then <code>realpart</code> returns <em>number</em> and <code>imagpart</code> returns <code>(* 0 </code><em>number</em><code>)</code>, which has the effect that the imaginary part of a <em>rational</em> is <code>0</code> and that of a <em>float</em> is a floating-point zero of the same format. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_realpa.htm#imagpart)", "host-namestring": "```commonlisp\nnamestring pathname => namestring\nfile-namestring pathname => namestring\ndirectory-namestring pathname => namestring\nhost-namestring pathname => namestring\nenough-namestring pathname &optional defaults => namestring\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>defaults</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p><code>namestring</code> &mdash; a <em>string</em> or <code>nil</code>.  </p><p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_namest.htm#host-namestring)", "identity": "```commonlisp\nidentity object => object\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p>Returns its argument <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_identi.htm#identity)", "import": "```commonlisp\nimport symbols &optional package => t\n```\n\n<p><code>symbols</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>symbols</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>import</code> adds <em>symbol</em> or <em>symbols</em> to the internals of <em>package</em>, checking for name conflicts with existing <em>symbols</em> either <em>present</em> in <em>package</em> or <em>accessible</em> to it. Once the <em>symbols</em> have been <em>imported</em>, they may be referenced in the <em>importing</em> <em>package</em> without the use of a <em>package prefix</em> when using the <em>Lisp reader</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_import.htm#import)", "inspect": "```commonlisp\ninspect object => implementation-dependent\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>inspect</code> is an interactive version of <code>describe</code>. The nature of the interaction is <em>implementation-dependent</em>, but the purpose of <code>inspect</code> is to make it easy to wander through a data structure, examining and modifying parts of it. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_inspec.htm#inspect)", "input-stream-p": "```commonlisp\ninput-stream-p stream => generalized-boolean\noutput-stream-p stream => generalized-boolean\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>input-stream-p</code> returns <em>true</em> if <em>stream</em> is an <em>input</em> <em>stream</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_in_stm.htm#input-stream-p)", "integer-length": "```commonlisp\ninteger-length integer => number-of-bits\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>number-of-bits</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the number of bits needed to represent <em>integer</em> in binary two's-complement format. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_intege.htm#integer-length)", "integerp": "```commonlisp\nintegerp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>integer</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_inte_1.htm#integerp)", "integer-decode-float": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#integer-decode-float)", "invalid-method-error": "```commonlisp\ninvalid-method-error method format-control &rest args => implementation-dependent\n```\n\n<p><code>method</code> &mdash; a <em>method</em>. </p><p> <code>format-control</code> &mdash; a <em>format control</em>.  </p><p><code>args</code> &mdash; <em>format arguments</em> for the <em>format-control</em>. </p><p>The <em>function</em> <code>invalid-method-error</code> is used to signal an error of <em>type</em> <code>error</code> when there is an applicable <em>method</em> whose <em>qualifiers</em> are not valid for the method combination type. The error message is constructed by using the <em>format-control</em> suitable for <code>format</code> and any <em>args</em> to it. Because an implementation may need to add additional contextual information to the error message, <code>invalid-method-error</code> should be called only within the dynamic extent of a method combination function. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_invali.htm#invalid-method-error)", "interactive-stream-p": "```commonlisp\ninteractive-stream-p stream => generalized-boolean\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>stream</em> is an <em>interactive stream</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_intera.htm#interactive-stream-p)", "intern": "```commonlisp\nintern string &optional package => symbol, status\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>status</code> &mdash; one of <code>:inherited</code>, <code>:external</code>, <code>:internal</code>, or <code>nil</code>. </p><p><code>intern</code> enters a <em>symbol</em> named <em>string</em> into <em>package</em>. If a <em>symbol</em> whose name is the same as <em>string</em> is already <em>accessible</em> in <em>package</em>, it is returned. If no such <em>symbol</em> is <em>accessible</em> in <em>package</em>, a new <em>symbol</em> with the given name is created and entered into <em>package</em> as an <em>internal symbol</em>, or as an <em>external symbol</em> if the <em>package</em> is the <code>KEYWORD</code> package; <em>package</em> becomes the <em>home package</em> of the created <em>symbol</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_intern.htm#intern)", "intersection": "```commonlisp\nintersection list-1 list-2 &key key test test-not => result-list\nnintersection list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>intersection</code> and <code>nintersection</code> return a <em>list</em> that contains every element that occurs in both <em>list-1</em> and <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_isec_.htm#intersection)", "invoke-restart-interactively": "```commonlisp\ninvoke-restart-interactively restart => result*\n```\n\n<p><code>restart</code> &mdash; a <em>restart designator</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>function</em> associated with <em>restart</em>, if that <em>function</em> returns. </p><p><code>invoke-restart-interactively</code> calls the <em>function</em> associated with <em>restart</em>, prompting for any necessary arguments. If <em>restart</em> is a name, it must be valid in the current <em>dynamic environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_2.htm#invoke-restart-interactively)", "invoke-debugger": "```commonlisp\ninvoke-debugger condition =>| \n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> <em>object</em>. </p><p><code>invoke-debugger</code> attempts to enter the debugger with <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_invoke.htm#invoke-debugger)", "invoke-restart": "```commonlisp\ninvoke-restart restart &rest arguments => result*\n```\n\n<p><code>restart</code> &mdash; a <em>restart designator</em>. </p><p><code>argument</code> &mdash; an <em>object</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>function</em> associated with <em>restart</em>, if that <em>function</em> returns. </p><p>Calls the <em>function</em> associated with <em>restart</em>, passing <em>arguments</em> to it. <em>Restart</em> must be valid in the current <em>dynamic environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_1.htm#invoke-restart)", "isqrt": "```commonlisp\nsqrt number => root\nisqrt natural => natural-root\n```\n\n<p><code>number</code>, <code>root</code> &mdash; a <em>number</em>. </p><p><code>natural</code>, <code>natural-root</code> &mdash; a non-negative <em>integer</em>. </p><p><code>sqrt</code> and <code>isqrt</code> compute square roots. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sqrt_.htm#isqrt)", "keywordp": "```commonlisp\nkeywordp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is a <em>keyword</em>[1]; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_kwdp.htm#keywordp)", "lcm": "```commonlisp\nlcm &rest integers => least-common-multiple\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>least-common-multiple</code> &mdash; a non-negative <em>integer</em>. </p><p><code>lcm</code> returns the least common multiple of the <em>integers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_lcm.htm#lcm)", "ldb-test": "```commonlisp\nldb-test bytespec integer => generalized-boolean\n```\n\n<p><code>bytespec</code> &mdash; a <em>byte specifier</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if any of the bits of the byte in <em>integer</em> specified by <em>bytespec</em> is non-zero; otherwise returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ldb_te.htm#ldb-test)", "last": "```commonlisp\nlast list &optional n => tail\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> but must not be a <em>circular list</em>.  </p><p> <code>n</code> &mdash; a non-negative <em>integer</em>. The default is <code>1</code>.  </p><p><code>tail</code> &mdash; an <em>object</em>. </p><p><code>last</code> returns the last <em>n</em> <em>conses</em> (not the last <em>n</em> elements) of <em>list</em>). If <em>list</em> is <code>()</code>, <code>last</code> returns <code>()</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_last.htm#last)", "ldiff": "```commonlisp\nldiff list object => result-list\ntailp object list => generalized-boolean\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em>. </p><p><code>object</code> &mdash; an <em>object</em>.  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p> If <em>object</em> is the <em>same</em> as some <em>tail</em> of <em>list</em>, <code>tailp</code> returns <em>true</em>; otherwise, it returns <em>false</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ldiffc.htm#ldiff)", "length": "```commonlisp\nlength sequence => n\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>n</code> &mdash; a non-negative <em>integer</em>. </p><p>Returns the number of <em>elements</em> in <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_length.htm#length)", "list-all-packages": "```commonlisp\nlist-all-packages <no arguments> => packages\n```\n\n<p><code>packages</code> &mdash; a <em>list</em> of <em>package</em> <em>objects</em>. </p><p><code>list-all-packages</code> returns a  <em>fresh</em>  <em>list</em> of  all <em>registered packages</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_list_a.htm#list-all-packages)", "lisp-implementation-version": "```commonlisp\nlisp-implementation-type <no arguments> => description\nlisp-implementation-version <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>lisp-implementation-type</code> and <code>lisp-implementation-version</code> identify the current implementation of Common Lisp. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_lisp_i.htm#lisp-implementation-version)", "list*": "```commonlisp\nlist &rest objects => list\nlist* &rest objects+ => result\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>list</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>list</code> returns a <em>list</em> containing the supplied <em>objects</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_list_.htm#listST)", "lisp-implementation-type": "```commonlisp\nlisp-implementation-type <no arguments> => description\nlisp-implementation-version <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>lisp-implementation-type</code> and <code>lisp-implementation-version</code> identify the current implementation of Common Lisp. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_lisp_i.htm#lisp-implementation-type)", "listen": "```commonlisp\nlisten &optional input-stream => generalized-boolean\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if there is a character immediately available from <em>input-stream</em>; otherwise, returns <em>false</em>. On a non-interactive <em>input-stream</em>, <code>listen</code> returns <em>true</em> except when at <em>end of file</em>[1]. If an <em>end of file</em> is encountered, <code>listen</code> returns <em>false</em>. <code>listen</code> is intended to be used when <em>input-stream</em> obtains characters from an interactive device such as a keyboard. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_listen.htm#listen)", "listp": "```commonlisp\nlistp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>list</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_listp.htm#listp)", "list-length": "```commonlisp\nlist-length list => length\n```\n\n<p><code>list</code> &mdash; a <em>proper list</em> or a <em>circular list</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p>Returns the <em>length</em> of <em>list</em> if <em>list</em> is a <em>proper list</em>. Returns <code>nil</code> if <em>list</em> is a <em>circular list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_list_l.htm#list-length)", "log": "```commonlisp\nlog number &optional base => logarithm\n```\n\n<p><code>number</code> &mdash; a non-zero <em>number</em>. </p><p><code>base</code> &mdash; a <em>number</em>. </p><p><code>logarithm</code> &mdash; a <em>number</em>. </p><p><code>log</code> returns the logarithm of <em>number</em> in base <em>base</em>. If <em>base</em> is not supplied its value is <em>e</em>, the base of the natural logarithms. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_log.htm#log)", "load": "```commonlisp\nload filespec &key verbose print if-does-not-exist external-format\n => generalized-boolean\n```\n\n<p><code>filespec</code> &mdash; a <em>stream</em>, or a <em>pathname designator</em>. The default is taken from <code>*default-pathname-defaults*</code>. </p><p><code>verbose</code> &mdash; a <em>generalized boolean</em>. The default is the <em>value</em> of <code>*load-verbose*</code>. </p><p><code>print</code> &mdash; a <em>generalized boolean</em>. The default is the <em>value</em> of <code>*load-print*</code>. </p><p><code>if-does-not-exist</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>external-format</code> &mdash; an <em>external file format designator</em>. The default is <code>:default</code>.  </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>load</code> <em>loads</em> the <em>file</em> named by <em>filespec</em> into the Lisp environment. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_load.htm#load)", "logandc1": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logandc1)", "logand": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logand)", "load-logical-pathname-translations": "```commonlisp\nload-logical-pathname-translations host => just-loaded\n```\n\n<p><code>host</code> &mdash; a <em>string</em>. </p><p><code>just-loaded</code> &mdash; a <em>generalized boolean</em>. </p><p>Searches for and loads the definition of a <em>logical host</em> named <em>host</em>, if it is not already defined. The specific nature of the search is <em>implementation-defined</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ld_log.htm#load-logical-pathname-translations)", "logcount": "```commonlisp\nlogcount integer => number-of-on-bits\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>number-of-on-bits</code> &mdash; a non-negative <em>integer</em>. </p><p>Computes and returns the number of bits in the two's-complement binary representation of <em>integer</em> that are `on' or `set'. If <em>integer</em> is negative, the <code>0</code> bits are counted; otherwise, the <code>1</code> bits are counted. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logcou.htm#logcount)", "logbitp": "```commonlisp\nlogbitp index integer => generalized-boolean\n```\n\n<p> <code>index</code> &mdash; a non-negative <em>integer</em>.  </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>logbitp</code> is used to test the value of a particular bit in <em>integer</em>, that is treated as if it were binary. The value of <code>logbitp</code> is <em>true</em> if the bit in <em>integer</em> whose index is <em>index</em> (that is, its weight is 2^<em>index</em>) is a one-bit; otherwise it is <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logbtp.htm#logbitp)", "logeqv": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logeqv)", "logtest": "```commonlisp\nlogtest integer-1 integer-2 => generalized-boolean\n```\n\n<p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if any of the bits designated by the 1's in <em>integer-1</em> is 1 in <em>integer-2</em>; otherwise it is <em>false</em>. <em>integer-1</em> and <em>integer-2</em> are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logtes.htm#logtest)", "logior": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logior)", "long-site-name": "```commonlisp\nshort-site-name <no arguments> => description\nlong-site-name <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>short-site-name</code> and <code>long-site-name</code> return a <em>string</em> that identifies the physical location of the computer hardware, or <code>nil</code> if no appropriate <em>description</em> can be produced. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_short_.htm#long-site-name)", "lognand": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#lognand)", "lower-case-p": "```commonlisp\nupper-case-p character => generalized-boolean\nlower-case-p character => generalized-boolean\nboth-case-p character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These functions test the case of a given <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upper_.htm#lower-case-p)", "lognot": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#lognot)", "machine-instance": "```commonlisp\nmachine-instance <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p>Returns a <em>string</em> that identifies the particular instance of the computer hardware on which Common Lisp is running, or <code>nil</code> if no such <em>string</em> can be computed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mach_i.htm#machine-instance)", "logxor": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logxor)", "machine-type": "```commonlisp\nmachine-type <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p>Returns a <em>string</em> that identifies the generic name of the computer hardware on which Common Lisp is running. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mach_t.htm#machine-type)", "machine-version": "```commonlisp\nmachine-version <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p>Returns a <em>string</em> that identifies the version of the computer hardware on which Common Lisp is running, or <code>nil</code> if no such value can be computed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mach_v.htm#machine-version)", "lognor": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#lognor)", "make-broadcast-stream": "```commonlisp\nmake-broadcast-stream &rest streams => broadcast-stream\n```\n\n<p><code>stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>broadcast-stream</code> &mdash; a <em>broadcast stream</em>. </p><p>Returns a <em>broadcast stream</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_bro.htm#make-broadcast-stream)", "logorc1": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logorc1)", "logorc2": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logorc2)", "macroexpand-1": "```commonlisp\nmacroexpand form &optional env => expansion, expanded-p\nmacroexpand-1 form &optional env => expansion, expanded-p\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>env</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>. </p><p><code>expansion</code> &mdash; a <em>form</em>. </p><p> <code>expanded-p</code> &mdash; a <em>generalized boolean</em>.  </p><p><code>macroexpand</code> and <code>macroexpand-1</code> expand <em>macros</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mexp_.htm#macroexpand-1)", "make-echo-stream": "```commonlisp\nmake-echo-stream input-stream output-stream => echo-stream\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>echo-stream</code> &mdash; an <em>echo stream</em>. </p><p>Creates and returns an <em>echo stream</em> that takes input from <em>input-stream</em> and sends output to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_ech.htm#make-echo-stream)", "make-concatenated-stream": "```commonlisp\nmake-concatenated-stream &rest input-streams => concatenated-stream\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>concatenated-stream</code> &mdash; a <em>concatenated stream</em>. </p><p>Returns a <em>concatenated stream</em> that has the indicated <em>input-streams</em> initially associated with it. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_con.htm#make-concatenated-stream)", "make-array": "```commonlisp\nmake-array dimensions &key element-type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset\n => new-array\n```\n\n<p><code>dimensions</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>valid array dimensions</em>. </p><p><code>element-type</code> &mdash; a <em>type specifier</em>. The default is <code>t</code>. </p><p><code>initial-element</code> &mdash; an <em>object</em>. </p><p><code>initial-contents</code> &mdash; an <em>object</em>. </p><p><code>adjustable</code> &mdash; a <em>generalized boolean</em>. The default is <code>nil</code>. </p><p><code>fill-pointer</code> &mdash; a <em>valid fill pointer</em> for the <em>array</em> to be created, or <code>t</code> or <code>nil</code>. The default is <code>nil</code>. </p><p><code>displaced-to</code> &mdash; an <em>array</em> or <code>nil</code>. The default is <code>nil</code>. This option must not be supplied if either <em>initial-element</em> or <em>initial-contents</em> is supplied. </p><p><code>displaced-index-offset</code> &mdash; a <em>valid array row-major index</em> for <em>displaced-to</em>. The default is <code>0</code>. This option must not be supplied unless a <em>non-nil</em> <em>displaced-to</em> is supplied. </p><p><code>new-array</code> &mdash; an <em>array</em>. </p><p>Creates and returns an <em>array</em> constructed of the most <em>specialized</em> <em>type</em> that can accommodate elements of <em>type</em> given by <em>element-type</em>. If <em>dimensions</em> is <code>nil</code> then a zero-dimensional <em>array</em> is created. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_ar.htm#make-array)", "macroexpand": "```commonlisp\nmacroexpand form &optional env => expansion, expanded-p\nmacroexpand-1 form &optional env => expansion, expanded-p\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>env</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>. </p><p><code>expansion</code> &mdash; a <em>form</em>. </p><p> <code>expanded-p</code> &mdash; a <em>generalized boolean</em>.  </p><p><code>macroexpand</code> and <code>macroexpand-1</code> expand <em>macros</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mexp_.htm#macroexpand)", "logandc2": "```commonlisp\nlogand &rest integers => result-integer\nlogandc1 integer-1 integer-2 => result-integer\nlogandc2 integer-1 integer-2 => result-integer\nlogeqv &rest integers => result-integer\nlogior &rest integers => result-integer\nlognand integer-1 integer-2 => result-integer\nlognor integer-1 integer-2 => result-integer\nlognot integer => result-integer\nlogorc1 integer-1 integer-2 => result-integer\nlogorc2 integer-1 integer-2 => result-integer\nlogxor &rest integers => result-integer\n```\n\n<p><code>integers</code> &mdash; <em>integers</em>. </p><p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>integer-1</code> &mdash; an <em>integer</em>. </p><p><code>integer-2</code> &mdash; an <em>integer</em>. </p><p><code>result-integer</code> &mdash; an <em>integer</em>. </p><p>The <em>functions</em> <code>logandc1</code>, <code>logandc2</code>, <code>logand</code>, <code>logeqv</code>, <code>logior</code>, <code>lognand</code>, <code>lognor</code>, <code>lognot</code>, <code>logorc1</code>, <code>logorc2</code>, and <code>logxor</code> perform bit-wise logical operations on their <em>arguments</em>, that are treated as if they were binary. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_logand.htm#logandc2)", "make-dispatch-macro-character": "```commonlisp\nmake-dispatch-macro-character char &optional non-terminating-p readtable => t\n```\n\n<p> <code>char</code> &mdash; a <em>character</em>.  </p><p><code>non-terminating-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>readtable</code> &mdash; a <em>readtable</em>. The default is the <em>current readtable</em>. </p><p><code>make-dispatch-macro-character</code> makes <em>char</em> be a <em>dispatching macro character</em> in <em>readtable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_dis.htm#make-dispatch-macro-character)", "make-load-form-saving-slots": "```commonlisp\nmake-load-form-saving-slots object &key slot-names environment\n => creation-form, initialization-form\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>slot-names</code> &mdash; a <em>list</em>. </p><p><code>environment</code> &mdash; an <em>environment object</em>. </p><p><code>creation-form</code> &mdash; a <em>form</em>. </p><p><code>initialization-form</code> &mdash; a <em>form</em>. </p><p> Returns <em>forms</em> that, when <em>evaluated</em>, will construct an <em>object</em> equivalent to <em>object</em>, without <em>executing</em> <em>initialization forms</em>. The <em>slots</em> in the new <em>object</em> that correspond to initialized <em>slots</em> in <em>object</em> are initialized using the values from <em>object</em>. Uninitialized <em>slots</em> in <em>object</em> are not initialized in the new <em>object</em>. <code>make-load-form-saving-slots</code> works for any <em>instance</em> of <code>standard-object</code> or <code>structure-object</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_l_1.htm#make-load-form-saving-slots)", "make-condition": "```commonlisp\nmake-condition type &rest slot-initializations => condition\n```\n\n<p><code>type</code> &mdash; a <em>type specifier</em> (for a <em>subtype</em> of <code>condition</code>). </p><p><code>slot-initializations</code> &mdash; an <em>initialization argument list</em>. </p><p><code>condition</code> &mdash; a <em>condition</em>. </p><p>Constructs and returns a <em>condition</em> of type <em>type</em> using <em>slot-initializations</em> for the initial values of the slots. The newly created <em>condition</em> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_cnd.htm#make-condition)", "make-list": "```commonlisp\nmake-list size &key initial-element => list\n```\n\n<p><code>size</code> &mdash; a non-negative <em>integer</em>. </p><p><code>initial-element</code> &mdash; an <em>object</em>. The default is <code>nil</code>. </p><p><code>list</code> &mdash; a <em>list</em>. </p><p>Returns a <em>list</em> of <em>length</em> given by <em>size</em>, each of the <em>elements</em> of which is <em>initial-element</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_lis.htm#make-list)", "make-hash-table": "```commonlisp\nmake-hash-table &key test size rehash-size rehash-threshold => hash-table\n```\n\n<p><code>test</code> &mdash; a <em>designator</em> for one of the <em>functions</em> <code>eq</code>, <code>eql</code>, <code>equal</code>, or  <code>equalp</code>.  The default is <code>eql</code>. </p><p> <code>size</code> &mdash; a non-negative <em>integer</em>.  The default is <em>implementation-dependent</em>. </p><p><code>rehash-size</code> &mdash; a <em>real</em> of <em>type</em> <code>(or (integer 1 *) (float (1.0) *))</code>. The default is <em>implementation-dependent</em>. </p><p> <code>rehash-threshold</code> &mdash; a <em>real</em> of <em>type</em> <code>(real 0 1)</code>. The default is <em>implementation-dependent</em>.  </p><p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p>Creates and returns a new <em>hash table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_has.htm#make-hash-table)", "make-random-state": "```commonlisp\nmake-random-state &optional state => new-state\n```\n\n<p><code>state</code> &mdash; a <em>random state</em>, or <code>nil</code>, or <code>t</code>. The default is <code>nil</code>. </p><p><code>new-state</code> &mdash; a <em>random state</em> <em>object</em>. </p><p>Creates a <em>fresh</em> <em>object</em> of <em>type</em> <code>random-state</code> suitable for use as the <em>value</em> of <code>*random-state*</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_rnd.htm#make-random-state)", "make-package": "```commonlisp\nmake-package package-name &key nicknames use => package\n```\n\n<p><code>package-name</code> &mdash; a <em>string designator</em>. </p><p><code>nicknames</code> &mdash; a <em>list</em> of <em>string designators</em>. The default is the <em>empty list</em>. </p><p> <code>use</code> &mdash; a <em>list</em> of <em>package designators</em>.  The default is <em>implementation-defined</em>.   </p><p><code>package</code> &mdash; a <em>package</em>. </p><p>Creates a new <em>package</em> with the name <em>package-name</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_pkg.htm#make-package)", "make-string-input-stream": "```commonlisp\nmake-string-input-stream string &optional start end => string-stream\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p> <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.  </p><p> <code>string-stream</code> &mdash; an <em>input</em> <em>string stream</em>.  </p><p>Returns an <em>input</em> <em>string stream</em>. This <em>stream</em> will supply, in order, the <em>characters</em> in the substring of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em>. After the last <em>character</em> has been supplied, the <em>string stream</em> will then be at <em>end of file</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_s_1.htm#make-string-input-stream)", "make-sequence": "```commonlisp\nmake-sequence result-type size &key initial-element => sequence\n```\n\n<p>  <code>result-type</code> &mdash; a <code>sequence</code> <em>type specifier</em>.   </p><p> <code>size</code> &mdash; a non-negative <em>integer</em>.  </p><p><code>initial-element</code> &mdash; an <em>object</em>. The default is <em>implementation-dependent</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p>Returns a <em>sequence</em> of the type <em>result-type</em> and of length <em>size</em>, each of the <em>elements</em> of which has been initialized to <em>initial-element</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_seq.htm#make-sequence)", "make-pathname": "```commonlisp\nmake-pathname &key host device directory name type version defaults case\n => pathname\n```\n\n<p> <code>host</code> &mdash; a <em>valid physical pathname host</em>. Complicated defaulting behavior; see below. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. Complicated defaulting behavior; see below. </p><p><code>directory</code> &mdash; a <em>valid pathname directory</em>. Complicated defaulting behavior; see below. </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. Complicated defaulting behavior; see below. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. Complicated defaulting behavior; see below. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. Complicated defaulting behavior; see below.  </p><p><code>defaults</code> &mdash; a <em>pathname designator</em>. The default is a <em>pathname</em> whose host component is the same as the host component of the <em>value</em> of <code>*default-pathname-defaults*</code>, and whose other components are all <code>nil</code>. </p><p> <code>case</code> &mdash; one of <code>:common</code> or <code>:local</code>. The default is <code>:local</code>.  </p><p><code>pathname</code> &mdash; a <em>pathname</em>. </p><p>Constructs and returns a <em>pathname</em> from the supplied keyword arguments. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_pn.htm#make-pathname)", "make-string": "```commonlisp\nmake-string size &key initial-element element-type => string\n```\n\n<p> <code>size</code> &mdash; a <em>valid array dimension</em>.  </p><p> <code>initial-element</code> &mdash; a <em>character</em>.  The default is <em>implementation-dependent</em>. </p><p> <code>element-type</code> &mdash; a <em>type specifier</em>. The default is <code>character</code>.  </p><p><code>string</code> &mdash; a <em>simple string</em>. </p><p><code>make-string</code> returns a <em>simple string</em> of length <em>size</em> whose elements have been initialized to <em>initial-element</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_stg.htm#make-string)", "make-string-output-stream": "```commonlisp\nmake-string-output-stream &key element-type => string-stream\n```\n\n<p> <code>element-type</code> &mdash; a <em>type specifier</em>. The default is <code>character</code>.  </p><p> <code>string-stream</code> &mdash; an <em>output</em> <em>string stream</em>.  </p><p>Returns  an <em>output</em> <em>string stream</em> that accepts <em>characters</em> and makes available (via <code>get-output-stream-string</code>) a <em>string</em> that contains the <em>characters</em> that were actually output. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_s_2.htm#make-string-output-stream)", "make-symbol": "```commonlisp\nmake-symbol name => new-symbol\n```\n\n<p><code>name</code> &mdash; a <em>string</em>. </p><p><code>new-symbol</code> &mdash; a <em>fresh</em>, <em>uninterned</em> <em>symbol</em>. </p><p><code>make-symbol</code> creates and returns a <em>fresh</em>, <em>uninterned</em> <em>symbol</em> whose <em>name</em> is the given <em>name</em>. The <em>new-symbol</em> is neither <em>bound</em> nor <em>fbound</em> and has a <em>null</em> <em>property list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_sym.htm#make-symbol)", "make-synonym-stream": "```commonlisp\nmake-synonym-stream symbol => synonym-stream\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em> that names a <em>dynamic variable</em>. </p><p> <code>synonym-stream</code> &mdash; a <em>synonym stream</em>.  </p><p>Returns a <em>synonym stream</em> whose <em>synonym stream symbol</em> is <em>symbol</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_syn.htm#make-synonym-stream)", "make-two-way-stream": "```commonlisp\nmake-two-way-stream input-stream output-stream => two-way-stream\n```\n\n<p><code>input-stream</code> &mdash; a <em>stream</em>. </p><p><code>output-stream</code> &mdash; a <em>stream</em>. </p><p> <code>two-way-stream</code> &mdash; a <em>two-way stream</em>.  </p><p>Returns a <em>two-way stream</em> that gets its input from <em>input-stream</em> and sends its output to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_two.htm#make-two-way-stream)", "makunbound": "```commonlisp\nmakunbound symbol => symbol\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em> </p><p>Makes the <em>symbol</em> be <em>unbound</em>, regardless of whether it was previously <em>bound</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_makunb.htm#makunbound)", "mapcan": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#mapcan)", "map": "```commonlisp\nmap result-type function &rest sequences+ => result\n```\n\n<p> <code>result-type</code>  &mdash;  a <code>sequence</code> <code>type specifier</code>, or <code>nil</code>.  </p><p> <code>function</code> &mdash; a <em>function designator</em>. <em>function</em> must take as many arguments as there are <em>sequences</em>.  </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>result</code> &mdash; if <em>result-type</em> is a <em>type specifier</em> other than <code>nil</code>, then a <em>sequence</em> of the <em>type</em> it denotes; otherwise (if the <em>result-type</em> is <code>nil</code>), <code>nil</code>. </p><p>Applies <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. The <em>function</em> is called first on all the elements with index <code>0</code>, then on all those with index <code>1</code>, and so on. The <em>result-type</em> specifies the <em>type</em> of the resulting <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_map.htm#map)", "maphash": "```commonlisp\nmaphash function hash-table => nil\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em>, the <em>key</em> and the <em>value</em>. </p><p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p>Iterates over all entries in the <code>hash-table</code>. For each entry, the <code>function</code> is called with two <code>arguments</code> &mdash; the <em>key</em> and the <em>value</em> of that entry. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_maphas.htm#maphash)", "max": "```commonlisp\nmax &rest reals+ => max-real\nmin &rest reals+ => min-real\n```\n\n<p><code>real</code> &mdash; a <em>real</em>. </p><p><code>max-real</code>, <code>min-real</code> &mdash; a <em>real</em>. </p><p><code>max</code> returns the <em>real</em> that is greatest (closest to positive infinity). <code>min</code> returns the <em>real</em> that is least (closest to negative infinity). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_max_m.htm#max)", "map-into": "```commonlisp\nmap-into result-sequence function &rest sequences => result-sequence\n```\n\n<p><code>result-sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> of as many <em>arguments</em> as there are <em>sequences</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p>Destructively modifies <em>result-sequence</em> to contain the results of applying <em>function</em> to each element in the argument <em>sequences</em> in turn. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_map_in.htm#map-into)", "mapc": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#mapc)", "member-if-not": "```commonlisp\nmember item list &key key test test-not => tail\nmember-if predicate list &key key => tail\nmember-if-not predicate list &key key => tail\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>tail</code> &mdash; a <em>list</em>. </p><p><code>member</code>, <code>member-if</code>, and <code>member-if-not</code> each search <em>list</em> for <em>item</em> or for a top-level element that <em>satisfies the test</em>. The argument to the <em>predicate</em> function is an element of <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mem_m.htm#member-if-not)", "mapl": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#mapl)", "min": "```commonlisp\nmax &rest reals+ => max-real\nmin &rest reals+ => min-real\n```\n\n<p><code>real</code> &mdash; a <em>real</em>. </p><p><code>max-real</code>, <code>min-real</code> &mdash; a <em>real</em>. </p><p><code>max</code> returns the <em>real</em> that is greatest (closest to positive infinity). <code>min</code> returns the <em>real</em> that is least (closest to negative infinity). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_max_m.htm#min)", "merge": "```commonlisp\nmerge result-type sequence-1 sequence-2 predicate &key key => result-sequence\n```\n\n<p> <code>result-type</code> &mdash; a <code>sequence</code> <em>type specifier</em>.  </p><p><code>sequence-1</code> &mdash; a <em>sequence</em>. </p><p><code>sequence-2</code> &mdash; a <em>sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of two arguments that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>proper sequence</em> of <em>type</em> <em>result-type</em>. </p><p>Destructively merges <em>sequence-1</em> with <em>sequence-2</em> according to an order determined by the <em>predicate</em>. <code>merge</code> determines the relationship between two elements by giving keys extracted from the sequence elements to the <em>predicate</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_merge.htm#merge)", "member-if": "```commonlisp\nmember item list &key key test test-not => tail\nmember-if predicate list &key key => tail\nmember-if-not predicate list &key key => tail\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>tail</code> &mdash; a <em>list</em>. </p><p><code>member</code>, <code>member-if</code>, and <code>member-if-not</code> each search <em>list</em> for <em>item</em> or for a top-level element that <em>satisfies the test</em>. The argument to the <em>predicate</em> function is an element of <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mem_m.htm#member-if)", "mapcar": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#mapcar)", "mapcon": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#mapcon)", "minusp": "```commonlisp\nminusp real => generalized-boolean\nplusp real => generalized-boolean\n```\n\n<p><code>real</code> &mdash; a <em>real</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>minusp</code> returns <em>true</em> if <em>real</em> is less than zero; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_minusp.htm#minusp)", "merge-pathnames": "```commonlisp\nmerge-pathnames pathname &optional default-pathname default-version\n => merged-pathname\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>default-pathname</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p> <code>default-version</code> &mdash; a <em>valid pathname version</em>.  The default is <code>:newest</code>. </p><p><code>merged-pathname</code> &mdash; a <em>pathname</em>. </p><p>Constructs a <em>pathname</em> from <em>pathname</em> by filling in any unsupplied components with the corresponding values from <em>default-pathname</em> and <em>default-version</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_merge_.htm#merge-pathnames)", "method-combination-error": "```commonlisp\nmethod-combination-error format-control &rest args => implementation-dependent\n```\n\n<p> <code>format-control</code> &mdash; a <em>format control</em>.  </p><p><code>args</code> &mdash; <em>format arguments</em> for <em>format-control</em>. </p><p>The <em>function</em> <code>method-combination-error</code> is used to signal an error in method combination. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_meth_1.htm#method-combination-error)", "mismatch": "```commonlisp\nmismatch sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2\n => position\n```\n\n<p><code>Sequence-1</code> &mdash; a <em>sequence</em>. </p><p><code>Sequence-2</code> &mdash; a <em>sequence</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>sequence-1</em>. The defaults for <em>start1</em> and <em>end1</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>sequence-2</em>. The defaults for <em>start2</em> and <em>end2</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>position</code> &mdash; a <em>bounding index</em> of <em>sequence-1</em>, or <code>nil</code>. </p><p>The specified subsequences of <em>sequence-1</em> and <em>sequence-2</em> are compared element-wise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mismat.htm#mismatch)", "name-char": "```commonlisp\nname-char name => char-p\n```\n\n<p><code>name</code> &mdash; a <em>string designator</em>. </p><p><code>char-p</code> &mdash; a <em>character</em> or <code>nil</code>. </p><p>Returns the <em>character</em> <em>object</em> whose <em>name</em> is <em>name</em> (as determined by <code>string-equal</code> &mdash; i.e., lookup is not case sensitive). If such a <em>character</em> does not exist, <code>nil</code> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_name_c.htm#name-char)", "nbutlast": "```commonlisp\nbutlast list &optional n => result-list\nnbutlast list &optional n => result-list\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> but must not be a <em>circular list</em>.  </p><p> <code>n</code> &mdash; a non-negative <em>integer</em>.  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>butlast</code> returns a copy of <em>list</em> from which the last <em>n</em>  conses  have been omitted. If <em>n</em> is not supplied, its value is 1. If there are fewer than <em>n</em>  conses  in <em>list</em>, <code>nil</code> is returned and, in the case of <code>nbutlast</code>, <em>list</em> is not modified. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_butlas.htm#nbutlast)", "namestring": "```commonlisp\nnamestring pathname => namestring\nfile-namestring pathname => namestring\ndirectory-namestring pathname => namestring\nhost-namestring pathname => namestring\nenough-namestring pathname &optional defaults => namestring\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>defaults</code> &mdash; a <em>pathname designator</em>.  The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p><code>namestring</code> &mdash; a <em>string</em> or <code>nil</code>.  </p><p>These functions convert <em>pathname</em> into a namestring. The name represented by <em>pathname</em> is returned as a <em>namestring</em> in an <em>implementation-dependent</em> canonical form. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_namest.htm#namestring)", "maplist": "```commonlisp\nmapc function &rest lists+ => list-1\nmapcar function &rest lists+ => result-list\nmapcan function &rest lists+ => concatenated-results\nmapl function &rest lists+ => list-1\nmaplist function &rest lists+ => result-list\nmapcon function &rest lists+ => concatenated-results\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that must take as many <em>arguments</em> as there are <em>lists</em>. </p><p> <code>list</code> &mdash; a <em>proper list</em>. </p><p><code>list-1</code> &mdash; the first <em>list</em> (which must be a <em>proper list</em>).  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>concatenated-results</code> &mdash; a <em>list</em>. </p><p>The mapping operation involves applying <em>function</em> to successive sets of arguments in which one argument is obtained from each <em>sequence</em>. Except for <code>mapc</code> and <code>mapl</code>, the result contains the results returned by <em>function</em>. In the cases of <code>mapc</code> and <code>mapl</code>, the resulting <em>sequence</em> is <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mapc_.htm#maplist)", "nintersection": "```commonlisp\nintersection list-1 list-2 &key key test test-not => result-list\nnintersection list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>intersection</code> and <code>nintersection</code> return a <em>list</em> that contains every element that occurs in both <em>list-1</em> and <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_isec_.htm#nintersection)", "notany": "```commonlisp\nevery predicate &rest sequences+ => generalized-boolean\nsome predicate &rest sequences+ => result\nnotevery predicate &rest sequences+ => generalized-boolean\nnotany predicate &rest sequences+ => generalized-boolean\n```\n\n<p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of as many <em>arguments</em> as there are <em>sequences</em>. </p><p><code>sequence</code> &mdash; a <em>sequence</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>every</code>, <code>some</code>, <code>notevery</code>, and <code>notany</code> test <em>elements</em> of <em>sequences</em> for satisfaction of a given <em>predicate</em>. The first argument to <em>predicate</em> is an <em>element</em> of the first <em>sequence</em>; each succeeding argument is an <em>element</em> of a succeeding <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_everyc.htm#notany)", "nconc": "```commonlisp\nnconc &rest lists => concatenated-list\n```\n\n<p> <code>list</code> &mdash; each but the last must be a <em>list</em> (which might be a <em>dotted list</em> but must not be a <em>circular list</em>); the last <em>list</em> may be any <em>object</em>.  </p><p><code>concatenated-list</code> &mdash; a <em>list</em>. </p><p>Returns a <em>list</em> that is the concatenation of <em>lists</em>. If no <em>lists</em> are supplied, <code>(nconc)</code> returns <code>nil</code>.  <code>nconc</code> is defined using the following recursive relationship: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_nconc.htm#nconc)", "nreconc": "```commonlisp\nrevappend list tail => result-list\nnreconc list tail => result-list\n```\n\n<p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>tail</code> &mdash; an <em>object</em>. </p><p><code>result-list</code> &mdash; an <em>object</em>. </p><p><code>revappend</code> constructs a <em>copy</em>[2] of <em>list</em>, but with the <em>elements</em> in reverse order. It then appends (as if by <code>nconc</code>) the <em>tail</em> to that reversed list and returns the result. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_revapp.htm#nreconc)", "notevery": "```commonlisp\nevery predicate &rest sequences+ => generalized-boolean\nsome predicate &rest sequences+ => result\nnotevery predicate &rest sequences+ => generalized-boolean\nnotany predicate &rest sequences+ => generalized-boolean\n```\n\n<p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of as many <em>arguments</em> as there are <em>sequences</em>. </p><p><code>sequence</code> &mdash; a <em>sequence</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>every</code>, <code>some</code>, <code>notevery</code>, and <code>notany</code> test <em>elements</em> of <em>sequences</em> for satisfaction of a given <em>predicate</em>. The first argument to <em>predicate</em> is an <em>element</em> of the first <em>sequence</em>; each succeeding argument is an <em>element</em> of a succeeding <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_everyc.htm#notevery)", "nreverse": "```commonlisp\nreverse sequence => reversed-sequence\nnreverse sequence => reversed-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>reversed-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>reverse</code> and <code>nreverse</code> return a new <em>sequence</em> of the same kind as <em>sequence</em>, containing the same <em>elements</em>, but in reverse order. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_revers.htm#nreverse)", "nset-difference": "```commonlisp\nset-difference list-1 list-2 &key key test test-not => result-list\nnset-difference list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>set-difference</code> returns a <em>list</em> of elements of <em>list-1</em> that do not appear in <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_di.htm#nset-difference)", "nstring-capitalize": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#nstring-capitalize)", "nstring-upcase": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#nstring-upcase)", "nset-exclusive-or": "```commonlisp\nset-exclusive-or list-1 list-2 &key key test test-not => result-list\nnset-exclusive-or list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>set-exclusive-or</code> returns a <em>list</em> of elements that appear in exactly one of <em>list-1</em> and <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_ex.htm#nset-exclusive-or)", "nsublis": "```commonlisp\nsublis alist tree &key key test test-not => new-tree\nnsublis alist tree &key key test test-not => new-tree\n```\n\n<p><code>alist</code> &mdash; an <em>association list</em>. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>sublis</code> makes substitutions for <em>objects</em> in <em>tree</em> (a structure of <em>conses</em>). <code>nsublis</code> is like <code>sublis</code> but destructively modifies the relevant parts of the <em>tree</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sublis.htm#nsublis)", "nstring-downcase": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#nstring-downcase)", "nsubst-if-not": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#nsubst-if-not)", "nsubst": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#nsubst)", "nsubstitute": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#nsubstitute)", "numberp": "```commonlisp\nnumberp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>number</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_nump.htm#numberp)", "nsubstitute-if": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#nsubstitute-if)", "nsubst-if": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#nsubst-if)", "nthcdr": "```commonlisp\nnthcdr n list => tail\n```\n\n<p> <code>n</code> &mdash; a non-negative <em>integer</em>.  </p><p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em> or a <em>circular list</em>.  </p><p><code>tail</code> &mdash; an <em>object</em>. </p><p>Returns the <em>tail</em> of <em>list</em> that would be obtained by calling <code>cdr</code> <em>n</em> times in succession. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_nthcdr.htm#nthcdr)", "oddp": "```commonlisp\nevenp integer => generalized-boolean\noddp integer => generalized-boolean\n```\n\n<p><code>integer</code> &mdash; an <em>integer</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>evenp</code> returns <em>true</em> if <em>integer</em> is even (divisible by two); otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_evenpc.htm#oddp)", "nsubstitute-if-not": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#nsubstitute-if-not)", "numerator": "```commonlisp\nnumerator rational => numerator\ndenominator rational => denominator\n```\n\n<p><code>rational</code> &mdash; a <em>rational</em>. </p><p><code>numerator</code> &mdash; an <em>integer</em>. </p><p><code>denominator</code> &mdash; a positive <em>integer</em>. </p><p><code>numerator</code> and <code>denominator</code> reduce <em>rational</em> to canonical form and compute the numerator or denominator of that number. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_numera.htm#numerator)", "nunion": "```commonlisp\nunion list-1 list-2 &key key test test-not => result-list\nnunion list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>union</code> and <code>nunion</code> return a <em>list</em> that contains every element that occurs in either <em>list-1</em> or <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unionc.htm#nunion)", "open-stream-p": "```commonlisp\nopen-stream-p stream => generalized-boolean\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>stream</em> is an <em>open</em> <em>stream</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_open_s.htm#open-stream-p)", "open": "```commonlisp\nopen filespec &key direction element-type if-exists if-does-not-exist external-format\n => stream\n```\n\n<p><code>filespec</code> &mdash; a <em>pathname designator</em>. </p><p><code>direction</code> &mdash; one of <code>:input</code>, <code>:output</code>, <code>:io</code>, or <code>:probe</code>. The default is <code>:input</code>. </p><p><code>element-type</code> &mdash; a <em>type specifier</em> for <em>recognizable subtype</em> of <code>character</code>; or a <em>type specifier</em> for a <em>finite</em> <em>recognizable subtype</em> of <em>integer</em>; or one of the <em>symbols</em> <code>signed-byte</code>, <code>unsigned-byte</code>, or <code>:default</code>. The default is <code>character</code>. </p><p><code>if-exists</code> &mdash; one of <code>:error</code>, <code>:new-version</code>, <code>:rename</code>, <code>:rename-and-delete</code>, <code>:overwrite</code>, <code>:append</code>, <code>:supersede</code>, or <code>nil</code>. The default is <code>:new-version</code> if the version component of <em>filespec</em> is <code>:newest</code>, or <code>:error</code> otherwise. </p><p><code>if-does-not-exist</code> &mdash; one of <code>:error</code>, <code>:create</code>, or <code>nil</code>. The default is <code>:error</code> if <em>direction</em> is <code>:input</code> or <em>if-exists</em> is <code>:overwrite</code> or <code>:append</code>; <code>:create</code> if <em>direction</em> is <code>:output</code> or <code>:io</code>, and <em>if-exists</em> is neither <code>:overwrite</code> nor <code>:append</code>; or <code>nil</code> when <em>direction</em> is <code>:probe</code>. </p><p> <code>external-format</code> &mdash; an <em>external file format designator</em>. The default is <code>:default</code>.  </p><p> <code>stream</code> &mdash; a <em>file stream</em> or <code>nil</code>.  </p><p><code>open</code> creates, opens, and returns a <em>file stream</em> that is connected to the file specified by <em>filespec</em>. <em>Filespec</em> is the name of the file to be opened. If the <em>filespec</em> <em>designator</em> is a <em>stream</em>, that <em>stream</em> is not closed first or otherwise affected. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_open.htm#open)", "package-error-package": "```commonlisp\npackage-error-package condition => package\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>package-error</code>. </p><p><code>package</code> &mdash; a <em>package designator</em>. </p><p>Returns a <em>designator</em> for the offending <em>package</em> in the <em>situation</em> represented by the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg_er.htm#package-error-package)", "output-stream-p": "```commonlisp\ninput-stream-p stream => generalized-boolean\noutput-stream-p stream => generalized-boolean\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>input-stream-p</code> returns <em>true</em> if <em>stream</em> is an <em>input</em> <em>stream</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_in_stm.htm#output-stream-p)", "package-name": "```commonlisp\npackage-name package => name\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>name</code> &mdash; a <em>string</em>  or <code>nil</code>.  </p><p><code>package-name</code> returns the <em>string</em> that names <em>package</em>,  or <code>nil</code> if the <em>package</em> <em>designator</em> is a <em>package</em> <em>object</em> that has no name (see the <em>function</em> <code>delete-package</code>).  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg_na.htm#package-name)", "package-nicknames": "```commonlisp\npackage-nicknames package => nicknames\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>nicknames</code> &mdash; a <em>list</em> of <em>strings</em>. </p><p>Returns the <em>list</em> of nickname <em>strings</em> for <em>package</em>, not including the name of <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg_ni.htm#package-nicknames)", "packagep": "```commonlisp\npackagep object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>package</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkgp.htm#packagep)", "package-shadowing-symbols": "```commonlisp\npackage-shadowing-symbols package => symbols\n```\n\n<p><code>package</code> &mdash; a <em>package designator</em>. </p><p><code>symbols</code> &mdash; a <em>list</em> of <em>symbols</em>. </p><p>Returns a <em>list</em> of <em>symbols</em> that have been declared as <em>shadowing symbols</em> in <em>package</em> by <code>shadow</code> or <code>shadowing-import</code> (or the equivalent <code>defpackage</code> options). All <em>symbols</em> on this <em>list</em> are <em>present</em> in <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg_sh.htm#package-shadowing-symbols)", "package-used-by-list": "```commonlisp\npackage-used-by-list package => used-by-list\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>used-by-list</code> &mdash; a <em>list</em> of <em>package</em> <em>objects</em>. </p><p><code>package-used-by-list</code> returns a <em>list</em> of other <em>packages</em> that use <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg__1.htm#package-used-by-list)", "pairlis": "```commonlisp\npairlis keys data &optional alist => new-alist\n```\n\n<p><code>keys</code> &mdash; a <em>proper list</em>. </p><p><code>data</code> &mdash; a <em>proper list</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. The default is the <em>empty list</em>. </p><p><code>new-alist</code> &mdash; an <em>association list</em>. </p><p>Returns an <em>association list</em> that associates elements of <em>keys</em> to corresponding elements of <em>data</em>. The consequences are undefined if <em>keys</em> and <em>data</em> are not of the same <em>length</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pairli.htm#pairlis)", "package-use-list": "```commonlisp\npackage-use-list package => use-list\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>use-list</code> &mdash; a <em>list</em> of <em>package</em> <em>objects</em>. </p><p>Returns a <em>list</em> of other <em>packages</em> used by <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pkg_us.htm#package-use-list)", "parse-integer": "```commonlisp\nparse-integer string &key start end radix junk-allowed => integer, pos\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>radix</code> &mdash; a <em>radix</em>. The default is <code>10</code>. </p><p><code>junk-allowed</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>integer</code> &mdash; an <em>integer</em> or <em>false</em>. </p><p><code>pos</code> &mdash; a <em>bounding index</em> of <em>string</em>. </p><p><code>parse-integer</code> parses an <em>integer</em> in the specified <em>radix</em> from the substring of <em>string</em> delimited by <em>start</em> and <em>end</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_parse_.htm#parse-integer)", "pathname-host": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-host)", "pathname-match-p": "```commonlisp\npathname-match-p pathname wildcard => generalized-boolean\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>. </p><p><code>wildcard</code> &mdash; a <em>designator</em> for a <em>wild</em> <em>pathname</em>.  </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>pathname-match-p</code> returns true if <em>pathname</em> matches <em>wildcard</em>, otherwise <code>nil</code>. The matching rules are <em>implementation-defined</em> but should be consistent with <code>directory</code>. Missing components of <em>wildcard</em> default to <code>:wild</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_mat.htm#pathname-match-p)", "parse-namestring": "```commonlisp\nparse-namestring thing &optional host default-pathname &key start end junk-allowed\n => pathname, position\n```\n\n<p>  <code>thing</code> &mdash; a <em>string</em>, a <em>pathname</em>, or a <em>stream associated with a file</em>.   </p><p>  <code>host</code> &mdash; a <em>valid pathname host</em>, a <em>logical host</em>, or <code>nil</code>.   </p><p><code>default-pathname</code> &mdash; a <em>pathname designator</em>. The default is the <em>value</em> of <code>*default-pathname-defaults*</code>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>thing</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>junk-allowed</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>pathname</code> &mdash; a <em>pathname</em>, or <code>nil</code>. </p><p><code>position</code> &mdash; a <em>bounding index designator</em> for <em>thing</em>. </p><p>Converts <em>thing</em> into a <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pars_1.htm#parse-namestring)", "pathnamep": "```commonlisp\npathnamep object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>pathname</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pnp.htm#pathnamep)", "pathname-device": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-device)", "pathname-name": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-name)", "peek-char": "```commonlisp\npeek-char &optional peek-type input-stream eof-error-p eof-value recursive-p => char\n```\n\n<p><code>peek-type</code> &mdash; a <em>character</em> or <code>t</code> or <code>nil</code>. </p><p><code>input-stream</code> &mdash; <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>. The default is <code>nil</code>.  </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>char</code> &mdash; a <em>character</em> or the <em>eof-value</em>. </p><p><code>peek-char</code> obtains the next character in <em>input-stream</em> without actually reading it, thus leaving the character to be read at a later time. It can also be used to skip over and discard intervening characters in the <em>input-stream</em> until a particular character is found. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_peek_c.htm#peek-char)", "phase": "```commonlisp\nphase number => phase\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>phase</code> &mdash; a <em>number</em>. </p><p><code>phase</code> returns the phase of <em>number</em> (the angle part of its polar representation) in radians, in the range  -&lt;PI&gt; (exclusive) if minus zero is not supported, or -&lt;PI&gt; (inclusive) if minus zero is supported,  to &lt;PI&gt; (inclusive). The phase of a positive  <em>real</em>  number is zero; that of a negative  <em>real</em>  number is &lt;PI&gt;. The phase of zero is defined to be zero. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_phase.htm#phase)", "pathname-directory": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-directory)", "plusp": "```commonlisp\nminusp real => generalized-boolean\nplusp real => generalized-boolean\n```\n\n<p><code>real</code> &mdash; a <em>real</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>minusp</code> returns <em>true</em> if <em>real</em> is less than zero; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_minusp.htm#plusp)", "pathname-type": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-type)", "position-if": "```commonlisp\nposition item sequence &key from-end test test-not start end key => position\nposition-if predicate sequence &key from-end start end key => position\nposition-if-not predicate sequence &key from-end start end key => position\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>position</code> &mdash; a <em>bounding index</em> of <em>sequence</em>, or <code>nil</code>. </p><p><code>position</code>, <code>position-if</code>, and <code>position-if-not</code> each search <em>sequence</em> for an <em>element</em> that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pos_p.htm#position-if)", "pathname-version": "```commonlisp\npathname-host pathname &key case => host\npathname-device pathname &key case => device\npathname-directory pathname &key case => directory\npathname-name pathname &key case => name\npathname-type pathname &key case => type\npathname-version pathname => version\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>case</code> &mdash; one of <code>:local</code> or <code>:common</code>. The default is <code>:local</code>.  </p><p> <code>host</code> &mdash; a <em>valid pathname host</em>. </p><p><code>device</code> &mdash; a <em>valid pathname device</em>. </p><p> <code>directory</code> &mdash; a <em>valid pathname directory</em>.  </p><p><code>name</code> &mdash; a <em>valid pathname name</em>. </p><p><code>type</code> &mdash; a <em>valid pathname type</em>. </p><p><code>version</code> &mdash; a <em>valid pathname version</em>. </p><p>These functions return the components of <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pn_hos.htm#pathname-version)", "pprint": "```commonlisp\nwrite object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream\n => object\nprin1 object &optional output-stream => object\nprinc object &optional output-stream => object\nprint object &optional output-stream => object\npprint object &optional output-stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write</code>, <code>prin1</code>, <code>princ</code>, <code>print</code>, and <code>pprint</code> write the printed representation of <em>object</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_pr.htm#pprint)", "pprint-dispatch": "```commonlisp\npprint-dispatch object &optional table => function, found-p\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>table</code> &mdash; a <em>pprint dispatch table</em>, or <code>nil</code>. The default is the <em>value</em> of <code>*print-pprint-dispatch*</code>. </p><p><code>function</code> &mdash; a <em>function designator</em>. </p><p><code>found-p</code> &mdash; a <em>generalized boolean</em>. </p><p>Retrieves the highest priority function in <em>table</em> that is associated with a <em>type specifier</em> that matches <em>object</em>. The function is chosen by finding all of the <em>type specifiers</em> in <em>table</em> that match the <em>object</em> and selecting the highest priority function associated with any of these <em>type specifiers</em>. If there is more than one highest priority function, an arbitrary choice is made. If no <em>type specifiers</em> match the <em>object</em>, a function is returned that prints <em>object</em>  using <code>print-object</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_di.htm#pprint-dispatch)", "position": "```commonlisp\nposition item sequence &key from-end test test-not start end key => position\nposition-if predicate sequence &key from-end start end key => position\nposition-if-not predicate sequence &key from-end start end key => position\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>position</code> &mdash; a <em>bounding index</em> of <em>sequence</em>, or <code>nil</code>. </p><p><code>position</code>, <code>position-if</code>, and <code>position-if-not</code> each search <em>sequence</em> for an <em>element</em> that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pos_p.htm#position)", "pprint-fill": "```commonlisp\npprint-fill stream object &optional colon-p at-sign-p => nil\npprint-linear stream object &optional colon-p at-sign-p => nil\npprint-tabular stream object &optional colon-p at-sign-p tabsize => nil\n```\n\n<p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>colon-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p><code>at-sign-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>implementation-dependent</em>. </p><p><code>tabsize</code> &mdash; a non-negative <em>integer</em>. The default is <code>16</code>. </p><p>The functions <code>pprint-fill</code>, <code>pprint-linear</code>, and <code>pprint-tabular</code> specify particular ways of <em>pretty printing</em> a <em>list</em> to <em>stream</em>. Each function prints parentheses around the output if and only if <em>colon-p</em> is <em>true</em>. Each function ignores its <em>at-sign-p</em> argument. (Both arguments are included even though only one is needed so that these functions can be used via <code>~/.../</code> and as <code>set-pprint-dispatch</code> functions, as well as directly.) Each function handles abbreviation and the detection of circularity and sharing correctly, and uses <code>write</code> to print <em>object</em> when it is a <em>non-list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_fi.htm#pprint-fill)", "pprint-indent": "```commonlisp\npprint-indent relative-to n &optional stream => nil\n```\n\n<p><code>relative-to</code> &mdash; either <code>:block</code> or <code>:current</code>. </p><p><code>n</code> &mdash; a <em>real</em>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>pprint-indent</code> specifies the indentation to use in a logical block on <em>stream</em>.  If <em>stream</em> is a <em>pretty printing stream</em> and the <em>value</em> of <code>*print-pretty*</code> is <em>true</em>, <code>pprint-indent</code> sets the indentation in the innermost dynamically enclosing logical block; otherwise, <code>pprint-indent</code> has no effect.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_in.htm#pprint-indent)", "pprint-linear": "```commonlisp\npprint-fill stream object &optional colon-p at-sign-p => nil\npprint-linear stream object &optional colon-p at-sign-p => nil\npprint-tabular stream object &optional colon-p at-sign-p tabsize => nil\n```\n\n<p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>colon-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p><code>at-sign-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>implementation-dependent</em>. </p><p><code>tabsize</code> &mdash; a non-negative <em>integer</em>. The default is <code>16</code>. </p><p>The functions <code>pprint-fill</code>, <code>pprint-linear</code>, and <code>pprint-tabular</code> specify particular ways of <em>pretty printing</em> a <em>list</em> to <em>stream</em>. Each function prints parentheses around the output if and only if <em>colon-p</em> is <em>true</em>. Each function ignores its <em>at-sign-p</em> argument. (Both arguments are included even though only one is needed so that these functions can be used via <code>~/.../</code> and as <code>set-pprint-dispatch</code> functions, as well as directly.) Each function handles abbreviation and the detection of circularity and sharing correctly, and uses <code>write</code> to print <em>object</em> when it is a <em>non-list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_fi.htm#pprint-linear)", "position-if-not": "```commonlisp\nposition item sequence &key from-end test test-not start end key => position\nposition-if predicate sequence &key from-end start end key => position\nposition-if-not predicate sequence &key from-end start end key => position\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>position</code> &mdash; a <em>bounding index</em> of <em>sequence</em>, or <code>nil</code>. </p><p><code>position</code>, <code>position-if</code>, and <code>position-if-not</code> each search <em>sequence</em> for an <em>element</em> that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pos_p.htm#position-if-not)", "pprint-newline": "```commonlisp\npprint-newline kind &optional stream => nil\n```\n\n<p><code>kind</code> &mdash; one of <code>:linear</code>, <code>:fill</code>, <code>:miser</code>, or <code>:mandatory</code>. </p><p><code>stream</code> &mdash; a <em>stream designator</em>. The default is <em>standard output</em>. </p><p> If <em>stream</em> is a <em>pretty printing stream</em> and the <em>value</em> of <code>*print-pretty*</code> is <em>true</em>, a line break is inserted in the output when the appropriate condition below is satisfied; otherwise, <code>pprint-newline</code> has no effect.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_nl.htm#pprint-newline)", "prin1": "```commonlisp\nwrite object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream\n => object\nprin1 object &optional output-stream => object\nprinc object &optional output-stream => object\nprint object &optional output-stream => object\npprint object &optional output-stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write</code>, <code>prin1</code>, <code>princ</code>, <code>print</code>, and <code>pprint</code> write the printed representation of <em>object</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_pr.htm#prin1)", "pprint-tab": "```commonlisp\npprint-tab kind colnum colinc &optional stream => nil\n```\n\n<p><code>kind</code> &mdash; one of <code>:line</code>, <code>:section</code>, <code>:line-relative</code>, or <code>:section-relative</code>. </p><p><code>colnum</code> &mdash; a non-negative <em>integer</em>. </p><p><code>colinc</code> &mdash; a non-negative <em>integer</em>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. </p><p>Specifies tabbing to <em>stream</em> as performed by the standard <code>~T</code> format directive.  If <em>stream</em> is a <em>pretty printing stream</em> and the <em>value</em> of <code>*print-pretty*</code> is <em>true</em>,  tabbing is performed; otherwise, <code>pprint-tab</code> has no effect. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_ta.htm#pprint-tab)", "pprint-tabular": "```commonlisp\npprint-fill stream object &optional colon-p at-sign-p => nil\npprint-linear stream object &optional colon-p at-sign-p => nil\npprint-tabular stream object &optional colon-p at-sign-p tabsize => nil\n```\n\n<p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>colon-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p><code>at-sign-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>implementation-dependent</em>. </p><p><code>tabsize</code> &mdash; a non-negative <em>integer</em>. The default is <code>16</code>. </p><p>The functions <code>pprint-fill</code>, <code>pprint-linear</code>, and <code>pprint-tabular</code> specify particular ways of <em>pretty printing</em> a <em>list</em> to <em>stream</em>. Each function prints parentheses around the output if and only if <em>colon-p</em> is <em>true</em>. Each function ignores its <em>at-sign-p</em> argument. (Both arguments are included even though only one is needed so that these functions can be used via <code>~/.../</code> and as <code>set-pprint-dispatch</code> functions, as well as directly.) Each function handles abbreviation and the detection of circularity and sharing correctly, and uses <code>write</code> to print <em>object</em> when it is a <em>non-list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ppr_fi.htm#pprint-tabular)", "print-not-readable-object": "```commonlisp\nprint-not-readable-object condition => object\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>print-not-readable</code>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p>Returns the <em>object</em> that could not be printed readably in the situation represented by <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pr_not.htm#print-not-readable-object)", "princ-to-string": "```commonlisp\nwrite-to-string object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin \n => string\nprin1-to-string object => string\nprinc-to-string object => string\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>.  </p><p><code>string</code> &mdash; a <em>string</em>. </p><p><code>write-to-string</code>, <code>prin1-to-string</code>, and <code>princ-to-string</code> are used to create a <em>string</em> consisting of the printed representation of <em>object</em>. <em>Object</em> is effectively printed as if by <code>write</code>, <code>prin1</code>, or <code>princ</code>, respectively, and the <em>characters</em> that would be output are made into a <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_to_.htm#princ-to-string)", "prin1-to-string": "```commonlisp\nwrite-to-string object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin \n => string\nprin1-to-string object => string\nprinc-to-string object => string\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>.  </p><p><code>string</code> &mdash; a <em>string</em>. </p><p><code>write-to-string</code>, <code>prin1-to-string</code>, and <code>princ-to-string</code> are used to create a <em>string</em> consisting of the printed representation of <em>object</em>. <em>Object</em> is effectively printed as if by <code>write</code>, <code>prin1</code>, or <code>princ</code>, respectively, and the <em>characters</em> that would be output are made into a <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_to_.htm#prin1-to-string)", "princ": "```commonlisp\nwrite object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream\n => object\nprin1 object &optional output-stream => object\nprinc object &optional output-stream => object\nprint object &optional output-stream => object\npprint object &optional output-stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write</code>, <code>prin1</code>, <code>princ</code>, <code>print</code>, and <code>pprint</code> write the printed representation of <em>object</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_pr.htm#princ)", "proclaim": "```commonlisp\nproclaim declaration-specifier => implementation-dependent\n```\n\n<p><code>declaration-specifier</code> &mdash; a <em>declaration specifier</em>. </p><p><em>Establishes</em> the <em>declaration</em> specified by <em>declaration-specifier</em> in the <em>global environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_procla.htm#proclaim)", "probe-file": "```commonlisp\nprobe-file pathspec => truename\n```\n\n<p> <code>pathspec</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>truename</code> &mdash; a <em>physical pathname</em> or <code>nil</code>.  </p><p><code>probe-file</code> tests whether a file exists. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_probe_.htm#probe-file)", "print": "```commonlisp\nwrite object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream\n => object\nprin1 object &optional output-stream => object\nprinc object &optional output-stream => object\nprint object &optional output-stream => object\npprint object &optional output-stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write</code>, <code>prin1</code>, <code>princ</code>, <code>print</code>, and <code>pprint</code> write the printed representation of <em>object</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_pr.htm#print)", "provide": "```commonlisp\nprovide module-name => implementation-dependent\nrequire module-name &optional pathname-list => implementation-dependent\n```\n\n<p><code>module-name</code> &mdash; a <em>string designator</em>. </p><p> <code>pathname-list</code> &mdash; <code>nil</code>, or a <em>designator</em> for a <em>non-empty</em> <em>list</em> of <em>pathname designators</em>. The default is <code>nil</code>.  </p><p><code>provide</code> adds the <em>module-name</em> to the <em>list</em> held by <code>*modules*</code>, if such a name is not already present. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_provid.htm#provide)", "random": "```commonlisp\nrandom limit &optional random-state => random-number\n```\n\n<p><code>limit</code> &mdash; a positive <em>integer</em>, or a positive <em>float</em>. </p><p><code>random-state</code> &mdash; a <em>random state</em>. The default is the <em>current random state</em>. </p><p><code>random-number</code> &mdash; a non-negative <em>number</em> less than <em>limit</em> and of the same <em>type</em> as <em>limit</em>. </p><p>Returns a pseudo-random number that is a non-negative <em>number</em> less than <em>limit</em> and of the same <em>type</em> as <em>limit</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_random.htm#random)", "random-state-p": "```commonlisp\nrandom-state-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>random-state</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rnd_st.htm#random-state-p)", "rassoc-if": "```commonlisp\nrassoc item alist &key key test test-not => entry\nrassoc-if predicate alist &key key => entry\nrassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of the <em>alist</em>, or <code>nil</code>. </p><p><code>rassoc</code>, <code>rassoc-if</code>, and <code>rassoc-if-not</code> return the first <em>cons</em> whose <em>cdr</em> <em>satisfies the test</em>. If no such <em>cons</em> is found, <code>nil</code> s returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rassoc.htm#rassoc-if)", "rationalize": "```commonlisp\nrational number => rational\nrationalize number => rational\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>rational</code> &mdash; a <em>rational</em>. </p><p><code>rational</code> and <code>rationalize</code> convert  <em>reals</em>  to <em>rationals</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ration.htm#rationalize)", "rationalp": "```commonlisp\nrationalp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>rational</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rati_1.htm#rationalp)", "read-byte": "```commonlisp\nread-byte stream &optional eof-error-p eof-value => byte\n```\n\n<p><code>stream</code> &mdash; a <em>binary</em> <em>input</em> <em>stream</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>. The default is <code>nil</code>.  </p><p><code>byte</code> &mdash; an <em>integer</em>, or the <em>eof-value</em>. </p><p><code>read-byte</code> reads and returns one byte from <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_by.htm#read-byte)", "rassoc-if-not": "```commonlisp\nrassoc item alist &key key test test-not => entry\nrassoc-if predicate alist &key key => entry\nrassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of the <em>alist</em>, or <code>nil</code>. </p><p><code>rassoc</code>, <code>rassoc-if</code>, and <code>rassoc-if-not</code> return the first <em>cons</em> whose <em>cdr</em> <em>satisfies the test</em>. If no such <em>cons</em> is found, <code>nil</code> s returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rassoc.htm#rassoc-if-not)", "read-char": "```commonlisp\nread-char &optional input-stream eof-error-p eof-value recursive-p => char\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>. The default is <code>nil</code>.  </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>char</code> &mdash; a <em>character</em> or the <em>eof-value</em>. </p><p><code>read-char</code> returns the next <em>character</em> from <em>input-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_cha.htm#read-char)", "read": "```commonlisp\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>.  The default is <code>nil</code>. </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>object</code> &mdash; an <em>object</em> (parsed by the <em>Lisp reader</em>) or the <em>eof-value</em>. </p><p><code>read</code> parses the printed representation of an <em>object</em> from <em>input-stream</em> and builds such an <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_rd.htm#read)", "rassoc": "```commonlisp\nrassoc item alist &key key test test-not => entry\nrassoc-if predicate alist &key key => entry\nrassoc-if-not predicate alist &key key => entry\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>alist</code> &mdash; an <em>association list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>entry</code> &mdash; a <em>cons</em> that is an <em>element</em> of the <em>alist</em>, or <code>nil</code>. </p><p><code>rassoc</code>, <code>rassoc-if</code>, and <code>rassoc-if-not</code> return the first <em>cons</em> whose <em>cdr</em> <em>satisfies the test</em>. If no such <em>cons</em> is found, <code>nil</code> s returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rassoc.htm#rassoc)", "read-char-no-hang": "```commonlisp\nread-char-no-hang &optional input-stream eof-error-p eof-value recursive-p => char\n```\n\n<p><code>input-stream</code>  &mdash;  an <code>input</code> <code>stream designator</code>. The default is <code>standard input</code>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>. The default is <code>nil</code>.  </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>char</code> &mdash; a <em>character</em> or <code>nil</code> or the <em>eof-value</em>. </p><p><code>read-char-no-hang</code> returns a character from <em>input-stream</em> if such a character is available. If no character is available, <code>read-char-no-hang</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_c_1.htm#read-char-no-hang)", "read-from-string": "```commonlisp\nread-from-string string &optional eof-error-p eof-value &key start end preserve-whitespace\n => object, position\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>.  The default is <code>nil</code>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>preserve-whitespace</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>object</code> &mdash; an <em>object</em> (parsed by the <em>Lisp reader</em>) or the <em>eof-value</em>. </p><p><code>position</code> &mdash; an <em>integer</em> greater than or equal to zero, and less than or equal to one more than the <em>length</em> of the <em>string</em>. </p><p>Parses the printed representation of an <em>object</em> from the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em>, as if <code>read</code> had been called on an <em>input</em> <em>stream</em> containing those same <em>characters</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_fro.htm#read-from-string)", "read-delimited-list": "```commonlisp\nread-delimited-list char &optional input-stream recursive-p => list\n```\n\n<p><code>char</code> &mdash; a <em>character</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>list</code> &mdash; a <em>list</em> of the <em>objects</em> read. </p><p><code>read-delimited-list</code> reads <em>objects</em> from <em>input-stream</em> until the next character after an <em>object</em>'s representation (ignoring <em>whitespace</em>[2] characters and comments) is <em>char</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_del.htm#read-delimited-list)", "read-preserving-whitespace": "```commonlisp\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>.  The default is <code>nil</code>. </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>object</code> &mdash; an <em>object</em> (parsed by the <em>Lisp reader</em>) or the <em>eof-value</em>. </p><p><code>read</code> parses the printed representation of an <em>object</em> from <em>input-stream</em> and builds such an <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_rd.htm#read-preserving-whitespace)", "read-sequence": "```commonlisp\nread-sequence sequence stream &key start end => position\nsequence \u2014 a sequence. \nstream \u2014 an input stream. \nstart, end \u2014 bounding index designators of sequence. The defaults for start and end are 0 and nil, respectively. \nposition \u2014 an integer greater than or equal to zero, and less than or equal to the length of the sequence. \n```\n\n<p>Destructively modifies <em>sequence</em> by replacing the <em>elements</em> of <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> with <em>elements</em> read from <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_seq.htm#read-sequence)", "read-line": "```commonlisp\nread-line &optional input-stream eof-error-p eof-value recursive-p\n => line, missing-newline-p\n```\n\n<p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>eof-error-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p> <code>eof-value</code> &mdash; an <em>object</em>. The default is <code>nil</code>.  </p><p><code>recursive-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>line</code> &mdash; a <em>string</em> or the <em>eof-value</em>. </p><p><code>missing-newline-p</code> &mdash; a <em>generalized boolean</em>. </p><p>Reads from <em>input-stream</em> a line of text that is terminated by a <em>newline</em> or <em>end of file</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rd_lin.htm#read-line)", "realpart": "```commonlisp\nrealpart number => real\nimagpart number => real\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>real</code> &mdash; a <em>real</em>. </p><p><code>realpart</code> and <code>imagpart</code> return the real and imaginary parts of <em>number</em> respectively. If <em>number</em> is  <em>real</em>,  then <code>realpart</code> returns <em>number</em> and <code>imagpart</code> returns <code>(* 0 </code><em>number</em><code>)</code>, which has the effect that the imaginary part of a <em>rational</em> is <code>0</code> and that of a <em>float</em> is a floating-point zero of the same format. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_realpa.htm#realpart)", "readtablep": "```commonlisp\nreadtablep object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>readtable</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rdta_1.htm#readtablep)", "reduce": "```commonlisp\nreduce function sequence &key key from-end start end initial-value => result\n```\n\n<p><code>function</code> &mdash; a <em>designator</em> for a <em>function</em> that might be called with either zero or two <em>arguments</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p> <code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>.  </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>initial-value</code> &mdash; an <em>object</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>reduce</code> uses a binary operation, <em>function</em>, to combine the <em>elements</em> of <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_reduce.htm#reduce)", "rem": "```commonlisp\nmod number divisor => modulus\nrem number divisor => remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a <em>real</em>. </p><p><code>modulus</code>, <code>remainder</code> &mdash; a <em>real</em>. </p><p><code>mod</code> and <code>rem</code> are generalizations of the modulus and remainder functions respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mod_r.htm#rem)", "realp": "```commonlisp\nrealp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>real</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_realp.htm#realp)", "remhash": "```commonlisp\nremhash key hash-table => generalized-boolean\n```\n\n<p><code>key</code> &mdash; an <em>object</em>. </p><p><code>hash-table</code> &mdash; a <em>hash table</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Removes the entry for <em>key</em> in <em>hash-table</em>, if any. Returns <em>true</em> if there was such an entry, or <em>false</em> otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_remhas.htm#remhash)", "remove": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#remove)", "remove-duplicates": "```commonlisp\nremove-duplicates sequence &key from-end test test-not start end key\n => result-sequence\ndelete-duplicates sequence &key from-end test test-not start end key\n => result-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove-duplicates</code> returns a modified copy of <em>sequence</em> from which any element that matches another element occurring in <em>sequence</em> has been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_dup.htm#remove-duplicates)", "remove-if-not": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#remove-if-not)", "rename-file": "```commonlisp\nrename-file filespec new-name => defaulted-new-name, old-truename, new-truename\n```\n\n<p> <code>filespec</code> &mdash; a <em>pathname designator</em>.  </p><p><code>new-name</code> &mdash; a <em>pathname designator</em> other than a <em>stream</em>. </p><p><code>defaulted-new-name</code> &mdash; a <em>pathname</em> </p><p><code>old-truename</code> &mdash; a <em>physical pathname</em>. </p><p><code>new-truename</code> &mdash; a <em>physical pathname</em>. </p><p><code>rename-file</code> modifies the file system in such a way that the file indicated by <em>filespec</em> is renamed to <em>defaulted-new-name</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rn_fil.htm#rename-file)", "remprop": "```commonlisp\nremprop symbol indicator => generalized-boolean\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>indicator</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>remprop</code> removes from the <em>property list</em>[2] of <em>symbol</em> a <em>property</em>[1] with a <em>property indicator</em> <em>identical</em> to <em>indicator</em>.  If there are multiple <em>properties</em>[1] with the <em>identical</em> key, <code>remprop</code> only removes the first such <em>property</em>.  <code>remprop</code> returns <em>false</em> if no such <em>property</em> was found, or <em>true</em> if a property was found. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rempro.htm#remprop)", "replace": "```commonlisp\nreplace sequence-1 sequence-2 &key start1 end1 start2 end2 => sequence-1\n```\n\n<p><code>sequence-1</code> &mdash; a <em>sequence</em>. </p><p><code>sequence-2</code> &mdash; a <em>sequence</em>. </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>sequence-1</em>. The defaults for <em>start1</em> and <em>end1</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>sequence-2</em>. The defaults for <em>start2</em> and <em>end2</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p>Destructively modifies <em>sequence-1</em> by replacing the <em>elements</em> of <em>subsequence-1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> with the <em>elements</em> of <em>subsequence-2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_replac.htm#replace)", "remove-if": "```commonlisp\nremove item sequence &key from-end test test-not start end count key => result-sequence\nremove-if test sequence &key from-end start end count key => result-sequence\nremove-if-not test sequence &key from-end start end count key => result-sequence\ndelete item sequence &key from-end test test-not start end count key => result-sequence\ndelete-if test sequence &key from-end start end count key => result-sequence\ndelete-if-not test sequence &key from-end start end count key => result-sequence\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>remove</code>, <code>remove-if</code>, and <code>remove-if-not</code> return a <em>sequence</em> from which the elements that <em>satisfy the test</em> have been removed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_rm.htm#remove-if)", "rename-package": "```commonlisp\nrename-package package new-name &optional new-nicknames => package-object\n```\n\n<p> <code>package</code> &mdash; a <em>package designator</em>.  </p><p><code>new-name</code> &mdash; a <em>package designator</em>. </p><p><code>new-nicknames</code> &mdash; a <em>list</em> of <em>string designators</em>. The default is the <em>empty list</em>. </p><p> <code>package-object</code> &mdash; the renamed <em>package</em> <em>object</em>.  </p><p>Replaces the name and nicknames of <em>package</em>. The old name and all of the old nicknames of <em>package</em> are eliminated and are replaced by <em>new-name</em> and <em>new-nicknames</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rn_pkg.htm#rename-package)", "require": "```commonlisp\nprovide module-name => implementation-dependent\nrequire module-name &optional pathname-list => implementation-dependent\n```\n\n<p><code>module-name</code> &mdash; a <em>string designator</em>. </p><p> <code>pathname-list</code> &mdash; <code>nil</code>, or a <em>designator</em> for a <em>non-empty</em> <em>list</em> of <em>pathname designators</em>. The default is <code>nil</code>.  </p><p><code>provide</code> adds the <em>module-name</em> to the <em>list</em> held by <code>*modules*</code>, if such a name is not already present. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_provid.htm#require)", "restart-name": "```commonlisp\nrestart-name restart => name\n```\n\n<p><code>restart</code> &mdash; a <em>restart</em>. </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p>Returns the name of the <em>restart</em>, or <code>nil</code> if the <em>restart</em> is not named. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rst_na.htm#restart-name)", "revappend": "```commonlisp\nrevappend list tail => result-list\nnreconc list tail => result-list\n```\n\n<p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>tail</code> &mdash; an <em>object</em>. </p><p><code>result-list</code> &mdash; an <em>object</em>. </p><p><code>revappend</code> constructs a <em>copy</em>[2] of <em>list</em>, but with the <em>elements</em> in reverse order. It then appends (as if by <code>nconc</code>) the <em>tail</em> to that reversed list and returns the result. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_revapp.htm#revappend)", "round": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#round)", "room": "```commonlisp\nroom &optional x => implementation-dependent\n```\n\n<p><code>x</code> &mdash; one of <code>t</code>, <code>nil</code>, or <code>:default</code>. </p><p><code>room</code> prints, to <em>standard output</em>, information about the state of internal storage and its management. This might include descriptions of the amount of memory in use and the degree of memory compaction, possibly broken down by internal data type if that is appropriate. The nature and format of the printed information is <em>implementation-dependent</em>. The intent is to provide information that a <em>programmer</em> might use to tune a <em>program</em> for a particular <em>implementation</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_room.htm#room)", "reverse": "```commonlisp\nreverse sequence => reversed-sequence\nnreverse sequence => reversed-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>reversed-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>reverse</code> and <code>nreverse</code> return a new <em>sequence</em> of the same kind as <em>sequence</em>, containing the same <em>elements</em>, but in reverse order. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_revers.htm#reverse)", "rplacd": "```commonlisp\nrplaca cons object => cons\nrplacd cons object => cons\n```\n\n<p><code>cons</code> &mdash; a <em>cons</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>rplaca</code> replaces the <em>car</em> of the <em>cons</em> with <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rplaca.htm#rplacd)", "rplaca": "```commonlisp\nrplaca cons object => cons\nrplacd cons object => cons\n```\n\n<p><code>cons</code> &mdash; a <em>cons</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>rplaca</code> replaces the <em>car</em> of the <em>cons</em> with <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rplaca.htm#rplaca)", "scale-float": "```commonlisp\ndecode-float float => significand, exponent, sign\nscale-float float integer => scaled-float\nfloat-radix float => float-radix\nfloat-sign float-1 &optional float-2 => signed-float\nfloat-digits float => digits1\nfloat-precision float => digits2\ninteger-decode-float float => significand, exponent, integer-sign\n```\n\n<p><code>digits1</code> &mdash; a non-negative <em>integer</em>. </p><p><code>digits2</code> &mdash; a non-negative <em>integer</em>. </p><p><code>exponent</code> &mdash; an <em>integer</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float-1</code> &mdash; a <em>float</em>. </p><p><code>float-2</code> &mdash; a <em>float</em>. </p><p><code>float-radix</code> &mdash; an <em>integer</em>. </p><p><code>integer</code> &mdash; a non-negative <em>integer</em>. </p><p><code>integer-sign</code> &mdash; the <em>integer</em> <code>-1</code>, or the <em>integer</em> <code>1</code>. </p><p><code>scaled-float</code> &mdash; a <em>float</em>. </p><p><code>sign</code> &mdash; A <em>float</em> of the same <em>type</em> as <em>float</em> but numerically equal to <code>1.0</code> or <code>-1.0</code>. </p><p><code>signed-float</code> &mdash; a <em>float</em>. </p><p><code>significand</code> &mdash; a <em>float</em>. </p><p><code>decode-float</code> computes three values that characterize <em>float</em>. The first value is of the same <em>type</em> as <em>float</em> and represents the significand. The second value represents the exponent to which the radix (notated in this description by <em>b</em>) must be raised to obtain the value that, when multiplied with the first result, produces the absolute value of <em>float</em>. If <em>float</em> is zero, any <em>integer</em> value may be returned, provided that the identity shown for <code>scale-float</code> holds. The third value is of the same <em>type</em> as <em>float</em> and is 1.0 if <em>float</em> is greater than or equal to zero or -1.0 otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm#scale-float)", "set-difference": "```commonlisp\nset-difference list-1 list-2 &key key test test-not => result-list\nnset-difference list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>set-difference</code> returns a <em>list</em> of elements of <em>list-1</em> that do not appear in <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_di.htm#set-difference)", "search": "```commonlisp\nsearch sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2\n => position\n```\n\n<p><code>Sequence-1</code> &mdash; a <em>sequence</em>. </p><p><code>Sequence-2</code> &mdash; a <em>sequence</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>sequence-1</em>. The defaults for <em>start1</em> and <em>end1</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>sequence-2</em>. The defaults for <em>start2</em> and <em>end2</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>position</code> &mdash; a <em>bounding index</em> of <em>sequence-2</em>, or <code>nil</code>. </p><p>Searches <em>sequence-2</em> for a subsequence that matches <em>sequence-1</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_search.htm#search)", "set": "```commonlisp\nset symbol value => value\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p> <code>value</code> &mdash; an <em>object</em>.  </p><p><code>set</code> changes the contents of the <em>value cell</em> of <em>symbol</em> to the given <em>value</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set.htm#set)", "set-exclusive-or": "```commonlisp\nset-exclusive-or list-1 list-2 &key key test test-not => result-list\nnset-exclusive-or list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>set-exclusive-or</code> returns a <em>list</em> of elements that appear in exactly one of <em>list-1</em> and <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_ex.htm#set-exclusive-or)", "set-dispatch-macro-character": "```commonlisp\nget-dispatch-macro-character disp-char sub-char &optional readtable => function\nset-dispatch-macro-character disp-char sub-char new-function &optional readtable => t\n```\n\n<p><code>disp-char</code> &mdash; a <em>character</em>. </p><p><code>sub-char</code> &mdash; a <em>character</em>. </p><p> <code>readtable</code> &mdash; a <em>readtable designator</em>.  The default is the <em>current readtable</em>. </p><p><code>function</code> &mdash; a <em>function designator</em> or <code>nil</code>. </p><p><code>new-function</code> &mdash; a <em>function designator</em>. </p><p><code>set-dispatch-macro-character</code> causes <em>new-function</em> to be called when <em>disp-char</em> followed by <em>sub-char</em> is read. If <em>sub-char</em> is a lowercase letter, it is converted to its uppercase equivalent. It is an error if <em>sub-char</em> is one of the ten decimal digits. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set__1.htm#set-dispatch-macro-character)", "set-macro-character": "```commonlisp\nget-macro-character char &optional readtable => function, non-terminating-p\nset-macro-character char new-function &optional non-terminating-p readtable => t\n```\n\n<p><code>char</code> &mdash; a <em>character</em>. </p><p><code>non-terminating-p</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p> <code>readtable</code> &mdash; a <em>readtable designator</em>.  The default is the <em>current readtable</em>. </p><p><code>function</code> &mdash; <code>nil</code>, or a <em>designator</em> for a <em>function</em> of two <em>arguments</em>. </p><p><code>new-function</code> &mdash; a <em>function designator</em>. </p><p><code>get-macro-character</code> returns as its <em>primary value</em>, <em>function</em>, the <em>reader macro function</em> associated with <em>char</em> in <em>readtable</em> (if any), or else <code>nil</code> if <em>char</em> is not a <em>macro character</em> in <em>readtable</em>. The <em>secondary value</em>, <em>non-terminating-p</em>, is <em>true</em> if <em>char</em> is a <em>non-terminating</em> <em>macro character</em>; otherwise, it is <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_ma.htm#set-macro-character)", "set-pprint-dispatch": "```commonlisp\nset-pprint-dispatch type-specifier function &optional priority table => nil\n```\n\n<p><code>type-specifier</code> &mdash; a <em>type specifier</em>. </p><p><code>function</code> &mdash; a <em>function</em>, a <em>function name</em>, or <code>nil</code>. </p><p><code>priority</code> &mdash; a <em>real</em>. The default is <code>0</code>. </p><p><code>table</code> &mdash; a <em>pprint dispatch table</em>. The default is the <em>value</em> of <code>*print-pprint-dispatch*</code>. </p><p>Installs an entry into the <em>pprint dispatch table</em> which is <em>table</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_pp.htm#set-pprint-dispatch)", "set-syntax-from-char": "```commonlisp\n```\n\n<p> <code>to-char</code> &mdash; a <em>character</em>. </p><p><code>from-char</code> &mdash; a <em>character</em>.  </p><p><code>to-readtable</code> &mdash; a <em>readtable</em>. The default is the <em>current readtable</em>. </p><p><code>from-readtable</code> &mdash; a <em>readtable designator</em>. The default is the <em>standard readtable</em>. </p><p><code>set-syntax-from-char</code> makes the syntax of <em>to-char</em> in <em>to-readtable</em> be the same as the syntax of <em>from-char</em> in <em>from-readtable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_set_sy.htm#set-syntax-from-char)", "shadow": "```commonlisp\nshadow symbol-names &optional package => t\n```\n\n<p> <code>symbol-names</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>string designators</em>.  </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>shadow</code> assures that <em>symbols</em> with names given by <em>symbol-names</em> are <em>present</em> in the <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_shadow.htm#shadow)", "short-site-name": "```commonlisp\nshort-site-name <no arguments> => description\nlong-site-name <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>short-site-name</code> and <code>long-site-name</code> return a <em>string</em> that identifies the physical location of the computer hardware, or <code>nil</code> if no appropriate <em>description</em> can be produced. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_short_.htm#short-site-name)", "shadowing-import": "```commonlisp\nshadowing-import symbols &optional package => t\n```\n\n<p><code>symbols</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>symbols</em>. </p><p> <em>package</em>  &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>shadowing-import</code> is like <code>import</code>, but it does not signal an error even if the importation of a <em>symbol</em> would shadow some <em>symbol</em> already <em>accessible</em> in <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_shdw_i.htm#shadowing-import)", "signal": "```commonlisp\nsignal datum &rest arguments => nil\n```\n\n<p><code>datum</code>, <code>arguments</code> &mdash; <em>designators</em> for a <em>condition</em> of default type <code>simple-condition</code>. </p><p><em>Signals</em> the <em>condition</em> denoted by the given <em>datum</em> and <em>arguments</em>. If the <em>condition</em> is not handled, <code>signal</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_signal.htm#signal)", "signum": "```commonlisp\nsignum number => signed-prototype\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>signed-prototype</code> &mdash; a <em>number</em>. </p><p><code>signum</code> determines a numerical value that indicates whether <em>number</em> is negative, zero, or positive. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_signum.htm#signum)", "simple-bit-vector-p": "```commonlisp\nsimple-bit-vector-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>simple-bit-vector</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_smp_bt.htm#simple-bit-vector-p)", "simple-condition-format-control": "```commonlisp\nsimple-condition-format-control condition => format-control\nsimple-condition-format-arguments condition => format-arguments\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>simple-condition</code>. </p><p><code>format-control</code> &mdash; a <em>format control</em>. </p><p><code>format-arguments</code> &mdash; a <em>list</em>. </p><p><code>simple-condition-format-control</code> returns the <em>format control</em> needed to process the <em>condition</em>'s <em>format arguments</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_smp_cn.htm#simple-condition-format-control)", "simple-string-p": "```commonlisp\nsimple-string-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>simple-string</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_smp_st.htm#simple-string-p)", "simple-condition-format-arguments": "```commonlisp\nsimple-condition-format-control condition => format-control\nsimple-condition-format-arguments condition => format-arguments\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>simple-condition</code>. </p><p><code>format-control</code> &mdash; a <em>format control</em>. </p><p><code>format-arguments</code> &mdash; a <em>list</em>. </p><p><code>simple-condition-format-control</code> returns the <em>format control</em> needed to process the <em>condition</em>'s <em>format arguments</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_smp_cn.htm#simple-condition-format-arguments)", "simple-vector-p": "```commonlisp\nsimple-vector-p object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>simple-vector</code>; otherwise, returns <em>false</em>.. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_smp_ve.htm#simple-vector-p)", "sin": "```commonlisp\nsin radians => number\ncos radians => number\ntan radians => number\n```\n\n<p><code>radians</code> &mdash; a <em>number</em> given in radians. </p><p><code>number</code> &mdash; a <em>number</em>. </p><p><code>sin</code>, <code>cos</code>, and <code>tan</code> return the sine, cosine, and tangent, respectively, of <em>radians</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sin_c.htm#sin)", "sleep": "```commonlisp\nsleep seconds => nil\n```\n\n<p><code>seconds</code> &mdash; a non-negative <em>real</em>. </p><p>Causes execution to cease and become dormant for approximately the seconds of real time indicated by <em>seconds</em>, whereupon execution is resumed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sleep.htm#sleep)", "sinh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#sinh)", "slot-boundp": "```commonlisp\nslot-boundp instance slot-name => generalized-boolean\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>slot-name</code> &mdash; a <em>symbol</em> naming a <em>slot</em> of <em>instance</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if the <em>slot</em> named <em>slot-name</em> in <em>instance</em> is bound; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_bo.htm#slot-boundp)", "slot-exists-p": "```commonlisp\nslot-exists-p object slot-name => generalized-boolean\n```\n\n<p> <code>object</code> &mdash; an <em>object</em>.  </p><p><code>slot-name</code> &mdash; a <em>symbol</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p> Returns <em>true</em> if the <em>object</em> has a <em>slot</em> named <em>slot-name</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_ex.htm#slot-exists-p)", "slot-makunbound": "```commonlisp\nslot-makunbound instance slot-name => instance\n```\n\n<p><code>instance</code>  &mdash;  instance. </p><p><code>Slot-name</code> &mdash; a <em>symbol</em>. </p><p>The <em>function</em> <code>slot-makunbound</code> restores a <em>slot</em> of the name <em>slot-name</em> in an <em>instance</em> to the unbound state. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_ma.htm#slot-makunbound)", "slot-value": "```commonlisp\nslot-value object slot-name => value\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>value</code> &mdash; an <em>object</em>. </p><p>The <em>function</em> <code>slot-value</code> returns the <em>value</em> of the <em>slot</em> named <em>slot-name</em> in the <em>object</em>. If there is no <em>slot</em> named <em>slot-name</em>, <code>slot-missing</code> is called. If the <em>slot</em> is unbound, <code>slot-unbound</code> is called. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_va.htm#slot-value)", "some": "```commonlisp\nevery predicate &rest sequences+ => generalized-boolean\nsome predicate &rest sequences+ => result\nnotevery predicate &rest sequences+ => generalized-boolean\nnotany predicate &rest sequences+ => generalized-boolean\n```\n\n<p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of as many <em>arguments</em> as there are <em>sequences</em>. </p><p><code>sequence</code> &mdash; a <em>sequence</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>every</code>, <code>some</code>, <code>notevery</code>, and <code>notany</code> test <em>elements</em> of <em>sequences</em> for satisfaction of a given <em>predicate</em>. The first argument to <em>predicate</em> is an <em>element</em> of the first <em>sequence</em>; each succeeding argument is an <em>element</em> of a succeeding <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_everyc.htm#some)", "sort": "```commonlisp\nsort sequence predicate &key key => sorted-sequence\nstable-sort sequence predicate &key key => sorted-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of two arguments that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>sorted-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>sort</code> and <code>stable-sort</code> destructively sort <em>sequences</em> according to the order determined by the <em>predicate</em> function. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sort_.htm#sort)", "software-version": "```commonlisp\nsoftware-type <no arguments> => description\nsoftware-version <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>software-type</code> returns a <em>string</em> that identifies the generic name of any relevant supporting software, or <code>nil</code> if no appropriate or relevant result can be produced. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sw_tpc.htm#software-version)", "special-operator-p": "```commonlisp\nspecial-operator-p symbol => generalized-boolean\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>symbol</em> is a <em>special operator</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_specia.htm#special-operator-p)", "sqrt": "```commonlisp\nsqrt number => root\nisqrt natural => natural-root\n```\n\n<p><code>number</code>, <code>root</code> &mdash; a <em>number</em>. </p><p><code>natural</code>, <code>natural-root</code> &mdash; a non-negative <em>integer</em>. </p><p><code>sqrt</code> and <code>isqrt</code> compute square roots. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sqrt_.htm#sqrt)", "stable-sort": "```commonlisp\nsort sequence predicate &key key => sorted-sequence\nstable-sort sequence predicate &key key => sorted-sequence\n```\n\n<p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of two arguments that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>sorted-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>sort</code> and <code>stable-sort</code> destructively sort <em>sequences</em> according to the order determined by the <em>predicate</em> function. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sort_.htm#stable-sort)", "software-type": "```commonlisp\nsoftware-type <no arguments> => description\nsoftware-version <no arguments> => description\n```\n\n<p><code>description</code> &mdash; a <em>string</em> or <code>nil</code>. </p><p><code>software-type</code> returns a <em>string</em> that identifies the generic name of any relevant supporting software, or <code>nil</code> if no appropriate or relevant result can be produced. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sw_tpc.htm#software-type)", "standard-char-p": "```commonlisp\nstandard-char-p character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>character</em> is of <em>type</em> <code>standard-char</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_std_ch.htm#standard-char-p)", "stream-element-type": "```commonlisp\nstream-element-type stream => typespec\n```\n\n<p><code>stream</code> &mdash; a <em>stream</em>. </p><p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>stream-element-type</code> returns a <em>type specifier</em> that indicates the <em>types</em> of <em>objects</em> that may be read from or written to <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stm_el.htm#stream-element-type)", "stream-error-stream": "```commonlisp\nstream-error-stream condition => stream\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>stream-error</code>. </p><p><code>stream</code> &mdash; a <em>stream</em>. </p><p>Returns the offending <em>stream</em> of a <em>condition</em> of <em>type</em> <code>stream-error</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stm_er.htm#stream-error-stream)", "streamp": "```commonlisp\nstreamp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>stream</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stmp.htm#streamp)", "stream-external-format": "```commonlisp\nstream-external-format stream => format\n```\n\n<p><code>stream</code> &mdash; a <em>file stream</em>. </p><p><code>format</code> &mdash; an <em>external file format</em>. </p><p>Returns an <em>external file format designator</em> for the <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stm_ex.htm#stream-external-format)", "string<=": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringLTEQ)", "string=": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringEQ)", "string-capitalize": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#string-capitalize)", "string<": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringLT)", "string-downcase": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#string-downcase)", "string-left-trim": "```commonlisp\nstring-trim character-bag string => trimmed-string\nstring-left-trim character-bag string => trimmed-string\nstring-right-trim character-bag string => trimmed-string\n```\n\n<p><code>character-bag</code> &mdash; a <em>sequence</em> containing <em>characters</em>. </p><p> <code>string</code> &mdash; a <em>string designator</em>.  </p><p><code>trimmed-string</code> &mdash; a <em>string</em>. </p><p><code>string-trim</code> returns a substring of <em>string</em>, with all characters in <em>character-bag</em> stripped off the beginning and end. <code>string-left-trim</code> is similar but strips characters off only the beginning; <code>string-right-trim</code> strips off only the end. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_tr.htm#string-left-trim)", "string/=": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringSLEQ)", "string-greaterp": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-greaterp)", "string-not-equal": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-not-equal)", "stringp": "```commonlisp\nstringp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>string</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgp.htm#stringp)", "string-not-greaterp": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-not-greaterp)", "string-lessp": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-lessp)", "string-right-trim": "```commonlisp\nstring-trim character-bag string => trimmed-string\nstring-left-trim character-bag string => trimmed-string\nstring-right-trim character-bag string => trimmed-string\n```\n\n<p><code>character-bag</code> &mdash; a <em>sequence</em> containing <em>characters</em>. </p><p> <code>string</code> &mdash; a <em>string designator</em>.  </p><p><code>trimmed-string</code> &mdash; a <em>string</em>. </p><p><code>string-trim</code> returns a substring of <em>string</em>, with all characters in <em>character-bag</em> stripped off the beginning and end. <code>string-left-trim</code> is similar but strips characters off only the beginning; <code>string-right-trim</code> strips off only the end. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_tr.htm#string-right-trim)", "string-upcase": "```commonlisp\nstring-upcase string &key start end => cased-string\nstring-downcase string &key start end => cased-string\nstring-capitalize string &key start end => cased-string\nnstring-upcase string &key start end => string\nnstring-downcase string &key start end => string\nnstring-capitalize string &key start end => string\n```\n\n<p> <code>string</code> &mdash; a <em>string designator</em>. For <code>nstring-upcase</code>, <code>nstring-downcase</code>, and <code>nstring-capitalize</code>, the <em>string</em> <em>designator</em> must be a <em>string</em>.  </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>cased-string</code> &mdash; a <em>string</em>. </p><p><code>string-upcase</code>, <code>string-downcase</code>, <code>string-capitalize</code>, <code>nstring-upcase</code>, <code>nstring-downcase</code>, <code>nstring-capitalize</code> change the case of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> as follows: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_up.htm#string-upcase)", "string>=": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringGTEQ)", "sublis": "```commonlisp\nsublis alist tree &key key test test-not => new-tree\nnsublis alist tree &key key test test-not => new-tree\n```\n\n<p><code>alist</code> &mdash; an <em>association list</em>. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>sublis</code> makes substitutions for <em>objects</em> in <em>tree</em> (a structure of <em>conses</em>). <code>nsublis</code> is like <code>sublis</code> but destructively modifies the relevant parts of the <em>tree</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sublis.htm#sublis)", "string-equal": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-equal)", "string-trim": "```commonlisp\nstring-trim character-bag string => trimmed-string\nstring-left-trim character-bag string => trimmed-string\nstring-right-trim character-bag string => trimmed-string\n```\n\n<p><code>character-bag</code> &mdash; a <em>sequence</em> containing <em>characters</em>. </p><p> <code>string</code> &mdash; a <em>string designator</em>.  </p><p><code>trimmed-string</code> &mdash; a <em>string</em>. </p><p><code>string-trim</code> returns a substring of <em>string</em>, with all characters in <em>character-bag</em> stripped off the beginning and end. <code>string-left-trim</code> is similar but strips characters off only the beginning; <code>string-right-trim</code> strips off only the end. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stg_tr.htm#string-trim)", "subsetp": "```commonlisp\nsubsetp list-1 list-2 &key key test test-not => generalized-boolean\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>subsetp</code> returns <em>true</em> if every element of <em>list-1</em> <em>matches</em> some element of <em>list-2</em>, and <em>false</em> otherwise. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_subset.htm#subsetp)", "subst": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#subst)", "string-not-lessp": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#string-not-lessp)", "substitute": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#substitute)", "subst-if-not": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#subst-if-not)", "substitute-if-not": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#substitute-if-not)", "string>": "```commonlisp\nstring= string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring/= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring< string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring> string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring<= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring>= string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean\nstring-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index\nstring-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index\n```\n\n<p> <code>string1</code> &mdash; a <em>string designator</em>. </p><p><code>string2</code> &mdash; a <em>string designator</em>.  </p><p>  <code>start1</code>, <code>end1</code> &mdash; <em>bounding index designators</em> of <em>string1</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively. </p><p><code>start2</code>, <code>end2</code> &mdash; <em>bounding index designators</em> of <em>string2</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>mismatch-index</code> &mdash; a <em>bounding index</em> of <em>string1</em>, or <code>nil</code>. </p><p>These functions perform lexicographic comparisons on <em>string1</em> and <em>string2</em>. <code>string=</code> and <code>string-equal</code> are called equality functions; the others are called inequality functions. The comparison operations these <em>functions</em> perform are restricted to the subsequence of <em>string1</em> <em>bounded</em> by <em>start1</em> and <em>end1</em> and to the subsequence of <em>string2</em> <em>bounded</em> by <em>start2</em> and <em>end2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_stgeq_.htm#stringGT)", "subst-if": "```commonlisp\nsubst new old tree &key key test test-not => new-tree\nsubst-if new predicate tree &key key => new-tree\nsubst-if-not new predicate tree &key key => new-tree\nnsubst new old tree &key key test test-not => new-tree\nnsubst-if new predicate tree &key key => new-tree\nnsubst-if-not new predicate tree &key key => new-tree\n```\n\n<p><code>new</code> &mdash; an <em>object</em>. </p><p><code>old</code> &mdash; an <em>object</em>. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em>, or a <em>function</em> of one argument that returns a <em>generalized boolean</em> value. </p><p> <code>tree</code> &mdash; a <em>tree</em>.  </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p> <code>new-tree</code> &mdash; a <em>tree</em>.  </p><p><code>subst</code>, <code>subst-if</code>, and <code>subst-if-not</code> perform substitution operations on <em>tree</em>. Each function searches <em>tree</em> for occurrences of a particular <em>old</em> item of an element or subexpression that <em>satisfies the test</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_substc.htm#subst-if)", "subtypep": "```commonlisp\nsubtypep type-1 type-2 &optional environment => subtype-p, valid-p\n```\n\n<p><code>type-1</code> &mdash; a <em>type specifier</em>. </p><p><code>type-2</code> &mdash; a <em>type specifier</em>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>, denoting the <em>null lexical environment</em> and the current <em>global environment</em>. </p><p><code>subtype-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>valid-p</code> &mdash; a <em>generalized boolean</em>. </p><p>If <em>type-1</em> is a <em>recognizable subtype</em> of <em>type-2</em>, the first <em>value</em> is <em>true</em>. Otherwise, the first <em>value</em> is <em>false</em>, indicating that either <em>type-1</em> is not a <em>subtype</em> of <em>type-2</em>, or else <em>type-1</em> is a <em>subtype</em> of <em>type-2</em> but is not a <em>recognizable subtype</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_subtpp.htm#subtypep)", "symbol-name": "```commonlisp\nsymbol-name symbol => name\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>name</code> &mdash; a <em>string</em>. </p><p><code>symbol-name</code> returns the <em>name</em> of <em>symbol</em>.  The consequences are undefined if <em>name</em> is ever modified.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symb_2.htm#symbol-name)", "substitute-if": "```commonlisp\nsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => result-sequence\nsubstitute-if newitem predicate sequence &key from-end start end count key\n => result-sequence\nsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => result-sequence\nnsubstitute newitem olditem sequence &key from-end test test-not start end count key\n => sequence\nnsubstitute-if newitem predicate sequence &key from-end start end count key\n => sequence\nnsubstitute-if-not newitem predicate sequence &key from-end start end count key\n => sequence\n```\n\n<p><code>newitem</code> &mdash; an <em>object</em>. </p><p><code>olditem</code> &mdash; an <em>object</em>. </p><p><code>sequence</code> &mdash; a <em>proper sequence</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>from-end</code> &mdash; a <em>generalized boolean</em>. The default is <em>false</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>sequence</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p> <code>count</code> &mdash; an <em>integer</em> or <code>nil</code>.  The default is <code>nil</code>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-sequence</code> &mdash; a <em>sequence</em>. </p><p><code>substitute</code>, <code>substitute-if</code>, and <code>substitute-if-not</code> return a copy of <em>sequence</em> in which each <em>element</em> that <em>satisfies the test</em> has been replaced with <em>newitem</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sbs_s.htm#substitute-if)", "symbolp": "```commonlisp\nsymbolp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>symbol</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symbol.htm#symbolp)", "sxhash": "```commonlisp\nsxhash object => hash-code\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>hash-code</code> &mdash; a non-negative <em>fixnum</em>. </p><p><code>sxhash</code> returns a hash code for <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sxhash.htm#sxhash)", "symbol-package": "```commonlisp\nsymbol-package symbol => contents\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>contents</code> &mdash; a <em>package</em> <em>object</em> or <code>nil</code>. </p><p>Returns the <em>home package</em> of <em>symbol</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_symb_3.htm#symbol-package)", "tailp": "```commonlisp\nldiff list object => result-list\ntailp object list => generalized-boolean\n```\n\n<p><code>list</code> &mdash; a <em>list</em>,  which might be a <em>dotted list</em>. </p><p><code>object</code> &mdash; an <em>object</em>.  </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p> If <em>object</em> is the <em>same</em> as some <em>tail</em> of <em>list</em>, <code>tailp</code> returns <em>true</em>; otherwise, it returns <em>false</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_ldiffc.htm#tailp)", "synonym-stream-symbol": "```commonlisp\nsynonym-stream-symbol synonym-stream => symbol\n```\n\n<p><code>synonym-stream</code> &mdash; a <em>synonym stream</em>. </p><p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p>Returns the <em>symbol</em> whose <code>symbol-value</code> the <em>synonym-stream</em> is using. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_syn_st.htm#synonym-stream-symbol)", "tan": "```commonlisp\nsin radians => number\ncos radians => number\ntan radians => number\n```\n\n<p><code>radians</code> &mdash; a <em>number</em> given in radians. </p><p><code>number</code> &mdash; a <em>number</em>. </p><p><code>sin</code>, <code>cos</code>, and <code>tan</code> return the sine, cosine, and tangent, respectively, of <em>radians</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sin_c.htm#tan)", "tanh": "```commonlisp\nsinh number => result\ncosh number => result\ntanh number => result\nasinh number => result\nacosh number => result\natanh number => result\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>result</code> &mdash; a <em>number</em>. </p><p>These functions compute the hyperbolic sine, cosine, tangent, arc sine, arc cosine, and arc tangent functions, which are mathematically defined for an argument <em>x</em> as given in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_sinh_.htm#tanh)", "terpri": "```commonlisp\nterpri &optional output-stream => nil\nfresh-line &optional output-stream => generalized-boolean\n```\n\n<p><code>output-stream</code>  &mdash;  an <code>output</code> <code>stream designator</code>. The default is <code>standard output</code>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>terpri</code> outputs a <em>newline</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_terpri.htm#terpri)", "translate-logical-pathname": "```commonlisp\ntranslate-logical-pathname pathname &key => physical-pathname\n```\n\n<p><code>pathname</code> &mdash; a <em>pathname designator</em>, or a <em>logical pathname</em> <em>namestring</em>. </p><p><code>physical-pathname</code> &mdash; a <em>physical pathname</em>. </p><p>Translates <em>pathname</em> to a <em>physical pathname</em>, which it returns. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tr_log.htm#translate-logical-pathname)", "tree-equal": "```commonlisp\ntree-equal tree-1 tree-2 &key test test-not => generalized-boolean\n```\n\n<p><code>tree-1</code> &mdash; a <em>tree</em>. </p><p><code>tree-2</code> &mdash; a <em>tree</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>tree-equal</code> tests whether two trees are of the same shape and have the same leaves. <code>tree-equal</code> returns <em>true</em> if <em>tree-1</em> and <em>tree-2</em> are both <em>atoms</em> and <em>satisfy the test</em>, or if they are both <em>conses</em> and the <em>car</em> of <em>tree-1</em> is <code>tree-equal</code> to the <em>car</em> of <em>tree-2</em> and the <em>cdr</em> of <em>tree-1</em> is <code>tree-equal</code> to the <em>cdr</em> of <em>tree-2</em>. Otherwise, <code>tree-equal</code> returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tree_e.htm#tree-equal)", "translate-pathname": "```commonlisp\ntranslate-pathname source from-wildcard to-wildcard &key\n => translated-pathname\n```\n\n<p><code>source</code> &mdash; a <em>pathname designator</em>. </p><p><code>from-wildcard</code> &mdash; a <em>pathname designator</em>. </p><p><code>to-wildcard</code> &mdash; a <em>pathname designator</em>. </p><p><code>translated-pathname</code> &mdash; a <em>pathname</em>. </p><p><code>translate-pathname</code> translates <em>source</em> (that matches <em>from-wildcard</em>) into a corresponding <em>pathname</em> that matches <em>to-wildcard</em>, and returns the corresponding <em>pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tr_pn.htm#translate-pathname)", "truncate": "```commonlisp\nfloor number &optional divisor => quotient, remainder\nffloor number &optional divisor => quotient, remainder\nceiling number &optional divisor => quotient, remainder\nfceiling number &optional divisor => quotient, remainder\ntruncate number &optional divisor => quotient, remainder\nftruncate number &optional divisor => quotient, remainder\nround number &optional divisor => quotient, remainder\nfround number &optional divisor => quotient, remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a non-zero <em>real</em>. The default is the <em>integer</em> <code>1</code>. </p><p><code>quotient</code> &mdash; for <code>floor</code>, <code>ceiling</code>, <code>truncate</code>, and <code>round</code>: an <em>integer</em>; for <code>ffloor</code>, <code>fceiling</code>, <code>ftruncate</code>, and <code>fround</code>: a <em>float</em>. </p><p><code>remainder</code> &mdash; a <em>real</em>. </p><p>These functions divide <em>number</em> by <em>divisor</em>, returning a <em>quotient</em> and <em>remainder</em>, such that </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_floorc.htm#truncate)", "truename": "```commonlisp\ntruename filespec => truename\n```\n\n<p> <code>filespec</code> &mdash; a <em>pathname designator</em>.  </p><p> <code>truename</code> &mdash; a <em>physical pathname</em>.  </p><p><code>truename</code> tries to find the <em>file</em> indicated by <em>filespec</em> and returns its <em>truename</em>. If the <em>filespec</em> <em>designator</em> is an open <em>stream</em>, its associated <em>file</em> is used.  If <em>filespec</em> is a <em>stream</em>, <code>truename</code> can be used whether the <em>stream</em> is open or closed. It is permissible for <code>truename</code> to return more specific information after the <em>stream</em> is closed than when the <em>stream</em> was open.  If <em>filespec</em> is a <em>pathname</em> it represents the name used to open the file. This may be, but is not required to be, the actual name of the file. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tn.htm#truename)", "two-way-stream-output-stream": "```commonlisp\ntwo-way-stream-input-stream two-way-stream => input-stream\ntwo-way-stream-output-stream two-way-stream => output-stream\n```\n\n<p><code>two-way-stream</code> &mdash; a <em>two-way stream</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>two-way-stream-input-stream</code> returns the <em>stream</em> from which <em>two-way-stream</em> receives input. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_two_wa.htm#two-way-stream-output-stream)", "type-error-expected-type": "```commonlisp\ntype-error-datum condition => datum\ntype-error-expected-type condition => expected-type\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>type-error</code>. </p><p><code>datum</code> &mdash; an <em>object</em>. </p><p><code>expected-type</code> &mdash; a <em>type specifier</em>. </p><p><code>type-error-datum</code> returns the offending datum in the <em>situation</em> represented by the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tp_err.htm#type-error-expected-type)", "type-of": "```commonlisp\ntype-of object => typespec\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p>Returns a <em>type specifier</em>, <em>typespec</em>, for a <em>type</em> that has the <em>object</em> as an <em>element</em>. The <em>typespec</em> satisfies the following: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tp_of.htm#type-of)", "two-way-stream-input-stream": "```commonlisp\ntwo-way-stream-input-stream two-way-stream => input-stream\ntwo-way-stream-output-stream two-way-stream => output-stream\n```\n\n<p><code>two-way-stream</code> &mdash; a <em>two-way stream</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream</em>. </p><p><code>two-way-stream-input-stream</code> returns the <em>stream</em> from which <em>two-way-stream</em> receives input. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_two_wa.htm#two-way-stream-input-stream)", "type-error-datum": "```commonlisp\ntype-error-datum condition => datum\ntype-error-expected-type condition => expected-type\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>type-error</code>. </p><p><code>datum</code> &mdash; an <em>object</em>. </p><p><code>expected-type</code> &mdash; a <em>type specifier</em>. </p><p><code>type-error-datum</code> returns the offending datum in the <em>situation</em> represented by the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_tp_err.htm#type-error-datum)", "typep": "```commonlisp\ntypep object type-specifier &optional environment => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>type-specifier</code> &mdash; any <em>type specifier</em> except <code>values</code>, or a <em>type specifier</em> list whose first element is either <code>function</code> or <code>values</code>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>, denoting the <em>null lexical environment</em> and the and current <em>global environment</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of the <em>type</em> specified by <em>type-specifier</em>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_typep.htm#typep)", "unexport": "```commonlisp\nunexport symbols &optional package => t\n```\n\n<p><code>symbols</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>symbols</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>unexport</code> reverts external <em>symbols</em> in <em>package</em> to internal status; it undoes the effect of <code>export</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unexpo.htm#unexport)", "unbound-slot-instance": "```commonlisp\nunbound-slot-instance condition => instance\n```\n\n<p><code>condition</code> &mdash; a <em>condition</em> of <em>type</em> <code>unbound-slot</code>. </p><p><code>instance</code> &mdash; an <em>object</em>. </p><p>Returns the instance which had the unbound slot in the <em>situation</em> represented by the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unboun.htm#unbound-slot-instance)", "union": "```commonlisp\nunion list-1 list-2 &key key test test-not => result-list\nnunion list-1 list-2 &key key test test-not => result-list\n```\n\n<p><code>list-1</code> &mdash; a <em>proper list</em>. </p><p><code>list-2</code> &mdash; a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>result-list</code> &mdash; a <em>list</em>. </p><p><code>union</code> and <code>nunion</code> return a <em>list</em> that contains every element that occurs in either <em>list-1</em> or <em>list-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unionc.htm#union)", "unintern": "```commonlisp\nunintern symbol &optional package => generalized-boolean\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p> <code>package</code> &mdash; a <em>package designator</em>.  The default is the <em>current package</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>unintern</code> removes <em>symbol</em> from <em>package</em>. If <em>symbol</em> is <em>present</em> in <em>package</em>, it is removed from <em>package</em> and also from <em>package</em>'s <em>shadowing symbols list</em> if it is present there. If <em>package</em> is the <em>home package</em> for <em>symbol</em>, <em>symbol</em> is made to have no <em>home package</em>. <em>Symbol</em> may continue to be <em>accessible</em> in <em>package</em> by inheritance. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_uninte.htm#unintern)", "unread-char": "```commonlisp\nunread-char character &optional input-stream => nil\n```\n\n<p><code>character</code> &mdash; a <em>character</em>; must be the last <em>character</em> that was read from <em>input-stream</em>. </p><p><code>input-stream</code> &mdash; an <em>input</em> <em>stream designator</em>. The default is <em>standard input</em>. </p><p><code>unread-char</code> places <em>character</em> back onto the front of <em>input-stream</em> so that it will again be the next character in <em>input-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unrd_c.htm#unread-char)", "upper-case-p": "```commonlisp\nupper-case-p character => generalized-boolean\nlower-case-p character => generalized-boolean\nboth-case-p character => generalized-boolean\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These functions test the case of a given <em>character</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upper_.htm#upper-case-p)", "unuse-package": "```commonlisp\nunuse-package packages-to-unuse &optional package => t\n```\n\n<p> <code>packages-to-unuse</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>package designators</em>.  </p><p><code>package</code> &mdash; a <em>package designator</em>. The default is the <em>current package</em>. </p><p><code>unuse-package</code> causes <em>package</em> to cease inheriting all the <em>external symbols</em> of <em>packages-to-unuse</em>; <code>unuse-package</code> undoes the effects of <code>use-package</code>. The <em>packages-to-unuse</em> are removed from the <em>use list</em> of <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_unuse_.htm#unuse-package)", "upgraded-array-element-type": "```commonlisp\nupgraded-array-element-type typespec &optional environment => upgraded-typespec\n```\n\n<p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>, denoting the <em>null lexical environment</em> and the current <em>global environment</em>. </p><p><code>upgraded-typespec</code> &mdash; a <em>type specifier</em>. </p><p>Returns the <em>element type</em> of the most <em>specialized</em> <em>array</em> representation capable of holding items of the <em>type</em> denoted by <em>typespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upgr_1.htm#upgraded-array-element-type)", "upgraded-complex-part-type": "```commonlisp\nupgraded-complex-part-type typespec &optional environment => upgraded-typespec\n```\n\n<p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>environment</code> &mdash; an <em>environment</em> <em>object</em>. The default is <code>nil</code>, denoting the <em>null lexical environment</em> and the and current <em>global environment</em>. </p><p><code>upgraded-typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>upgraded-complex-part-type</code> returns the part type of the most specialized <em>complex</em> number representation that can hold parts of <em>type</em> <em>typespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upgrad.htm#upgraded-complex-part-type)", "use-package": "```commonlisp\nuse-package packages-to-use &optional package => t\n```\n\n<p> <code>packages-to-use</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>package designators</em>. The <code>KEYWORD</code> package may not be supplied. </p><p><code>package</code> &mdash; a <em>package designator</em>. The default is the <em>current package</em>. The <em>package</em> cannot be the <code>KEYWORD</code> package.  </p><p><code>use-package</code> causes <em>package</em> to inherit all the <em>external symbols</em> of <em>packages-to-use</em>. The inherited <em>symbols</em> become <em>accessible</em> as <em>internal symbols</em> of <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_use_pk.htm#use-package)", "user-homedir-pathname": "```commonlisp\nuser-homedir-pathname &optional host => pathname\n```\n\n<p><code>host</code> &mdash; a <em>string</em>, a <em>list</em> of <em>strings</em>, or <code>:unspecific</code>. </p><p><code>pathname</code> &mdash; a <em>pathname</em>, or <code>nil</code>. </p><p><code>user-homedir-pathname</code> determines the <em>pathname</em> that corresponds to the user's home directory on <em>host</em>. If <em>host</em> is not supplied, its value is <em>implementation-dependent</em>.  For a description of <code>:unspecific</code>, see Section 19.2.1 (Pathname Components).  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_user_h.htm#user-homedir-pathname)", "values-list": "```commonlisp\nvalues-list list => element*\n```\n\n<p><code>list</code> &mdash; a <em>list</em>. </p><p><code>elements</code> &mdash; the <em>elements</em> of the <em>list</em>. </p><p>Returns the <em>elements</em> of the <em>list</em> as <em>multiple values</em>[2]. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_vals_l.htm#values-list)", "vectorp": "```commonlisp\nvectorp object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>vector</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_vecp.htm#vectorp)", "vector-pop": "```commonlisp\nvector-pop vector => element\n```\n\n<p><code>vector</code> &mdash; a <em>vector</em> with a <em>fill pointer</em>. </p><p><code>element</code> &mdash; an <em>object</em>. </p><p>Decreases the <em>fill pointer</em> of <em>vector</em> by one, and retrieves the <em>element</em> of <em>vector</em> that is designated by the new <em>fill pointer</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_vec_po.htm#vector-pop)", "warn": "```commonlisp\nwarn datum &rest arguments => nil\n```\n\n<p><code>datum</code>, <code>arguments</code> &mdash; <em>designators</em> for a <em>condition</em> of default type <code>simple-warning</code>. </p><p><em>Signals</em> a <em>condition</em> of <em>type</em> <code>warning</code>. If the <em>condition</em> is not <em>handled</em>, reports the <em>condition</em> to <em>error output</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_warn.htm#warn)", "vector-push": "```commonlisp\nvector-push new-element vector => new-index-p\nvector-push-extend new-element vector &optional extension => new-index\n```\n\n<p><code>new-element</code> &mdash; an <em>object</em>. </p><p><code>vector</code> &mdash; a <em>vector</em> with a <em>fill pointer</em>. </p><p><code>extension</code> &mdash; a positive <em>integer</em>. The default is <em>implementation-dependent</em>. </p><p><code>new-index-p</code> &mdash; a <em>valid array index</em> for <em>vector</em>, or <code>nil</code>. </p><p><code>new-index</code> &mdash; a <em>valid array index</em> for <em>vector</em>. </p><p><code>vector-push</code> and <code>vector-push-extend</code> store <em>new-element</em> in <em>vector</em>. <code>vector-push</code> attempts to store <em>new-element</em> in the element of <em>vector</em> designated by the <em>fill pointer</em>, and to increase the <em>fill pointer</em> by one. If the <code>(&gt;= (fill-pointer </code><em>vector</em><code>) (array-dimension </code><em>vector</em><code> 0))</code>, neither <em>vector</em> nor its <em>fill pointer</em> are affected. Otherwise, the store and increment take place and <code>vector-push</code> returns the former value of the <em>fill pointer</em> which is one less than the one it leaves in <em>vector</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_vec_ps.htm#vector-push)", "wild-pathname-p": "```commonlisp\nwild-pathname-p pathname &optional field-key => generalized-boolean\n```\n\n<p> <code>pathname</code> &mdash; a <em>pathname designator</em>.  </p><p><code>Field-key</code> &mdash; one of <code>:host</code>, <code>:device</code> <code>:directory</code>, <code>:name</code>, <code>:type</code>, <code>:version</code>, or <code>nil</code>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>wild-pathname-p</code> tests <em>pathname</em> for the presence of wildcard components. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wild_p.htm#wild-pathname-p)", "write": "```commonlisp\nwrite object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream\n => object\nprin1 object &optional output-stream => object\nprinc object &optional output-stream => object\nprint object &optional output-stream => object\npprint object &optional output-stream => <no values>\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>output-stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>stream</code> &mdash; an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write</code>, <code>prin1</code>, <code>princ</code>, <code>print</code>, and <code>pprint</code> write the printed representation of <em>object</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_pr.htm#write)", "write-byte": "```commonlisp\nwrite-byte byte stream => byte\n```\n\n<p><code>byte</code> &mdash; an <em>integer</em> of the <em>stream element type</em> of <em>stream</em>. </p><p><code>stream</code> &mdash; a <em>binary</em> <em>output</em> <em>stream</em>. </p><p><code>write-byte</code> writes one byte, <em>byte</em>, to <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_by.htm#write-byte)", "vector-push-extend": "```commonlisp\nvector-push new-element vector => new-index-p\nvector-push-extend new-element vector &optional extension => new-index\n```\n\n<p><code>new-element</code> &mdash; an <em>object</em>. </p><p><code>vector</code> &mdash; a <em>vector</em> with a <em>fill pointer</em>. </p><p><code>extension</code> &mdash; a positive <em>integer</em>. The default is <em>implementation-dependent</em>. </p><p><code>new-index-p</code> &mdash; a <em>valid array index</em> for <em>vector</em>, or <code>nil</code>. </p><p><code>new-index</code> &mdash; a <em>valid array index</em> for <em>vector</em>. </p><p><code>vector-push</code> and <code>vector-push-extend</code> store <em>new-element</em> in <em>vector</em>. <code>vector-push</code> attempts to store <em>new-element</em> in the element of <em>vector</em> designated by the <em>fill pointer</em>, and to increase the <em>fill pointer</em> by one. If the <code>(&gt;= (fill-pointer </code><em>vector</em><code>) (array-dimension </code><em>vector</em><code> 0))</code>, neither <em>vector</em> nor its <em>fill pointer</em> are affected. Otherwise, the store and increment take place and <code>vector-push</code> returns the former value of the <em>fill pointer</em> which is one less than the one it leaves in <em>vector</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_vec_ps.htm#vector-push-extend)", "write-char": "```commonlisp\nwrite-char character &optional output-stream => character\n```\n\n<p><code>character</code> &mdash; a <em>character</em>. </p><p><em>output-stream</em>  &mdash;  an <em>output</em> <em>stream designator</em>. The default is <em>standard output</em>. </p><p><code>write-char</code> outputs <em>character</em> to <em>output-stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_cha.htm#write-char)", "write-string": "```commonlisp\nwrite-string string &optional output-stream &key start end => string\nwrite-line string &optional output-stream &key start end => string\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p><code>output-stream</code>  &mdash;  an <code>output</code> <code>stream designator</code>. The default is <code>standard output</code>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>write-string</code> writes the <em>characters</em> of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> to <em>output-stream</em>. <code>write-line</code> does the same thing, but then outputs a newline afterwards. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_stg.htm#write-string)", "write-to-string": "```commonlisp\nwrite-to-string object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin \n => string\nprin1-to-string object => string\nprinc-to-string object => string\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>array</code> &mdash; a <em>generalized boolean</em>. </p><p><code>base</code> &mdash; a <em>radix</em>. </p><p><code>case</code> &mdash; a <em>symbol</em> of <em>type</em> <code>(member :upcase :downcase :capitalize)</code>. </p><p><code>circle</code> &mdash; a <em>generalized boolean</em>. </p><p><code>escape</code> &mdash; a <em>generalized boolean</em>. </p><p><code>gensym</code> &mdash; a <em>generalized boolean</em>. </p><p><code>length</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>level</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>lines</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>miser-width</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>pprint-dispatch</code> &mdash; a <em>pprint dispatch table</em>. </p><p><code>pretty</code> &mdash; a <em>generalized boolean</em>. </p><p><code>radix</code> &mdash; a <em>generalized boolean</em>. </p><p><code>readably</code> &mdash; a <em>generalized boolean</em>. </p><p><code>right-margin</code> &mdash; a non-negative <em>integer</em>, or <code>nil</code>.  </p><p><code>string</code> &mdash; a <em>string</em>. </p><p><code>write-to-string</code>, <code>prin1-to-string</code>, and <code>princ-to-string</code> are used to create a <em>string</em> consisting of the printed representation of <em>object</em>. <em>Object</em> is effectively printed as if by <code>write</code>, <code>prin1</code>, or <code>princ</code>, respectively, and the <em>characters</em> that would be output are made into a <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_to_.htm#write-to-string)", "write-sequence": "```commonlisp\nwrite-sequence sequence stream &key start end => sequence\nsequence \u2014 a sequence. \nstream \u2014 an output stream. \nstart, end \u2014 bounding index designators of sequence. The defaults for start and end are 0 and nil, respectively. \n```\n\n<p><code>write-sequence</code> writes the <em>elements</em> of the subsequence of <em>sequence</em> <em>bounded</em> by <em>start</em> and <em>end</em> to <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_seq.htm#write-sequence)", "zerop": "```commonlisp\nzerop number => generalized-boolean\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>number</em> is zero (<em>integer</em>, <em>float</em>, or <em>complex</em>); otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_zerop.htm#zerop)", "write-line": "```commonlisp\nwrite-string string &optional output-stream &key start end => string\nwrite-line string &optional output-stream &key start end => string\n```\n\n<p><code>string</code> &mdash; a <em>string</em>. </p><p><code>output-stream</code>  &mdash;  an <code>output</code> <code>stream designator</code>. The default is <code>standard output</code>. </p><p>  <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.   </p><p><code>write-string</code> writes the <em>characters</em> of the subsequence of <em>string</em> <em>bounded</em> by <em>start</em> and <em>end</em> to <em>output-stream</em>. <code>write-line</code> does the same thing, but then outputs a newline afterwards. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_wr_stg.htm#write-line)", "y-or-n-p": "```commonlisp\ny-or-n-p &optional control &rest arguments => generalized-boolean\nyes-or-no-p &optional control &rest arguments => generalized-boolean\n```\n\n<p> <code>control</code> &mdash; a <em>format control</em>.  </p><p><code>arguments</code> &mdash; <em>format arguments</em> for <em>control</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These functions ask a question and parse a response from the user. They return <em>true</em> if the answer is affirmative, or <em>false</em> if the answer is negative. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_y_or_n.htm#y-or-n-p)", "yes-or-no-p": "```commonlisp\ny-or-n-p &optional control &rest arguments => generalized-boolean\nyes-or-no-p &optional control &rest arguments => generalized-boolean\n```\n\n<p> <code>control</code> &mdash; a <em>format control</em>.  </p><p><code>arguments</code> &mdash; <em>format arguments</em> for <em>control</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>These functions ask a question and parse a response from the user. They return <em>true</em> if the answer is affirmative, or <em>false</em> if the answer is negative. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_y_or_n.htm#yes-or-no-p)", "call-next-method": "```commonlisp\ncall-next-method &rest args => result*\n```\n\n<p><code>arg</code> &mdash; an <em>object</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>method</em> it calls. </p><p>The <em>function</em> <code>call-next-method</code> can be used  within the body <em>forms</em> (but not the <em>lambda list</em>)  of a <em>method</em> defined by a <em>method-defining form</em> to call the <em>next method</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_call_n.htm#call-next-method)", "next-method-p": "```commonlisp\nnext-method-p <no arguments> => generalized-boolean\n```\n\n<p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>The locally defined function <code>next-method-p</code> can be used  within the body <em>forms</em> (but not the <em>lambda list</em>)  defined by a <em>method-defining form</em> to determine whether a next <em>method</em> exists. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_next_m.htm#next-method-p)", "loop-finish": "```commonlisp\nloop-finish <no arguments> =>| \n```\n\n<p>The <code>loop-finish</code> <em>macro</em> can be used lexically within an extended <code>loop</code> <em>form</em> to terminate that <em>form</em> ``normally.'' That is, it transfers control to the loop epilogue of the lexically innermost extended <code>loop</code> <em>form</em>. This permits execution of any <code>finally</code> clause (for effect) and the return of any accumulated result. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_loop_f.htm#loop-finish)", "pprint-exit-if-list-exhausted": "```commonlisp\npprint-exit-if-list-exhausted <no arguments> => nil\n```\n\n<p>Tests whether or not the <em>list</em> passed to the <em>lexically current logical block</em> has been exhausted; see Section 22.2.1.1 (Dynamic Control of the Arrangement of Output). If this <em>list</em> has been reduced to <code>nil</code>, <code>pprint-exit-if-list-exhausted</code> terminates the execution of the <em>lexically current logical block</em> except for the printing of the suffix. Otherwise <code>pprint-exit-if-list-exhausted</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_ppr_ex.htm#pprint-exit-if-list-exhausted)", "call-method": "```commonlisp\ncall-method method &optional next-method-list => result*\nmake-method form => method-object\n```\n\n<p><code>method</code> &mdash; a <em>method</em> <em>object</em>, or a <em>list</em> (see below); not evaluated. </p><p><code>method-object</code> &mdash; a <em>method</em> <em>object</em>. </p><p><code>next-method-list</code> &mdash; a <em>list</em> of <em>method</em> <em>objects</em>; not evaluated. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>method</em> invocation. </p><p>The macro <code>call-method</code> is used in method combination. It hides the <em>implementation-dependent</em> details of how <em>methods</em> are called. The macro <code>call-method</code> has <em>lexical scope</em> and can only be used within an <em>effective method</em> <em>form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_call_m.htm#call-method)", "make-method": "```commonlisp\ncall-method method &optional next-method-list => result*\nmake-method form => method-object\n```\n\n<p><code>method</code> &mdash; a <em>method</em> <em>object</em>, or a <em>list</em> (see below); not evaluated. </p><p><code>method-object</code> &mdash; a <em>method</em> <em>object</em>. </p><p><code>next-method-list</code> &mdash; a <em>list</em> of <em>method</em> <em>objects</em>; not evaluated. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>method</em> invocation. </p><p>The macro <code>call-method</code> is used in method combination. It hides the <em>implementation-dependent</em> details of how <em>methods</em> are called. The macro <code>call-method</code> has <em>lexical scope</em> and can only be used within an <em>effective method</em> <em>form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_call_m.htm#make-method)", "assert": "```commonlisp\nassert test-form [(place*) [datum-form argument-form*]]\n => nil\n```\n\n<p><code>test-form</code> &mdash; a <em>form</em>; always evaluated. </p><p><code>place</code> &mdash; a <em>place</em>; evaluated if an error is signaled. </p><p> <code>datum-form</code> &mdash; a <em>form</em> that evaluates to a <em>datum</em>. Evaluated each time an error is to be signaled, or not at all if no error is to be signaled. </p><p><code>argument-form</code> &mdash; a <em>form</em> that evaluates to an <em>argument</em>. Evaluated each time an error is to be signaled, or not at all if no error is to be signaled. </p><p> <code>datum</code>, <code>arguments</code> &mdash; <em>designators</em> for a <em>condition</em> of default type <code>error</code>. (These <em>designators</em> are the result of evaluating <em>datum-form</em> and each of the <em>argument-forms</em>.)   </p><p><code>assert</code> assures that <em>test-form</em> evaluates to <em>true</em>. If <em>test-form</em> evaluates to <em>false</em>, <code>assert</code> signals a <em>correctable</em> <em>error</em> (denoted by <em>datum</em> and <em>arguments</em>). Continuing from this error using the <code>continue</code> <em>restart</em> makes it possible for the user to alter the values of the <em>places</em> before <code>assert</code> evaluates <em>test-form</em> again. If the value of <em>test-form</em> is <em>non-nil</em>, <code>assert</code> returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_assert.htm#assert)", "pprint-pop": "```commonlisp\npprint-pop <no arguments> => object\n```\n\n<p><code>object</code> &mdash; an <em>element</em> of the <em>list</em> being printed in the <em>lexically current logical block</em>, or <code>nil</code>. </p><p>Pops one <em>element</em> from the <em>list</em> being printed in the <em>lexically current logical block</em>, obeying <code>*print-length*</code> and <code>*print-circle*</code> as described below. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_ppr_po.htm#pprint-pop)", "ccase": "```commonlisp\ncase keyform {normal-clause}* [otherwise-clause] => result*\nccase keyplace {normal-clause}* => result*\necase keyform {normal-clause}* => result*\nnormal-clause::= (keys form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>keys</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>keys</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>objects</em>. In the case of <code>case</code>, the <em>symbols</em> <code>t</code> and <code>otherwise</code> may not be used as the <em>keys</em> <em>designator</em>. To refer to these <em>symbols</em> by themselves as <em>keys</em>, the designators <code>(t)</code> and <code>(otherwise)</code>, respectively, must be used instead. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its identity. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_case_.htm#ccase)", "case": "```commonlisp\ncase keyform {normal-clause}* [otherwise-clause] => result*\nccase keyplace {normal-clause}* => result*\necase keyform {normal-clause}* => result*\nnormal-clause::= (keys form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>keys</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>keys</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>objects</em>. In the case of <code>case</code>, the <em>symbols</em> <code>t</code> and <code>otherwise</code> may not be used as the <em>keys</em> <em>designator</em>. To refer to these <em>symbols</em> by themselves as <em>keys</em>, the designators <code>(t)</code> and <code>(otherwise)</code>, respectively, must be used instead. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its identity. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_case_.htm#case)", "check-type": "```commonlisp\ncheck-type place typespec [string] => nil\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>string</code> &mdash; a <em>string</em>; evaluated. </p><p><code>check-type</code> signals a <em>correctable</em> <em>error</em> of <em>type</em> <code>type-error</code> if the contents of <em>place</em> are not of the type <em>typespec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_check_.htm#check-type)", "cond": "```commonlisp\ncond {clause}* => result*\nclause::= (test-form form*) \n\n```\n\n<p><code>test-form</code> &mdash; a <em>form</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em> in the first <em>clause</em> whose <em>test-form</em> <em>yields</em> <em>true</em>, or the <em>primary value</em> of the <em>test-form</em> if there are no <em>forms</em> in that <em>clause</em>, or else <code>nil</code> if no <em>test-form</em> <em>yields</em> <em>true</em>. </p><p><code>cond</code> allows the execution of <em>forms</em> to be dependent on <em>test-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_cond.htm#cond)", "decf": "```commonlisp\nincf place [delta-form] => new-value\ndecf place [delta-form] => new-value\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>delta-form</code> &mdash; a <em>form</em>; evaluated to produce a <em>delta</em>. The default is <code>1</code>. </p><p><code>delta</code> &mdash; a <em>number</em>. </p><p><code>new-value</code> &mdash; a <em>number</em>. </p><p><code>incf</code> and <code>decf</code> are used for incrementing and decrementing the <em>value</em> of <em>place</em>, respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_incf_.htm#decf)", "ctypecase": "```commonlisp\ntypecase keyform {normal-clause}* [otherwise-clause] => result*\nctypecase keyplace {normal-clause}* => result*\netypecase keyform {normal-clause}* => result*\nnormal-clause::= (type form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>types</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>type</code> &mdash; a <em>type specifier</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its <em>type</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_tpcase.htm#ctypecase)", "declaim": "```commonlisp\ndeclaim declaration-specifier* => implementation-dependent\n```\n\n<p><code>declaration-specifier</code> &mdash; a <em>declaration specifier</em>; not evaluated. </p><p>Establishes the <em>declarations</em> specified by the <em>declaration-specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_declai.htm#declaim)", "defconstant": "```commonlisp\ndefconstant name initial-value [documentation] => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>; not evaluated. </p><p><code>initial-value</code> &mdash; a <em>form</em>; evaluated. </p><p> <code>documentation</code> &mdash; a <em>string</em>; not evaluated.  </p><p><code>defconstant</code> causes the global variable named by <em>name</em> to be given a value that is the result of evaluating <em>initial-value</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defcon.htm#defconstant)", "defclass": "```commonlisp\ndefclass class-name ({superclass-name}*) ({slot-specifier}*) [[class-option]]\n => new-class\nslot-specifier::= slot-name | (slot-name [[slot-option]])\nslot-name::= symbol\nslot-option::= {:reader reader-function-name}* | \n               {:writer writer-function-name}* | \n               {:accessor reader-function-name}* | \n               {:allocation allocation-type} | \n               {:initarg initarg-name}* | \n               {:initform form} | \n               {:type type-specifier} | \n               {:documentation string} \nfunction-name::= {symbol | (setf symbol)}\nclass-option::= (:default-initargs . initarg-list) | \n                (:documentation string) | \n                (:metaclass class-name) \n\n```\n\n<p><code>Class-name</code> &mdash; a <em>non-nil</em> <em>symbol</em>. </p><p><code>Superclass-name</code> &mdash; a <em>non-nil</em> <em>symbol</em>. </p><p><code>Slot-name</code> &mdash; a <em>symbol</em>. The <em>slot-name</em> argument is a <em>symbol</em> that is syntactically valid for use as a variable name. </p><p><code>Reader-function-name</code> &mdash; a <em>non-nil</em> <em>symbol</em>. <code>:reader</code> can be supplied more than once for a given <em>slot</em>. </p><p><code>Writer-function-name</code> &mdash; a <em>generic function</em> name. <code>:writer</code> can be supplied more than once for a given <em>slot</em>. </p><p><code>Reader-function-name</code> &mdash; a <em>non-nil</em> <em>symbol</em>. <code>:accessor</code> can be supplied more than once for a given <em>slot</em>. </p><p><code>Allocation-type</code> &mdash; (member <code>:instance</code> <code>:class</code>). <code>:allocation</code> can be supplied once at most for a given <em>slot</em>. </p><p><code>Initarg-name</code> &mdash; a <em>symbol</em>. <code>:initarg</code> can be supplied more than once for a given <em>slot</em>. </p><p><code>Form</code> &mdash; a <em>form</em>. <code>:init-form</code> can be supplied once at most for a given <em>slot</em>. </p><p><code>Type-specifier</code> &mdash; a <em>type specifier</em>. <code>:type</code> can be supplied once at most for a given <em>slot</em>. </p><p><code>Class-option</code> &mdash;  refers to the <em>class</em> as a whole or to all class <em>slots</em>. </p><p><code>Initarg-list</code> &mdash; a <em>list</em> of alternating initialization argument <em>names</em> and default initial value <em>forms</em>. <code>:default-initargs</code> can be supplied at most once. </p><p><code>Class-name</code> &mdash; a <em>non-nil</em> <em>symbol</em>. <code>:metaclass</code> can be supplied once at most. </p><p>       <code>new-class</code> &mdash; the new <em>class</em> <em>object</em>. </p><p>The macro <code>defclass</code> defines a new named <em>class</em>. It returns the new <em>class</em> <em>object</em> as its result. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defcla.htm#defclass)", "define-compiler-macro": "```commonlisp\ndefine-compiler-macro name lambda-list [[declaration* | documentation]] form*\n => name\n```\n\n<p><code>name</code> &mdash; a <em>function name</em>. </p><p><code>lambda-list</code> &mdash; a <em>macro lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p>This is the normal mechanism for defining a <em>compiler macro function</em>. Its manner of definition is the same as for <code>defmacro</code>; the only differences are: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_define.htm#define-compiler-macro)", "defgeneric": "```commonlisp\ndefgeneric function-name gf-lambda-list [[option | {method-description}*]]\n => new-generic\noption::= (:argument-precedence-order parameter-name+) | \n          (declare gf-declaration+) | \n          (:documentation gf-documentation) | \n          (:method-combination method-combination method-combination-argument*) | \n          (:generic-function-class generic-function-class) | \n          (:method-class method-class) \nmethod-description::= (:method method-qualifier* specialized-lambda-list [[declaration* | documentation]] form*) \n\n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p><code>generic-function-class</code> &mdash; a <em>non-nil</em> <em>symbol</em> naming a <em>class</em>. </p><p><code>gf-declaration</code> &mdash; an <code>optimize</code> <em>declaration specifier</em>; other <em>declaration specifiers</em> are not permitted. </p><p><code>gf-documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>gf-lambda-list</code> &mdash; a <em>generic function lambda list</em>. </p><p><code>method-class</code> &mdash; a <em>non-nil</em> <em>symbol</em> naming a <em>class</em>. </p><p><code>method-combination-argument</code> &mdash; an <em>object.</em> </p><p><code>method-combination-name</code> &mdash; a <em>symbol</em> naming a <em>method combination</em> <em>type</em>. </p><p><code>method-qualifiers</code>, <code>specialized-lambda-list</code>, <code>declarations</code>, <code>documentation</code>, <code>forms</code> &mdash; as per <code>defmethod</code>. </p><p><code>new-generic</code> &mdash; the <em>generic function</em> <em>object</em>. </p><p><code>parameter-name</code> &mdash; a <em>symbol</em> that names a <em>required parameter</em> in the <em>lambda-list</em>. (If the <code>:argument-precedence-order</code> option is specified, each <em>required parameter</em> in the <em>lambda-list</em> must be used exactly once as a <em>parameter-name</em>.) </p><p>The macro <code>defgeneric</code> is used to define a <em>generic function</em> or to specify options and declarations that pertain to a <em>generic function</em> as a whole. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defgen.htm#defgeneric)", "define-modify-macro": "```commonlisp\ndefine-modify-macro name lambda-list function [documentation] => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>lambda-list</code> &mdash; a <em>define-modify-macro lambda list</em> </p><p><code>function</code> &mdash; a <em>symbol</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>define-modify-macro</code> defines a <em>macro</em> named <em>name</em> to <em>read</em> and <em>write</em> a <em>place</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defi_2.htm#define-modify-macro)", "define-condition": "```commonlisp\ndefine-condition name (parent-type*) ({slot-spec}*) option*\n => name\nslot-spec::= slot-name | (slot-name slot-option) \nslot-option::= [[{:reader symbol}* |  \n               {:writer function-name}* |  \n               {:accessor symbol}* |  \n               {:allocation allocation-type} |  \n               {:initarg symbol}* |  \n               {:initform form} |  \n               {:type type-specifier} ]] \noption::= [[(:default-initargs . initarg-list) |  \n          (:documentation string) |  \n          (:report report-name) ]] \nfunction-name::= {symbol | (setf symbol)} \nallocation-type::= :instance | :class \nreport-name::= string | symbol | lambda expression \n\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>parent-type</code> &mdash; a <em>symbol</em> naming a <em>condition</em> <em>type</em>. If no <em>parent-types</em> are supplied, the <em>parent-types</em> default to <code>(condition)</code>. </p><p><code>default-initargs</code> &mdash; a <em>list</em> of <em>keyword/value pairs</em>. </p><p><em>Slot-spec</em>  &mdash;  the <em>name</em> of a <em>slot</em> or a <em>list</em> consisting of the <em>slot-name</em> followed by zero or more <em>slot-options</em>. </p><p><em>Slot-name</em>  &mdash;  a slot name (a <em>symbol</em>), the <em>list</em> of a slot name, or the <em>list</em> of slot name/slot form pairs. </p><p><em>Option</em>  &mdash;  Any of the following: </p><p><code>define-condition</code> defines a new condition type called <em>name</em>, which is a <em>subtype</em> of  the <em>type</em> or <em>types</em> named by <em>parent-type</em>. Each <em>parent-type</em> argument specifies a direct <em>supertype</em> of the new <em>condition</em>. The new <em>condition</em> inherits <em>slots</em> and <em>methods</em> from each of its direct <em>supertypes</em>, and so on.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defi_5.htm#define-condition)", "define-setf-expander": "```commonlisp\ndefine-setf-expander access-fn lambda-list [[declaration* | documentation]] form*\n => access-fn\n```\n\n<p><code>access-fn</code> &mdash; a <em>symbol</em> that <em>names</em> a <em>function</em> or <em>macro</em>. </p><p><code>lambda-list</code>  &mdash;  <code>macro lambda list</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>define-setf-expander</code> specifies the means by which <code>setf</code> updates a <em>place</em> that is referenced by <em>access-fn</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defi_3.htm#define-setf-expander)", "define-method-combination": "```commonlisp\ndefine-method-combination name [[short-form-option]]\n => name\ndefine-method-combination name lambda-list (method-group-specifier*) [(:arguments . args-lambda-list)] [(:generic-function generic-function-symbol)] [[declaration* | documentation]] form*\n => name\nshort-form-option::= :documentation documentation |  \n                     :identity-with-one-argument identity-with-one-argument | \n                     :operator operator \nmethod-group-specifier::= (name {qualifier-pattern+ | predicate} [[long-form-option]]) \nlong-form-option::= :description description | \n                    :order order | \n                    :required required-p \n\n```\n\n<p><code>args-lambda-list</code> &mdash; a <em>define-method-combination arguments lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>description</code> &mdash; a <em>format control</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em> that must compute and return the <em>form</em> that specifies how the <em>methods</em> are combined, that is, the <em>effective method</em>. </p><p><code>generic-function-symbol</code> &mdash; a <em>symbol</em>. </p><p><code>identity-with-one-argument</code> &mdash; a <em>generalized boolean</em>. </p><p><code>lambda-list</code> &mdash; <em>ordinary lambda list</em>. </p><p><code>name</code> &mdash; a <em>symbol</em>. Non-<em>keyword</em>, <em>non-nil</em> <em>symbols</em> are usually used. </p><p><code>operator</code> &mdash; an <em>operator</em>. <em>Name</em> and <em>operator</em> are often the <em>same</em> <em>symbol</em>. This is the default, but it is not required. </p><p><code>order</code> &mdash; <code>:most-specific-first</code> or <code>:most-specific-last</code>; evaluated. </p><p><code>predicate</code> &mdash; a <em>symbol</em> that names a <em>function</em> of one argument that returns a <em>generalized boolean</em>. </p><p><code>qualifier-pattern</code> &mdash; a <em>list</em>, or the <em>symbol</em> <code>*</code>. </p><p><code>required-p</code> &mdash; a <em>generalized boolean</em>. </p><p>The macro <code>define-method-combination</code> is used to define new types of method combination. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defi_4.htm#define-method-combination)", "defmacro": "```commonlisp\ndefmacro name lambda-list [[declaration* | documentation]] form*\n => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. <em>lambda-list</em> &mdash; a <em>macro lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p>Defines <em>name</em> as a <em>macro</em> by associating a <em>macro function</em> with that <em>name</em> in the global environment.  The <em>macro function</em> is defined in the same <em>lexical environment</em> in which the <code>defmacro</code> <em>form</em> appears.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defmac.htm#defmacro)", "define-symbol-macro": "```commonlisp\ndefine-symbol-macro symbol expansion\n => symbol\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>expansion</code> &mdash; a <em>form</em>. </p><p>Provides a mechanism for globally affecting the <em>macro expansion</em> of the indicated <em>symbol</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defi_1.htm#define-symbol-macro)", "defpackage": "```commonlisp\ndefpackage defined-package-name [[option]] => package\noption::= (:nicknames nickname*)* |  \n          (:documentation string) |  \n          (:use package-name*)* |  \n          (:shadow {symbol-name}*)* |  \n          (:shadowing-import-from package-name {symbol-name}*)* |  \n          (:import-from package-name {symbol-name}*)* |  \n          (:export {symbol-name}*)* |  \n          (:intern {symbol-name}*)* |  \n          (:size integer) \n\n```\n\n<p><code>defined-package-name</code> &mdash; a <em>string designator</em>. </p><p> <code>package-name</code> &mdash; a <em>package designator</em>.  </p><p><code>nickname</code> &mdash; a <em>string designator</em>. </p><p><code>symbol-name</code> &mdash; a <em>string designator</em>. </p><p><code>package</code> &mdash; the <em>package</em> named <em>package-name</em>. </p><p><code>defpackage</code> creates a <em>package</em> as specified and returns the <em>package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defpkg.htm#defpackage)", "defparameter": "```commonlisp\ndefparameter name initial-value [documentation]  => name\ndefvar name [initial-value [documentation]] => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>; not evaluated. </p><p><code>initial-value</code> &mdash; a <em>form</em>; for <code>defparameter</code>, it is always <em>evaluated</em>, but for <code>defvar</code> it is <em>evaluated</em> only if <em>name</em> is not already <em>bound</em>. </p><p> <code>documentation</code> &mdash; a <em>string</em>; not evaluated.  </p><p><code>defparameter</code> and <code>defvar</code> <em>establish</em> <em>name</em> as a <em>dynamic variable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defpar.htm#defparameter)", "defmethod": "```commonlisp\ndefmethod function-name {method-qualifier}* specialized-lambda-list [[declaration* | documentation]] form*\n => new-method\nfunction-name::= {symbol | (setf symbol)} \nmethod-qualifier::= non-list \nspecialized-lambda-list::= ({var | (var parameter-specializer-name)}* \n                            [&optional {var | (var [initform [supplied-p-parameter] ])}*] \n                            [&rest var] \n                            [&key{var | ({var | (keywordvar)} [initform [supplied-p-parameter] ])}*\n                                 [&allow-other-keys] ] \n                            [&aux {var | (var [initform] )}*] ) \nparameter-specializer-name::= symbol | (eql eql-specializer-form)\n\n```\n\n<p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>eql-specializer-form</code> &mdash; a <em>form</em>. </p><p><code>Form</code> &mdash; a <em>form</em>. </p><p><code>Initform</code> &mdash; a <em>form</em>. </p><p><code>Supplied-p-parameter</code> &mdash; variable name. </p><p><code>new-method</code> &mdash; the new <em>method</em> <em>object</em>. </p><p>The macro <code>defmethod</code> defines a <em>method</em> on a <em>generic function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defmet.htm#defmethod)", "defsetf": "```commonlisp\nThe ``short form'': \ndefsetf access-fn update-fn [documentation]\n => access-fn\nThe ``long form'': \ndefsetf access-fn lambda-list (store-variable*) [[declaration* | documentation]] form*\n => access-fn\n```\n\n<p><code>access-fn</code> &mdash; a <em>symbol</em> which names a <em>function</em> or a <em>macro</em>. </p><p><code>update-fn</code> &mdash; a <em>symbol</em> naming a <em>function</em> or <em>macro</em>. </p><p><code>lambda-list</code> &mdash; a <em>defsetf lambda list</em>. </p><p><code>store-variable</code> &mdash; a <em>symbol</em> (a <em>variable</em> <em>name</em>). </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>defsetf</code> defines how to <code>setf</code> a <em>place</em> of the form <code>(</code><em>access-fn</em><code> ...)</code> for relatively simple cases. (See <code>define-setf-expander</code> for more general access to this facility.)  It must be the case that the <em>function</em> or <em>macro</em> named by <em>access-fn</em> evaluates all of its arguments.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defset.htm#defsetf)", "deftype": "```commonlisp\ndeftype name lambda-list [[declaration* | documentation]] form* => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>lambda-list</code> &mdash; a <em>deftype lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>deftype</code> defines a <em>derived type specifier</em> named <em>name</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_deftp.htm#deftype)", "defun": "```commonlisp\ndefun function-name lambda-list [[declaration* | documentation]] form*\n => function-name\n```\n\n<p><code>function-name</code> &mdash; a <em>function name</em>. </p><p><code>lambda-list</code> &mdash; an <em>ordinary lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>block-name</code> &mdash; the <em>function block name</em> of the <em>function-name</em>. </p><p>Defines a new <em>function</em> named <em>function-name</em> in the <em>global environment</em>. The body of the <em>function</em> defined by <code>defun</code> consists of <em>forms</em>; they are executed as an <em>implicit progn</em> when the <em>function</em> is called. <code>defun</code> can be used to define a new <em>function</em>, to install a corrected version of an incorrect definition, to redefine an already-defined <em>function</em>, or to redefine a <em>macro</em> as a <em>function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defun.htm#defun)", "destructuring-bind": "```commonlisp\ndestructuring-bind lambda-list expression declaration* form*\n => result*\n```\n\n<p><code>lambda-list</code> &mdash; a <em>destructuring lambda list</em>. </p><p><code>expression</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>destructuring-bind</code> binds the variables specified in <em>lambda-list</em> to the corresponding values in the tree structure resulting from the evaluation of <em>expression</em>; then <code>destructuring-bind</code> evaluates <em>forms</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_destru.htm#destructuring-bind)", "do-external-symbols": "```commonlisp\ndo-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-external-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-all-symbols (var [result-form]) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>; not evaluated. </p><p> <code>package</code> &mdash; a <em>package designator</em>; evaluated.  The default in <code>do-symbols</code> and <code>do-external-symbols</code> is the <em>current package</em>. </p><p><code>result-form</code> &mdash; a <em>form</em>; evaluated as described below. The default is <code>nil</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>result-form</em> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p><code>do-symbols</code>, <code>do-external-symbols</code>, and <code>do-all-symbols</code> iterate over the <em>symbols</em> of <em>packages</em>. For each <em>symbol</em> in the set of <em>packages</em> chosen, the <em>var</em> is bound to the <em>symbol</em>, and the <em>statements</em> in the body are executed. When all the <em>symbols</em> have been processed, <em>result-form</em> is evaluated and returned as the value of the macro. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_do_sym.htm#do-external-symbols)", "defvar": "```commonlisp\ndefparameter name initial-value [documentation]  => name\ndefvar name [initial-value [documentation]] => name\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>; not evaluated. </p><p><code>initial-value</code> &mdash; a <em>form</em>; for <code>defparameter</code>, it is always <em>evaluated</em>, but for <code>defvar</code> it is <em>evaluated</em> only if <em>name</em> is not already <em>bound</em>. </p><p> <code>documentation</code> &mdash; a <em>string</em>; not evaluated.  </p><p><code>defparameter</code> and <code>defvar</code> <em>establish</em> <em>name</em> as a <em>dynamic variable</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defpar.htm#defvar)", "do*": "```commonlisp\ndo ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*\n => result*\ndo* ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>step-form</code> &mdash; a <em>form</em>. </p><p><code>end-test-form</code> &mdash; a <em>form</em>. </p><p><code>result-forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; if a <code>return</code> or <code>return-from</code> form is executed, the <em>values</em> passed from that <em>form</em>; otherwise, the <em>values</em> returned by the <em>result-forms</em>. </p><p><code>do</code> iterates over a group of <em>statements</em> while a test condition holds. <code>do</code> accepts an arbitrary number of iteration <em>vars</em> which are bound within the iteration and stepped in parallel. An initial value may be supplied for each iteration variable by use of an <em>init-form</em>. <em>Step-forms</em> may be used to specify how the <em>vars</em> should be updated on succeeding iterations through the loop. <em>Step-forms</em> may be used both to generate successive values or to accumulate results. If the <em>end-test-form</em> condition is met prior to an execution of the body, the iteration terminates. <em>Tags</em> label <em>statements</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_do_do.htm#doST)", "dolist": "```commonlisp\ndolist (var list-form [result-form]) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>list-form</code> &mdash; a <em>form</em>. </p><p><code>result-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; if a <code>return</code> or <code>return-from</code> form is executed, the <em>values</em> passed from that <em>form</em>; otherwise, the <em>values</em> returned by the <em>result-form</em> or <code>nil</code> if there is no <em>result-form</em>. </p><p><code>dolist</code> iterates over the elements of a <em>list</em>. The body of <code>dolist</code> is like a <code>tagbody</code>. It consists of a series of <em>tags</em> and <em>statements</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_dolist.htm#dolist)", "defstruct": "```commonlisp\ndefstruct name-and-options [documentation] {slot-description}*\n => structure-name\nname-and-options::= structure-name | (structure-name [[options]]) \noptions::= conc-name-option | \n           {constructor-option}* | \n           copier-option | \n           include-option | \n           initial-offset-option | \n           named-option | \n           predicate-option | \n           printer-option | \n           type-option \nconc-name-option::= :conc-name | (:conc-name) | (:conc-name conc-name) \nconstructor-option::= :constructor | \n                      (:constructor) | \n                      (:constructor constructor-name) | \n                      (:constructor constructor-name constructor-arglist) \ncopier-option::= :copier | (:copier) | (:copier copier-name) \npredicate-option::= :predicate | (:predicate) | (:predicate predicate-name) \ninclude-option::= (:include included-structure-name {slot-description}*) \nprinter-option::= print-object-option | print-function-option \nprint-object-option::= (:print-object printer-name) | (:print-object) \nprint-function-option::= (:print-function printer-name) | (:print-function) \ntype-option::= (:type type) \nnamed-option::= :named \ninitial-offset-option::= (:initial-offset initial-offset) \nslot-description::= slot-name |  \n                    (slot-name [slot-initform [[slot-option]]]) \nslot-option::= :type slot-type |  \n               :read-only slot-read-only-p \n\n```\n\n<p><code>conc-name</code> &mdash; a <em>string designator</em>. </p><p><code>constructor-arglist</code> &mdash; a <em>boa lambda list</em>. </p><p><code>constructor-name</code> &mdash; a <em>symbol</em>. </p><p><code>copier-name</code> &mdash; a <em>symbol</em>. </p><p><code>included-structure-name</code> &mdash; an already-defined <em>structure name</em>.  Note that a <em>derived type</em> is not permissible, even if it would expand into a <em>structure name</em>.  </p><p><code>initial-offset</code> &mdash; a non-negative <em>integer</em>. </p><p><code>predicate-name</code> &mdash; a <em>symbol</em>. </p><p> <code>printer-name</code> &mdash; a <em>function name</em> or a <em>lambda expression</em>.  </p><p><code>slot-name</code> &mdash; a <em>symbol</em>. </p><p><code>slot-initform</code> &mdash; a <em>form</em>. </p><p><code>slot-read-only-p</code> &mdash; a <em>generalized boolean</em>. </p><p><code>structure-name</code> &mdash; a <em>symbol</em>. </p><p><code>type</code> &mdash; one of the <em>type specifiers</em> <code>list</code>, <code>vector</code>, or <code>(vector </code><em>size</em><code>)</code>, or some other <em>type specifier</em> defined by the <em>implementation</em> to be appropriate. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>defstruct</code> defines a structured <em>type</em>, named <em>structure-type</em>, with named slots as specified by the <em>slot-options</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_defstr.htm#defstruct)", "do-all-symbols": "```commonlisp\ndo-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-external-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-all-symbols (var [result-form]) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>; not evaluated. </p><p> <code>package</code> &mdash; a <em>package designator</em>; evaluated.  The default in <code>do-symbols</code> and <code>do-external-symbols</code> is the <em>current package</em>. </p><p><code>result-form</code> &mdash; a <em>form</em>; evaluated as described below. The default is <code>nil</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>result-form</em> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p><code>do-symbols</code>, <code>do-external-symbols</code>, and <code>do-all-symbols</code> iterate over the <em>symbols</em> of <em>packages</em>. For each <em>symbol</em> in the set of <em>packages</em> chosen, the <em>var</em> is bound to the <em>symbol</em>, and the <em>statements</em> in the body are executed. When all the <em>symbols</em> have been processed, <em>result-form</em> is evaluated and returned as the value of the macro. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_do_sym.htm#do-all-symbols)", "do": "```commonlisp\ndo ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*\n => result*\ndo* ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>step-form</code> &mdash; a <em>form</em>. </p><p><code>end-test-form</code> &mdash; a <em>form</em>. </p><p><code>result-forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; if a <code>return</code> or <code>return-from</code> form is executed, the <em>values</em> passed from that <em>form</em>; otherwise, the <em>values</em> returned by the <em>result-forms</em>. </p><p><code>do</code> iterates over a group of <em>statements</em> while a test condition holds. <code>do</code> accepts an arbitrary number of iteration <em>vars</em> which are bound within the iteration and stepped in parallel. An initial value may be supplied for each iteration variable by use of an <em>init-form</em>. <em>Step-forms</em> may be used to specify how the <em>vars</em> should be updated on succeeding iterations through the loop. <em>Step-forms</em> may be used both to generate successive values or to accumulate results. If the <em>end-test-form</em> condition is met prior to an execution of the body, the iteration terminates. <em>Tags</em> label <em>statements</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_do_do.htm#do)", "ecase": "```commonlisp\ncase keyform {normal-clause}* [otherwise-clause] => result*\nccase keyplace {normal-clause}* => result*\necase keyform {normal-clause}* => result*\nnormal-clause::= (keys form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>keys</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>keys</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>objects</em>. In the case of <code>case</code>, the <em>symbols</em> <code>t</code> and <code>otherwise</code> may not be used as the <em>keys</em> <em>designator</em>. To refer to these <em>symbols</em> by themselves as <em>keys</em>, the designators <code>(t)</code> and <code>(otherwise)</code>, respectively, must be used instead. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its identity. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_case_.htm#ecase)", "etypecase": "```commonlisp\ntypecase keyform {normal-clause}* [otherwise-clause] => result*\nctypecase keyplace {normal-clause}* => result*\netypecase keyform {normal-clause}* => result*\nnormal-clause::= (type form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>types</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>type</code> &mdash; a <em>type specifier</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its <em>type</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_tpcase.htm#etypecase)", "do-symbols": "```commonlisp\ndo-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-external-symbols (var [package [result-form]]) declaration* {tag | statement}*\n => result*\ndo-all-symbols (var [result-form]) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>; not evaluated. </p><p> <code>package</code> &mdash; a <em>package designator</em>; evaluated.  The default in <code>do-symbols</code> and <code>do-external-symbols</code> is the <em>current package</em>. </p><p><code>result-form</code> &mdash; a <em>form</em>; evaluated as described below. The default is <code>nil</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>result-form</em> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p><code>do-symbols</code>, <code>do-external-symbols</code>, and <code>do-all-symbols</code> iterate over the <em>symbols</em> of <em>packages</em>. For each <em>symbol</em> in the set of <em>packages</em> chosen, the <em>var</em> is bound to the <em>symbol</em>, and the <em>statements</em> in the body are executed. When all the <em>symbols</em> have been processed, <em>result-form</em> is evaluated and returned as the value of the macro. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_do_sym.htm#do-symbols)", "dotimes": "```commonlisp\ndotimes (var count-form [result-form]) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>count-form</code> &mdash; a <em>form</em>. </p><p><code>result-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; if a <code>return</code> or <code>return-from</code> form is executed, the <em>values</em> passed from that <em>form</em>; otherwise, the <em>values</em> returned by the <em>result-form</em> or <code>nil</code> if there is no <em>result-form</em>. </p><p><code>dotimes</code> iterates over a series of <em>integers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_dotime.htm#dotimes)", "formatter": "```commonlisp\nformatter control-string => function\n```\n\n<p><code>control-string</code> &mdash; a <em>format string</em>; not evaluated. </p><p><code>function</code> &mdash; a <em>function</em>. </p><p>Returns a <em>function</em> which has behavior equivalent to: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_format.htm#formatter)", "handler-bind": "```commonlisp\nhandler-bind ({binding}*) form* => result*\nbinding::= (type handler) \n\n```\n\n<p><code>type</code> &mdash; a <em>type specifier</em>. </p><p><code>handler</code> &mdash; a <em>form</em>; evaluated to produce a <em>handler-function</em>. </p><p><code>handler-function</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Executes <em>forms</em> in a <em>dynamic environment</em> where the indicated <em>handler</em> <em>bindings</em> are in effect. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_handle.htm#handler-bind)", "in-package": "```commonlisp\nin-package name => package\n```\n\n<p><code>name</code> &mdash; a <em>string designator</em>; not evaluated. </p><p><code>package</code> &mdash; the <em>package</em> named by <em>name</em>. </p><p>Causes the the <code>package</code> named by <code>name</code> to become the <code>current package</code> &mdash; that is, the <em>value</em> of <code>*package*</code>. If no such <em>package</em> already exists, an error of <em>type</em> <code>package-error</code> is signaled. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_in_pkg.htm#in-package)", "incf": "```commonlisp\nincf place [delta-form] => new-value\ndecf place [delta-form] => new-value\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>delta-form</code> &mdash; a <em>form</em>; evaluated to produce a <em>delta</em>. The default is <code>1</code>. </p><p><code>delta</code> &mdash; a <em>number</em>. </p><p><code>new-value</code> &mdash; a <em>number</em>. </p><p><code>incf</code> and <code>decf</code> are used for incrementing and decrementing the <em>value</em> of <em>place</em>, respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_incf_.htm#incf)", "handler-case": "```commonlisp\nhandler-case expression [[{error-clause}* | no-error-clause]] => result*\nclause::= error-clause | no-error-clause \nerror-clause::= (typespec ([var]) declaration* form*) \nno-error-clause::= (:no-error lambda-list declaration* form*) \n\n```\n\n<p><code>expression</code> &mdash; a <em>form</em>. </p><p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>lambda-list</code> &mdash; an <em>ordinary lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; In the normal situation, the values returned are those that result from the evaluation of <em>expression</em>; in the exceptional situation when control is transferred to a <em>clause</em>, the value of the last <em>form</em> in that <em>clause</em> is returned. </p><p><code>handler-case</code> executes <em>expression</em> in a <em>dynamic environment</em> where various handlers are active. Each <em>error-clause</em> specifies how to handle a <em>condition</em> matching the indicated <em>typespec</em>. A <em>no-error-clause</em> allows the specification of a particular action if control returns normally. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_hand_1.htm#handler-case)", "multiple-value-bind": "```commonlisp\nmultiple-value-bind (var*) values-form declaration* form*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em> naming a variable; not evaluated. </p><p><code>values-form</code> &mdash; a <em>form</em>; evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Creates new variable <em>bindings</em> for the <em>vars</em> and executes a series of <em>forms</em> that use these <em>bindings</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_multip.htm#multiple-value-bind)", "loop": "```commonlisp\nThe ``simple'' loop form: \nloop compound-form* => result*\nThe ``extended'' loop form: \nloop [name-clause] {variable-clause}* {main-clause}* => result*\nname-clause::= named name \nvariable-clause::= with-clause | initial-final | for-as-clause \nwith-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* \nmain-clause::= unconditional | accumulation | conditional | termination-test | initial-final \ninitial-final::= initially compound-form+ | finally compound-form+ \nunconditional::= {do | doing} compound-form+ | return {form | it} \naccumulation::= list-accumulation | numeric-accumulation \nlist-accumulation::= {collect | collecting | append | appending | nconc | nconcing} {form | it}  \n                     [into simple-var] \nnumeric-accumulation::= {count | counting | sum | summing | } \n                         maximize | maximizing | minimize | minimizing {form | it} \n                        [into simple-var] [type-spec] \nconditional::= {if | when | unless} form selectable-clause {and selectable-clause}*  \n               [else selectable-clause {and selectable-clause}*]  \n               [end] \nselectable-clause::= unconditional | accumulation | conditional \ntermination-test::= while form | until form | repeat form | always form | never form | thereis form \nfor-as-clause::= {for | as} for-as-subclause {and for-as-subclause}* \nfor-as-subclause::= for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then | \n                    for-as-across | for-as-hash | for-as-package \nfor-as-arithmetic::= var [type-spec] for-as-arithmetic-subclause \nfor-as-arithmetic-subclause::= arithmetic-up | arithmetic-downto | arithmetic-downfrom \narithmetic-up::= [[{from | upfrom} form1 |   {to | upto | below} form2 |   by form3]]+ \narithmetic-downto::= [[{{from form1}}1  |   {{{downto | above} form2}}1  |   by form3]] \narithmetic-downfrom::= [[{{downfrom form1}}1  |   {to | downto | above} form2 |   by form3]] \nfor-as-in-list::= var [type-spec] in form1 [by step-fun] \nfor-as-on-list::= var [type-spec] on form1 [by step-fun] \nfor-as-equals-then::= var [type-spec] = form1 [then form2] \nfor-as-across::= var [type-spec] across vector \nfor-as-hash::= var [type-spec] being {each | the}  \n               {{hash-key | hash-keys} {in | of} hash-table  \n                [using (hash-value other-var)] |  \n                {hash-value | hash-values} {in | of} hash-table  \n                [using (hash-key other-var)]} \nfor-as-package::= var [type-spec] being {each | the}  \n                  {symbol | symbols | \n                   present-symbol | present-symbols | \n                   external-symbol | external-symbols} \n                  [{in | of} package] \ntype-spec::= simple-type-spec | destructured-type-spec \nsimple-type-spec::= fixnum | float | t | nil \ndestructured-type-spec::= of-type d-type-spec \nd-type-spec::= type-specifier | (d-type-spec . d-type-spec) \nvar::= d-var-spec \nvar1::= d-var-spec \nvar2::= d-var-spec \nother-var::= d-var-spec \nd-var-spec::= simple-var | nil | (d-var-spec . d-var-spec) \n\n```\n\n<p><code>compound-form</code> &mdash; a <em>compound form</em>. </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>simple-var</code> &mdash; a <em>symbol</em> (a <em>variable</em> name). </p><p><code>form</code>, <code>form1</code>, <code>form2</code>, <code>form3</code> &mdash; a <em>form</em>. </p><p> <code>step-fun</code> &mdash; a <em>form</em> that evaluates to a <em>function</em> of one <em>argument</em>.  </p><p><code>vector</code> &mdash; a <em>form</em> that evaluates to a <em>vector</em>. </p><p><code>hash-table</code> &mdash; a <em>form</em> that evaluates to a <em>hash table</em>. </p><p><code>package</code> &mdash; a <em>form</em> that evaluates to a <em>package designator</em>. </p><p><code>type-specifier</code> &mdash; a <em>type specifier</em>. This might be either an <em>atomic type specifier</em> or a <em>compound type specifier</em>, which introduces some additional complications to proper parsing in the face of destructuring; for further information, see Section 6.1.1.7 (Destructuring). </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>For details, see Section 6.1 (The LOOP Facility). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_loop.htm#loop)", "ignore-errors": "```commonlisp\nignore-errors form* => result*\n```\n\n<p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; In the normal situation, the <em>values</em> of the <em>forms</em> are returned; in the exceptional situation, two values are returned: <code>nil</code> and the <em>condition</em>. </p><p><code>ignore-errors</code> is used to prevent <em>conditions</em> of <em>type</em> <code>error</code> from causing entry into the debugger. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_ignore.htm#ignore-errors)", "nth-value": "```commonlisp\nnth-value n form => object\n```\n\n<p><code>n</code> &mdash; a non-negative <em>integer</em>; evaluated. </p><p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p>Evaluates <em>n</em> and then <em>form</em>, returning as its only value the <em>n</em>th value <em>yielded</em> by <em>form</em>, or <code>nil</code> if <em>n</em> is greater than or equal to the number of <em>values</em> returned by <em>form</em>. (The first returned value is numbered <code>0</code>.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_nth_va.htm#nth-value)", "otherwise": "```commonlisp\ncase keyform {normal-clause}* [otherwise-clause] => result*\nccase keyplace {normal-clause}* => result*\necase keyform {normal-clause}* => result*\nnormal-clause::= (keys form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>keys</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>keys</code> &mdash; a <em>designator</em> for a <em>list</em> of <em>objects</em>. In the case of <code>case</code>, the <em>symbols</em> <code>t</code> and <code>otherwise</code> may not be used as the <em>keys</em> <em>designator</em>. To refer to these <em>symbols</em> by themselves as <em>keys</em>, the designators <code>(t)</code> and <code>(otherwise)</code>, respectively, must be used instead. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its identity. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_case_.htm#otherwise)", "multiple-value-setq": "```commonlisp\nmultiple-value-setq vars form => result\n```\n\n<p><code>vars</code> &mdash; a <em>list</em> of <em>symbols</em> that are either <em>variable</em> <em>names</em> or <em>names</em> of <em>symbol macros</em>. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>result</code> &mdash; The <em>primary value</em> returned by the <em>form</em>. </p><p><code>multiple-value-setq</code> assigns values to <em>vars</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_mult_2.htm#multiple-value-setq)", "multiple-value-list": "```commonlisp\nmultiple-value-list form => list\n```\n\n<p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>list</code> &mdash; a <em>list</em> of the <em>values</em> returned by <em>form</em>. </p><p><code>multiple-value-list</code> evaluates <em>form</em> and creates a <em>list</em> of the <em>multiple values</em>[2] it returns. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_mult_1.htm#multiple-value-list)", "pop": "```commonlisp\npop place => element\n```\n\n<p> <code>place</code> &mdash; a <em>place</em>, the <em>value</em> of which is a <em>list</em> (possibly, but necessarily, a <em>dotted list</em> or <em>circular list</em>).  </p><p><code>element</code> &mdash; an <em>object</em> (the <em>car</em> of the contents of <em>place</em>). </p><p><code>pop</code> <em>reads</em> the <em>value</em> of <em>place</em>, remembers the <em>car</em> of the <em>list</em> which was retrieved, <em>writes</em> the <em>cdr</em> of the <em>list</em> back into the <em>place</em>, and finally <em>yields</em> the <em>car</em> of the originally retrieved <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_pop.htm#pop)", "print-unreadable-object": "```commonlisp\nprint-unreadable-object (object stream &key type identity) form* => nil\n```\n\n<p><code>object</code> &mdash; an <em>object</em>; evaluated. </p><p><code>stream</code> &mdash; a <em>stream designator</em>; evaluated. </p><p><code>type</code> &mdash; a <em>generalized boolean</em>; evaluated. </p><p><code>identity</code> &mdash; a <em>generalized boolean</em>; evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p>Outputs a printed representation of <em>object</em> on <em>stream</em>, beginning with ``<code>#&lt;</code>'' and ending with ``<code>&gt;</code>''. Everything output to <em>stream</em> by the body <em>forms</em> is enclosed in the the angle brackets. If <em>type</em> is <em>true</em>, the output from <em>forms</em> is preceded by a brief description of the <em>object</em>'s <em>type</em> and a space character. If <em>identity</em> is <em>true</em>, the output from <em>forms</em> is followed by a space character and a representation of the <em>object</em>'s identity, typically a storage address. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_pr_unr.htm#print-unreadable-object)", "pprint-logical-block": "```commonlisp\npprint-logical-block (stream-symbol object &key prefix per-line-prefix suffix) declaration* form*\n => nil\n```\n\n<p><code>stream-symbol</code> &mdash; a <em>stream variable designator</em>. </p><p><code>object</code> &mdash; an <em>object</em>; evaluated. </p><p><code>:prefix</code> &mdash; a <code>string</code>; evaluated. Complicated defaulting behavior; see below. </p><p><code>:per-line-prefix</code> &mdash; a <code>string</code>; evaluated. Complicated defaulting behavior; see below. </p><p><code>:suffix</code> &mdash; a <code>string</code>; evaluated. The default is the <code>null</code> <code>string</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p>Causes printing to be grouped into a logical block. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_ppr_lo.htm#pprint-logical-block)", "prog*": "```commonlisp\nprog ({var | (var [init-form])}*) declaration* {tag | statement}*\n => result*\nprog* ({var | (var [init-form])}*) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; variable name. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; <code>nil</code> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p>Three distinct operations are performed by <code>prog</code> and <code>prog*</code>: they bind local variables, they permit use of the <code>return</code> statement, and they permit use of the <code>go</code> statement. A typical <code>prog</code> looks like this: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_prog_.htm#progST)", "prog": "```commonlisp\nprog ({var | (var [init-form])}*) declaration* {tag | statement}*\n => result*\nprog* ({var | (var [init-form])}*) declaration* {tag | statement}*\n => result*\n```\n\n<p><code>var</code> &mdash; variable name. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p><code>results</code> &mdash; <code>nil</code> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p>Three distinct operations are performed by <code>prog</code> and <code>prog*</code>: they bind local variables, they permit use of the <code>return</code> statement, and they permit use of the <code>go</code> statement. A typical <code>prog</code> looks like this: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_prog_.htm#prog)", "prog1": "```commonlisp\nprog1 first-form form* => result-1\nprog2 first-form second-form form* => result-2\n```\n\n<p><code>first-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>second-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>; evaluated as described below. </p><p><code>result-1</code> &mdash; the <em>primary value</em> resulting from the <em>evaluation</em> of <em>first-form</em>. </p><p><code>result-2</code> &mdash; the <em>primary value</em> resulting from the <em>evaluation</em> of <em>second-form</em>. </p><p><code>prog1</code> <em>evaluates</em> <em>first-form</em> and then <em>forms</em>, <em>yielding</em> as its only <em>value</em> the <em>primary value</em> <em>yielded</em> by <em>first-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_prog1c.htm#prog1)", "psetf": "```commonlisp\nsetf {pair}* => result*\npsetf {pair}* => nil\npair::= place newvalue \n\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>newvalue</code> &mdash; a <em>form</em>. </p><p> <code>results</code> &mdash; the <em>multiple values</em>[2] returned by the storing form for the last <em>place</em>, or <code>nil</code> if there are no <em>pairs</em>.  </p><p><code>setf</code> changes the <em>value</em> of <em>place</em> to be <em>newvalue</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_setf_.htm#psetf)", "prog2": "```commonlisp\nprog1 first-form form* => result-1\nprog2 first-form second-form form* => result-2\n```\n\n<p><code>first-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>second-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>; evaluated as described below. </p><p><code>result-1</code> &mdash; the <em>primary value</em> resulting from the <em>evaluation</em> of <em>first-form</em>. </p><p><code>result-2</code> &mdash; the <em>primary value</em> resulting from the <em>evaluation</em> of <em>second-form</em>. </p><p><code>prog1</code> <em>evaluates</em> <em>first-form</em> and then <em>forms</em>, <em>yielding</em> as its only <em>value</em> the <em>primary value</em> <em>yielded</em> by <em>first-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_prog1c.htm#prog2)", "psetq": "```commonlisp\npsetq {pair}* => nil\npair::= var form \n\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em> naming a <em>variable</em> other than a <em>constant variable</em>. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p>Assigns values to <em>variables</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_psetq.htm#psetq)", "push": "```commonlisp\npush item place => new-place-value\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p> <code>place</code> &mdash; a <em>place</em>, the <em>value</em> of which may be any <em>object</em>.  </p><p><code>new-place-value</code> &mdash; a <em>list</em> (the new <em>value</em> of <em>place</em>). </p><p><code>push</code> prepends <em>item</em> to the <em>list</em> that is stored in <em>place</em>, stores the resulting <em>list</em> in <em>place</em>, and returns the <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_push.htm#push)", "pushnew": "```commonlisp\npushnew item place &key key test test-not\n => new-place-value\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>place</code> &mdash; a <em>place</em>, the <em>value</em> of which is a <em>proper list</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>new-place-value</code> &mdash; a <em>list</em> (the new <em>value</em> of <em>place</em>). </p><p><code>pushnew</code> tests whether <em>item</em> is the same as any existing element of the <em>list</em> stored in <em>place</em>. If <em>item</em> is not, it is prepended to the <em>list</em>, and the new <em>list</em> is stored in <em>place</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_pshnew.htm#pushnew)", "remf": "```commonlisp\nremf place indicator => generalized-boolean\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>indicator</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p><code>remf</code> removes from the <em>property list</em> stored in <em>place</em> a <em>property</em>[1] with a <em>property indicator</em> <em>identical</em> to <em>indicator</em>.  If there are multiple <em>properties</em>[1] with the <em>identical</em> key, <code>remf</code> only removes the first such <em>property</em>.  <code>remf</code> returns <em>false</em> if no such <em>property</em> was found, or <em>true</em> if a property was found. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_remf.htm#remf)", "restart-bind": "```commonlisp\nrestart-bind ({(name function {key-val-pair}*)}) form*\n => result*\nkey-val-pair::= :interactive-function interactive-function |  \n                :report-function report-function |  \n                :test-function test-function \n\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>; not evaluated. </p><p><code>function</code> &mdash; a <em>form</em>; evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>interactive-function</code> &mdash; a <em>form</em>; evaluated. </p><p><code>report-function</code> &mdash; a <em>form</em>; evaluated. </p><p><code>test-function</code> &mdash; a <em>form</em>; evaluated. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>restart-bind</code> executes the body of <em>forms</em> in a <em>dynamic environment</em> where <em>restarts</em> with the given <em>names</em> are in effect. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_bi.htm#restart-bind)", "rotatef": "```commonlisp\nrotatef place* => nil\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>rotatef</code> modifies the values of each <em>place</em> by rotating values from one <em>place</em> into another. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_rotate.htm#rotatef)", "restart-case": "```commonlisp\nrestart-case restartable-form {clause} => result*\nclause::= (case-name lambda-list  \n           [[:interactive interactive-expression | :report report-expression | :test test-expression]]  \n           declaration* form*) \n\n```\n\n<p><code>restartable-form</code> &mdash; a <em>form</em>. </p><p><code>case-name</code> &mdash; a <em>symbol</em> or <code>nil</code>. </p><p><code>lambda-list</code> &mdash; an <em>ordinary lambda list</em>. </p><p><code>interactive-expression</code> &mdash; a <em>symbol</em> or a <em>lambda expression</em>. </p><p><code>report-expression</code> &mdash; a <em>string</em>, a <em>symbol</em>, or a <em>lambda expression</em>. </p><p><code>test-expression</code> &mdash; a <em>symbol</em> or a <em>lambda expression</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> resulting from the <em>evaluation</em> of <em>restartable-form</em>, or the <em>values</em> returned by the last <em>form</em> executed in a chosen <em>clause</em>, or <code>nil</code>. </p><p><code>restart-case</code> evaluates <em>restartable-form</em> in a <em>dynamic environment</em> where the clauses have special meanings as points to which control may be transferred. If <em>restartable-form</em> finishes executing and returns any values, all values returned are returned by <code>restart-case</code> and processing has completed. While <em>restartable-form</em> is executing, any code may transfer control to one of the clauses (see <code>invoke-restart</code>). If a transfer occurs, the forms in the body of that clause is evaluated and any values returned by the last such form are returned by <code>restart-case</code>. In this case, the dynamic state is unwound appropriately (so that the restarts established around the <em>restartable-form</em> are no longer active) prior to execution of the clause. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_ca.htm#restart-case)", "return": "```commonlisp\nreturn [result] =>| \n```\n\n<p><code>result</code> &mdash; a <em>form</em>; evaluated. The default is <code>nil</code>. </p><p>Returns, as if by <code>return-from</code>, from the <em>block</em> named <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_return.htm#return)", "shiftf": "```commonlisp\nshiftf place+ newvalue => old-value-1\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>newvalue</code> &mdash; a <em>form</em>; evaluated. </p><p><code>old-value-1</code> &mdash; an <em>object</em> (the old <em>value</em> of the first <em>place</em>). </p><p><code>shiftf</code> modifies the values of each <em>place</em> by storing <em>newvalue</em> into the last <em>place</em>, and shifting the values of the second through the last <em>place</em> into the remaining <em>places</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_shiftf.htm#shiftf)", "step": "```commonlisp\nstep form => result*\n```\n\n<p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>form</em>. </p><p><code>step</code> implements a debugging paradigm wherein the programmer is allowed to <em>step</em> through the <em>evaluation</em> of a <em>form</em>. The specific nature of the interaction,  including which I/O streams are used and whether the stepping has lexical or dynamic scope,  is <em>implementation-defined</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_step.htm#step)", "time": "```commonlisp\ntime form => result*\n```\n\n<p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>form</em>. </p><p><code>time</code> evaluates <em>form</em> in the current <em>environment</em> (lexical and dynamic). A call to <code>time</code> can be compiled.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_time.htm#time)", "typecase": "```commonlisp\ntypecase keyform {normal-clause}* [otherwise-clause] => result*\nctypecase keyplace {normal-clause}* => result*\netypecase keyform {normal-clause}* => result*\nnormal-clause::= (type form*) \notherwise-clause::= ({otherwise | t} form*) \nclause::= normal-clause | otherwise-clause \n\n```\n\n<p><code>keyform</code> &mdash; a <em>form</em>; evaluated to produce a <em>test-key</em>. </p><p><code>keyplace</code> &mdash; a <em>form</em>; evaluated initially to produce a <em>test-key</em>. Possibly also used later as a <em>place</em> if no <em>types</em> match. </p><p><code>test-key</code> &mdash; an object produced by evaluating <em>keyform</em> or <em>keyplace</em>. </p><p><code>type</code> &mdash; a <em>type specifier</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em> in the matching <em>clause</em>. </p><p>These <em>macros</em> allow the conditional execution of a body of <em>forms</em> in a <em>clause</em> that is selected by matching the <em>test-key</em> on the basis of its <em>type</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_tpcase.htm#typecase)", "trace": "```commonlisp\ntrace function-name* => trace-result\nuntrace function-name* => untrace-result\n```\n\n<p> <code>function-name</code> &mdash; a <em>function name</em>.  </p><p><code>trace-result</code> &mdash; <em>implementation-dependent</em>, unless no <em>function-names</em> are supplied, in which case <em>trace-result</em> is a <em>list</em> of <em>function names</em>. </p><p><code>untrace-result</code> &mdash; <em>implementation-dependent</em>. </p><p><code>trace</code> and <code>untrace</code> control the invocation of the trace facility. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_tracec.htm#trace)", "unless": "```commonlisp\nwhen test-form form* => result*\nunless test-form form* => result*\n```\n\n<p><code>test-form</code> &mdash; a <em>form</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em> in a <code>when</code> <em>form</em> if the <em>test-form</em> <em>yields</em> <em>true</em> or in an <code>unless</code> <em>form</em> if the <em>test-form</em> <em>yields</em> <em>false</em>; otherwise <code>nil</code>. </p><p><code>when</code> and <code>unless</code> allow the execution of <em>forms</em> to be dependent on a single <em>test-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_when_.htm#unless)", "with-accessors": "```commonlisp\nwith-accessors (slot-entry*) instance-form declaration* form*\n => result*\nslot-entry::= (variable-name accessor-name) \n\n```\n\n<p><code>variable-name</code> &mdash; a <em>variable</em> <em>name</em>; not evaluated. </p><p><code>accessor-name</code> &mdash; a <em>function name</em>; not evaluated. </p><p><code>instance-form</code> &mdash; a <em>form</em>; evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Creates a lexical environment in which the slots specified by <em>slot-entry</em> are lexically available through their accessors as if they were variables. The macro <code>with-accessors</code> invokes the appropriate accessors to <em>access</em> the <em>slots</em> specified by <em>slot-entry</em>. Both <code>setf</code> and <code>setq</code> can be used to set the value of the <em>slot</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_acce.htm#with-accessors)", "untrace": "```commonlisp\ntrace function-name* => trace-result\nuntrace function-name* => untrace-result\n```\n\n<p> <code>function-name</code> &mdash; a <em>function name</em>.  </p><p><code>trace-result</code> &mdash; <em>implementation-dependent</em>, unless no <em>function-names</em> are supplied, in which case <em>trace-result</em> is a <em>list</em> of <em>function names</em>. </p><p><code>untrace-result</code> &mdash; <em>implementation-dependent</em>. </p><p><code>trace</code> and <code>untrace</code> control the invocation of the trace facility. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_tracec.htm#untrace)", "with-compilation-unit": "```commonlisp\nwith-compilation-unit ([[option]]) form* => result*\noption::= :override override \n\n```\n\n<p><code>override</code> &mdash; a <em>generalized boolean</em>; evaluated. The default is <code>nil</code>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Executes <em>forms</em> from left to right. Within the <em>dynamic environment</em> of <code>with-compilation-unit</code>, actions deferred by the compiler until the end of compilation will be deferred until the end of the outermost call to <code>with-compilation-unit</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_comp.htm#with-compilation-unit)", "when": "```commonlisp\nwhen test-form form* => result*\nunless test-form form* => result*\n```\n\n<p><code>test-form</code> &mdash; a <em>form</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em> in a <code>when</code> <em>form</em> if the <em>test-form</em> <em>yields</em> <em>true</em> or in an <code>unless</code> <em>form</em> if the <em>test-form</em> <em>yields</em> <em>false</em>; otherwise <code>nil</code>. </p><p><code>when</code> and <code>unless</code> allow the execution of <em>forms</em> to be dependent on a single <em>test-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_when_.htm#when)", "with-condition-restarts": "```commonlisp\nwith-condition-restarts condition-form restarts-form form*\n => result*\n```\n\n<p><code>condition-form</code> &mdash; a <em>form</em>; <em>evaluated</em> to produce a <em>condition</em>. </p><p><code>condition</code> &mdash; a <em>condition</em> <em>object</em> resulting from the <em>evaluation</em> of <em>condition-form</em>. </p><p><code>restart-form</code> &mdash; a <em>form</em>; <em>evaluated</em> to produce a <em>restart-list</em>. </p><p><code>restart-list</code> &mdash; a <em>list</em> of <em>restart</em> <em>objects</em> resulting from the <em>evaluation</em> of <em>restart-form</em>. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>; evaluated. </p><p><code>results</code> &mdash; the <em>values</em> returned by <em>forms</em>. </p><p>First, the <em>condition-form</em> and <em>restarts-form</em> are <em>evaluated</em> in normal left-to-right order; the <em>primary values</em> yielded by these <em>evaluations</em> are respectively called the <em>condition</em> and the <em>restart-list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_cnd_.htm#with-condition-restarts)", "with-open-file": "```commonlisp\nwith-open-file (stream filespec options*) declaration* form*\n => results\n```\n\n<p><code>stream</code>  &mdash;  a variable. </p><p> <code>filespec</code> &mdash; a <em>pathname designator</em>.  </p><p><code>options</code>  &mdash;  <code>forms</code>; evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>with-open-file</code> uses <code>open</code> to create a <em>file stream</em>  to <em>file</em> named by <em>filespec</em>. <em>Filespec</em> is the name of the file to be opened. <em>Options</em> are used as keyword arguments to <code>open</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_open.htm#with-open-file)", "with-hash-table-iterator": "```commonlisp\nwith-hash-table-iterator (name hash-table) declaration* form* => result*\n```\n\n<p><code>name</code> &mdash; a name suitable for the first argument to <code>macrolet</code>. </p><p><code>hash-table</code> &mdash; a <em>form</em>, evaluated once, that should produce a <em>hash table</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by <em>forms</em>. </p><p>Within the lexical scope of the body, <em>name</em> is defined via <code>macrolet</code> such that successive invocations of <code>(</code><em>name</em><code>)</code> return the items, one by one, from the <em>hash table</em> that is obtained by evaluating <em>hash-table</em> only once. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_hash.htm#with-hash-table-iterator)", "with-input-from-string": "```commonlisp\nwith-input-from-string (var string &key index start end) declaration* form*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>string</code> &mdash; a <em>form</em>; evaluated to produce a <em>string</em>. </p><p><code>index</code> &mdash; a <em>place</em>. </p><p> <code>start</code>, <code>end</code> &mdash; <em>bounding index designators</em> of <em>string</em>. The defaults for <em>start</em> and <em>end</em> are <code>0</code> and <code>nil</code>, respectively.  <em>declaration</em> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>result</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Creates an  <em>input</em> <em>string stream</em>,  provides an opportunity to perform operations on the <em>stream</em> (returning zero or more <em>values</em>), and then closes the <em>string stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_in_f.htm#with-input-from-string)", "with-output-to-string": "```commonlisp\nwith-output-to-string (var &optional string-form &key element-type) declaration* form*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>string-form</code> &mdash; a <em>form</em> or <code>nil</code>; if <em>non-nil</em>, evaluated to produce <em>string</em>. </p><p><code>string</code> &mdash; a <em>string</em> that has a <em>fill pointer</em>. </p><p> <code>element-type</code> &mdash; a <em>type specifier</em>; evaluated.  The default is <code>character</code>.   </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; If a <em>string-form</em> is not supplied or <code>nil</code>, a <em>string</em>; otherwise, the <em>values</em> returned by the <em>forms</em>. </p><p><code>with-output-to-string</code> creates a  character <em>output</em> <em>stream</em>, performs a series of operations that may send results to this <em>stream</em>, and then closes the <em>stream</em>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_out_.htm#with-output-to-string)", "with-open-stream": "```commonlisp\nwith-open-stream (var stream) declaration* form*\n => result*\n```\n\n<p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><code>stream</code> &mdash; a <em>form</em>; evaluated to produce a <em>stream</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>with-open-stream</code> performs a series of operations on <em>stream</em>, returns a value, and then closes the <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_op_1.htm#with-open-stream)", "with-simple-restart": "```commonlisp\nwith-simple-restart (name format-control format-argument*) form*\n => result*\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p> <code>format-control</code> &mdash; a <em>format control</em>.  </p><p><code>format-argument</code> &mdash; an <em>object</em> (i.e., a <em>format argument</em>). </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; in the normal situation, the <em>values</em> returned by the <em>forms</em>; in the exceptional situation where the <em>restart</em> named <em>name</em> is invoked, two values &mdash; <code>nil</code> and <code>t</code>. </p><p><code>with-simple-restart</code> establishes a restart. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_smp_.htm#with-simple-restart)", "with-package-iterator": "```commonlisp\nwith-package-iterator (name package-list-form &rest symbol-types) declaration* form*\n => result*\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>package-list-form</code> &mdash; a <em>form</em>; evaluated once to produce a <em>package-list</em>. </p><p><code>package-list</code> &mdash; a <em>designator</em> for a list of <em>package designators</em>. </p><p><code>symbol-type</code> &mdash; one of the <em>symbols</em> <code>:internal</code>, <code>:external</code>, or <code>:inherited</code>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em>. </p><p>Within the lexical scope of the body <em>forms</em>, the <em>name</em> is defined via <code>macrolet</code> such that successive invocations of <code>(</code><em>name</em><code>)</code> will return the <em>symbols</em>, one by one, from the <em>packages</em> in <em>package-list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_pkg_.htm#with-package-iterator)", "with-slots": "```commonlisp\nwith-slots (slot-entry*) instance-form declaration* form*\n => result*\nslot-entry::= slot-name | (variable-name slot-name) \n\n```\n\n<p><code>slot-name</code> &mdash; a <em>slot</em> <em>name</em>; not evaluated. </p><p><code>variable-name</code> &mdash; a <em>variable</em> <em>name</em>; not evaluated. </p><p><code>instance-form</code> &mdash; a <em>form</em>; evaluted to produce <em>instance</em>. </p><p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>The macro <code>with-slots</code> <em>establishes</em> a <em>lexical environment</em> for referring to the <em>slots</em> in the <em>instance</em> named by the given <em>slot-names</em> as though they were <em>variables</em>. Within such a context the value of the <em>slot</em> can be specified by using its slot name, as if it were a lexically bound variable. Both <code>setf</code> and <code>setq</code> can be used to set the value of the <em>slot</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_slts.htm#with-slots)", "with-standard-io-syntax": "```commonlisp\nwith-standard-io-syntax form* => result*\n```\n\n<p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p>Within the dynamic extent of the body of <em>forms</em>, all reader/printer control variables, including any <em>implementation-defined</em> ones not specified by this standard, are bound to values that produce standard read/print behavior. The values for the variables specified by this standard are listed in the next figure. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_std_.htm#with-standard-io-syntax)", "setq": "```commonlisp\nsetq {pair}* => result\npair::= var form \n\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em> naming a <em>variable</em> other than a <em>constant variable</em>. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>result</code> &mdash; the <em>primary value</em> of the last <em>form</em>, or <code>nil</code> if no <em>pairs</em> were supplied. </p><p>Assigns values to <em>variables</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_setq.htm#setq)", "catch": "```commonlisp\ncatch tag form* => result*\n```\n\n<p><code>tag</code> &mdash; a <em>catch tag</em>; evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; if the <em>forms</em> exit normally, the <em>values</em> returned by the <em>forms</em>; if a throw occurs to the <em>tag</em>, the <em>values</em> that are thrown. </p><p><code>catch</code> is used as the destination of a non-local control transfer by <code>throw</code>. <em>Tags</em> are used to find the <code>catch</code> to which a <code>throw</code> is transferring control. <code>(catch 'foo </code><em>form</em><code>)</code> catches a <code>(throw 'foo </code><em>form</em><code>)</code> but not a <code>(throw 'bar </code><em>form</em><code>)</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_catch.htm#catch)", "block": "```commonlisp\nblock name form* => result*\n```\n\n<p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em> if a <em>normal return</em> occurs, or else, if an <em>explicit return</em> occurs, the <em>values</em> that were transferred. </p><p><code>block</code> <em>establishes</em> a <em>block</em> named <em>name</em> and then evaluates <em>forms</em> as an <em>implicit progn</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_block.htm#block)", "go": "```commonlisp\ngo tag =>| \n```\n\n<p><code>tag</code> &mdash; a <em>go tag</em>. </p><p><code>go</code> transfers control to the point in the body of an enclosing <code>tagbody</code> form labeled by a tag <code>eql</code> to <em>tag</em>. If there is no such <em>tag</em> in the body, the bodies of lexically containing <code>tagbody</code> <em>forms</em> (if any) are examined as well. If several tags are <code>eql</code> to <em>tag</em>, control is transferred to whichever matching <em>tag</em> is contained in the innermost <code>tagbody</code> form that contains the <code>go</code>. The consequences are undefined if there is no matching <em>tag</em> lexically visible to the point of the <code>go</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_go.htm#go)", "eval-when": "```commonlisp\neval-when (situation*) form* => result*\n```\n\n<p> <code>situation</code> &mdash; One of the <em>symbols</em> <code>:compile-toplevel</code>, <code>:load-toplevel</code>, <code>:execute</code>, <code>compile</code>, <code>load</code>, or <code>eval</code>. </p><p>The use of <code>eval</code>, <code>compile</code>, and <code>load</code> is deprecated.    </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em> if they are executed, or <code>nil</code> if they are not. </p><p> The body of an <code>eval-when</code> form is processed as an <em>implicit progn</em>, but only in the <em>situations</em> listed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_eval_w.htm#eval-when)", "if": "```commonlisp\nif test-form then-form [else-form] => result*\n```\n\n<p><code>Test-form</code> &mdash; a <em>form</em>. </p><p><code>Then-form</code> &mdash; a <em>form</em>. </p><p><code>Else-form</code> &mdash; a <em>form</em>. The default is <code>nil</code>. </p><p><code>results</code> &mdash; if the <em>test-form</em> <em>yielded</em> <em>true</em>, the <em>values</em> returned by the <em>then-form</em>; otherwise, the <em>values</em> returned by the <em>else-form</em>. </p><p><code>if</code> allows the execution of a <em>form</em> to be dependent on a single <em>test-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_if.htm#if)", "labels": "```commonlisp\nflet ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nlabels ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nmacrolet ((name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\n```\n\n<p> <code>function-name</code> &mdash; a <em>function name</em>.  </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>lambda-list</code> &mdash; a <em>lambda list</em>; for <code>flet</code> and <code>labels</code>, it is an <em>ordinary lambda list</em>; for <code>macrolet</code>, it is a <em>macro lambda list</em>. </p><p><code>local-declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>local-documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>local-forms</code>, <code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em>. </p><p><code>flet</code>, <code>labels</code>, and <code>macrolet</code> define local <em>functions</em> and <em>macros</em>, and execute <em>forms</em> using the local definitions. <em>Forms</em> are executed in order of occurrence. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_flet_.htm#labels)", "let*": "```commonlisp\nlet ({var | (var [init-form])}*) declaration* form* => result*\nlet* ({var | (var [init-form])}*) declaration* form* => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>let</code> and <code>let*</code> create new variable <em>bindings</em> and execute a series of <em>forms</em> that use these <em>bindings</em>. <code>let</code> performs the <em>bindings</em> in parallel and <code>let*</code> does them sequentially. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_let_l.htm#letST)", "flet": "```commonlisp\nflet ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nlabels ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nmacrolet ((name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\n```\n\n<p> <code>function-name</code> &mdash; a <em>function name</em>.  </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>lambda-list</code> &mdash; a <em>lambda list</em>; for <code>flet</code> and <code>labels</code>, it is an <em>ordinary lambda list</em>; for <code>macrolet</code>, it is a <em>macro lambda list</em>. </p><p><code>local-declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>local-documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>local-forms</code>, <code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em>. </p><p><code>flet</code>, <code>labels</code>, and <code>macrolet</code> define local <em>functions</em> and <em>macros</em>, and execute <em>forms</em> using the local definitions. <em>Forms</em> are executed in order of occurrence. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_flet_.htm#flet)", "locally": "```commonlisp\nlocally declaration* form* => result*\n```\n\n<p><code>Declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p> <code>results</code> &mdash; the <em>values</em> of the <em>forms</em>.  </p><p>Sequentially evaluates a body of <em>forms</em> in a <em>lexical environment</em> where the given <em>declarations</em> have effect. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_locall.htm#locally)", "load-time-value": "```commonlisp\nload-time-value form &optional read-only-p => object\n```\n\n<p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>read-only-p</code> &mdash; a <em>boolean</em>; not evaluated. </p><p><code>object</code> &mdash; the <em>primary value</em> resulting from evaluating <em>form</em>. </p><p><code>load-time-value</code> provides a mechanism for delaying evaluation of <em>form</em> until the expression is in the run-time environment; see Section 3.2 (Compilation). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_ld_tim.htm#load-time-value)", "macrolet": "```commonlisp\nflet ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nlabels ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\nmacrolet ((name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*\n => result*\n```\n\n<p> <code>function-name</code> &mdash; a <em>function name</em>.  </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p><code>lambda-list</code> &mdash; a <em>lambda list</em>; for <code>flet</code> and <code>labels</code>, it is an <em>ordinary lambda list</em>; for <code>macrolet</code>, it is a <em>macro lambda list</em>. </p><p><code>local-declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>local-documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>local-forms</code>, <code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em>. </p><p><code>flet</code>, <code>labels</code>, and <code>macrolet</code> define local <em>functions</em> and <em>macros</em>, and execute <em>forms</em> using the local definitions. <em>Forms</em> are executed in order of occurrence. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_flet_.htm#macrolet)", "let": "```commonlisp\nlet ({var | (var [init-form])}*) declaration* form* => result*\nlet* ({var | (var [init-form])}*) declaration* form* => result*\n```\n\n<p><code>var</code> &mdash; a <em>symbol</em>. </p><p><code>init-form</code> &mdash; a <em>form</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>let</code> and <code>let*</code> create new variable <em>bindings</em> and execute a series of <em>forms</em> that use these <em>bindings</em>. <code>let</code> performs the <em>bindings</em> in parallel and <code>let*</code> does them sequentially. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_let_l.htm#let)", "multiple-value-call": "```commonlisp\nmultiple-value-call function-form form* => result*\n```\n\n<p><code>function-form</code> &mdash; a <em>form</em>; evaluated to produce <em>function</em>. </p><p><code>function</code> &mdash; a <em>function designator</em> resulting from the evaluation of <em>function-form</em>. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>function</em>. </p><p>Applies <em>function</em> to a <em>list</em> of the <em>objects</em> collected from groups of <em>multiple values</em>[2]. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_multip.htm#multiple-value-call)", "multiple-value-prog1": "```commonlisp\nmultiple-value-prog1 first-form form* => first-form-results\n```\n\n<p><code>first-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>first-form-results</code> &mdash; the <em>values</em> resulting from the <em>evaluation</em> of <em>first-form</em>. </p><p><code>multiple-value-prog1</code> evaluates <em>first-form</em> and saves all the values produced by that <em>form</em>. It then evaluates each <em>form</em> from left to right, discarding their values. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_mult_1.htm#multiple-value-prog1)", "progn": "```commonlisp\nprogn form* => result*\n```\n\n<p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>forms</em>. </p><p><code>progn</code> evaluates <em>forms</em>, in the order in which they are given. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_progn.htm#progn)", "progv": "```commonlisp\nprogv symbols values form* => result*\n```\n\n<p><code>symbols</code> &mdash; a <em>list</em> of <em>symbols</em>; evaluated. </p><p><code>values</code> &mdash; a <em>list</em> of <em>objects</em>; evaluated. </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>progv</code> creates new dynamic variable <em>bindings</em> and executes each <em>form</em> using those <em>bindings</em>. Each <em>form</em> is evaluated in order. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_progv.htm#progv)", "return-from": "```commonlisp\nreturn-from name [result] =>| \n```\n\n<p><code>name</code> &mdash; a <em>block tag</em>; not evaluated. </p><p><code>result</code> &mdash; a <em>form</em>; evaluated. The default is <code>nil</code>. </p><p>Returns control and <em>multiple values</em>[2] from a lexically enclosing <em>block</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_ret_fr.htm#return-from)", "quote": "```commonlisp\nquote object => object\n```\n\n<p><code>object</code> &mdash; an <em>object</em>; not evaluated. </p><p>The <code>quote</code> <em>special operator</em> just returns <em>object</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_quote.htm#quote)", "symbol-macrolet": "```commonlisp\nsymbol-macrolet ((symbol expansion)*) declaration* form*\n => result*\n```\n\n<p><code>symbol</code> &mdash; a <em>symbol</em>. </p><p><code>expansion</code> &mdash; a <em>form</em>. </p><p> <code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated.  </p><p><code>forms</code> &mdash; an <em>implicit progn</em>. </p><p><code>results</code> &mdash; the <em>values</em> returned by the <em>forms</em>. </p><p><code>symbol-macrolet</code> provides a mechanism for affecting the <em>macro expansion</em> environment for <em>symbols</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_symbol.htm#symbol-macrolet)", "tagbody": "```commonlisp\ntagbody {tag | statement}* => nil\n```\n\n<p><code>tag</code> &mdash; a <em>go tag</em>; not evaluated. </p><p><code>statement</code> &mdash; a <em>compound form</em>; evaluated as described below. </p><p>Executes zero or more <em>statements</em> in a <em>lexical environment</em> that provides for control transfers to labels indicated by the <em>tags</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_tagbod.htm#tagbody)", "the": "```commonlisp\nthe value-type form => result*\n```\n\n<p><code>value-type</code> &mdash; a <em>type specifier</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>; evaluated. </p><p> <code>results</code> &mdash; the <em>values</em> resulting from the <em>evaluation</em> of <em>form</em>. These <em>values</em> must conform to the <em>type</em> supplied by <em>value-type</em>; see below.  </p><p><code>the</code> specifies that the <em>values</em>[1a] returned by <em>form</em> are of the <em>types</em> specified by <em>value-type</em>. The consequences are undefined if any <em>result</em> is not of the declared type. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_the.htm#the)", "throw": "```commonlisp\nthrow tag result-form =>| \n```\n\n<p><code>tag</code> &mdash; a <em>catch tag</em>; evaluated. </p><p><code>result-form</code> &mdash; a <em>form</em>; evaluated as described below. </p><p><code>throw</code> causes a non-local control transfer to a <code>catch</code> whose tag is <code>eq</code> to <em>tag</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_throw.htm#throw)", "unwind-protect": "```commonlisp\nunwind-protect protected-form cleanup-form* => result*\n```\n\n<p><code>protected-form</code> &mdash; a <em>form</em>. </p><p><code>cleanup-form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> of the <em>protected-form</em>. </p><p><code>unwind-protect</code> evaluates <em>protected-form</em> and guarantees that <em>cleanup-forms</em> are executed before <code>unwind-protect</code> exits, whether it terminates normally or is aborted by a control transfer of some kind. <code>unwind-protect</code> is intended to be used to make sure that certain side effects take place after the evaluation of <em>protected-form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_unwind.htm#unwind-protect)", "add-method": "```commonlisp\nadd-method generic-function method => generic-function\n```\n\n<p><code>generic-function</code> &mdash; a <em>generic function</em> <em>object</em>. </p><p><code>method</code> &mdash; a <em>method</em> <em>object</em>. </p><p>The generic function <code>add-method</code> adds a <em>method</em> to a <em>generic function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_add_me.htm#add-method)", "allocate-instance": "```commonlisp\nallocate-instance class &rest initargs &key &allow-other-keys => new-instance\n```\n\n<p><code>class</code> &mdash; a <em>class</em>. </p><p><code>initargs</code> &mdash; a <em>list</em> of <em>keyword/value pairs</em> (initialization argument <em>names</em> and <em>values</em>). </p><p><code>new-instance</code> &mdash; an <em>object</em> whose <em>class</em> is <em>class</em>. </p><p>The generic function <code>allocate-instance</code> creates and returns a new instance of the <em>class</em>, without initializing it. When the <em>class</em> is a <em>standard class</em>, this means that the <em>slots</em> are <em>unbound</em>; when the <em>class</em> is a <em>structure class</em>, this means the <em>slots</em>' <em>values</em> are unspecified. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_alloca.htm#allocate-instance)", "change-class": "```commonlisp\nchange-class instance new-class &key &allow-other-keys => instance\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>new-class</code> &mdash; a <em>class designator</em>. </p><p> <code>initargs</code> &mdash; an <em>initialization argument list</em>.  </p><p>The <em>generic function</em> <code>change-class</code> changes the <em>class</em> of an <em>instance</em> to <em>new-class</em>. It destructively modifies and returns the <em>instance</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_chg_cl.htm#change-class)", "class-name": "```commonlisp\nclass-name class => name\n```\n\n<p><code>class</code> &mdash; a <em>class</em> <em>object</em>. </p><p><code>name</code> &mdash; a <em>symbol</em>. </p><p>Returns the <em>name</em> of the given <em>class</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_class_.htm#class-name)", "function-keywords": "```commonlisp\nfunction-keywords method => keys, allow-other-keys-p\n```\n\n<p><code>method</code> &mdash; a <em>method</em>. </p><p><code>keys</code> &mdash; a <em>list</em>. </p><p><code>allow-other-keys-p</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns the keyword parameter specifiers for a <em>method</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_fn_kwd.htm#function-keywords)", "compiler-macro": "```commonlisp\ndocumentation x doc-type => documentation\n(setf documentation) new-value x doc-type => new-value\n```\n\n<p> <code>x</code> &mdash; an <em>object</em>.  </p><p><code>doc-type</code> &mdash; a <em>symbol</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>, or <code>nil</code>. </p><p><code>new-value</code> &mdash; a <em>string</em>. </p><p>The <em>generic function</em> <code>documentation</code> returns the <em>documentation string</em> associated with the given <em>object</em> if it is available; otherwise it returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm#compiler-macro)", "describe-object": "```commonlisp\ndescribe-object object stream => implementation-dependent\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>stream</code> &mdash; a <em>stream</em>. </p><p>The generic function <code>describe-object</code> prints a description of <em>object</em> to a <em>stream</em>. <code>describe-object</code> is called by <code>describe</code>; it must not be called by the user. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_desc_1.htm#describe-object)", "compute-applicable-methods": "```commonlisp\ncompute-applicable-methods generic-function function-arguments => methods\n```\n\n<p><code>generic-function</code> &mdash; a <em>generic function</em>. </p><p><code>function-arguments</code> &mdash; a <em>list</em> of arguments for the <em>generic-function</em>. </p><p><code>methods</code> &mdash; a <em>list</em> of <em>method</em> <em>objects</em>. </p><p>Given a <em>generic-function</em> and a set of <em>function-arguments</em>, the function <code>compute-applicable-methods</code> returns the set of <em>methods</em> that are applicable for those arguments sorted according to precedence order. See Section 7.6.6 (Method Selection and Combination). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_comput.htm#compute-applicable-methods)", "find-method": "```commonlisp\nfind-method generic-function method-qualifiers specializers &optional errorp\n => method\n```\n\n<p><code>generic-function</code> &mdash; a <em>generic function</em>. </p><p><code>method-qualifiers</code> &mdash; a <em>list</em>. </p><p><code>specializers</code> &mdash; a <em>list</em>. </p><p><code>errorp</code> &mdash; a <em>generalized boolean</em>. The default is <em>true</em>. </p><p><code>method</code> &mdash; a <em>method</em> <em>object</em>, or <code>nil</code>. </p><p>The <em>generic function</em> <code>find-method</code> takes a <em>generic function</em> and returns the <em>method</em> <em>object</em> that agrees on <em>qualifiers</em> and <em>parameter specializers</em> with the <em>method-qualifiers</em> and <em>specializers</em> arguments of <code>find-method</code>. <em>Method-qualifiers</em> contains the method <em>qualifiers</em> for the <em>method</em>. The order of the method <em>qualifiers</em> is significant. For a definition of agreement in this context, see Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_m.htm#find-method)", "make-instance": "```commonlisp\nmake-instance class &rest initargs &key &allow-other-keys => instance\n```\n\n<p><code>class</code> &mdash; a <em>class</em>, or a <em>symbol</em> that names a <em>class</em>. </p><p><code>initargs</code> &mdash; an <em>initialization argument list</em>. </p><p><code>instance</code> &mdash; a <em>fresh</em> <em>instance</em> of <em>class</em> <em>class</em>. </p><p>The <em>generic function</em> <code>make-instance</code> creates and returns a new <em>instance</em> of the given <em>class</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_ins.htm#make-instance)", "initialize-instance": "```commonlisp\ninitialize-instance instance &rest initargs &key &allow-other-keys => instance\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>initargs</code> &mdash; a <em>defaulted initialization argument list</em>. </p><p>Called by <code>make-instance</code> to initialize a newly created <em>instance</em>. The generic function is called with the new <em>instance</em> and the <em>defaulted initialization argument list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_init_i.htm#initialize-instance)", "make-instances-obsolete": "```commonlisp\nmake-instances-obsolete class => class\n```\n\n<p><code>class</code> &mdash; a <em>class designator</em>. </p><p>The <em>function</em> <code>make-instances-obsolete</code> has the effect of initiating the process of updating the instances of the <em>class</em>. During updating, the generic function <code>update-instance-for-redefined-class</code> will be invoked. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_i_1.htm#make-instances-obsolete)", "documentation": "```commonlisp\ndocumentation x doc-type => documentation\n(setf documentation) new-value x doc-type => new-value\n```\n\n<p> <code>x</code> &mdash; an <em>object</em>.  </p><p><code>doc-type</code> &mdash; a <em>symbol</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>, or <code>nil</code>. </p><p><code>new-value</code> &mdash; a <em>string</em>. </p><p>The <em>generic function</em> <code>documentation</code> returns the <em>documentation string</em> associated with the given <em>object</em> if it is available; otherwise it returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm#documentation)", "no-applicable-method": "```commonlisp\nno-applicable-method generic-function &rest function-arguments => result*\n```\n\n<p><code>generic-function</code> &mdash; a <em>generic function</em> on which no <em>applicable method</em> was found. </p><p><code>function-arguments</code> &mdash; <em>arguments</em> to the <em>generic-function</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>The generic function <code>no-applicable-method</code> is called when a <em>generic function</em> is invoked and no <em>method</em> on that <em>generic function</em> is applicable. The <em>default method</em> signals an error. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_no_app.htm#no-applicable-method)", "make-load-form": "```commonlisp\nmake-load-form object &optional environment => creation-form[, initialization-form]\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>environment</code> &mdash; an <em>environment object</em>. </p><p><code>creation-form</code> &mdash; a <em>form</em>. </p><p><code>initialization-form</code> &mdash; a <em>form</em>. </p><p>The <em>generic function</em> <code>make-load-form</code> creates and returns one or two <em>forms</em>, a <em>creation-form</em> and an <em>initialization-form</em>, that enable <code>load</code> to construct an <em>object</em> equivalent to <em>object</em>. <em>Environment</em> is an <em>environment object</em> corresponding to the <em>lexical environment</em> in which the <em>forms</em> will be processed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_ld_.htm#make-load-form)", "no-next-method": "```commonlisp\nno-next-method generic-function method &rest args => result*\n```\n\n<p><code>generic-function</code>  &mdash;  <code>generic function</code> to which <code>method</code> belongs. </p><p><code>method</code>  &mdash;  <code>method</code> that contained the call to <code>call-next-method</code> for which there is no next <code>method</code>. </p><p><code>args</code>  &mdash;  arguments to <code>call-next-method</code>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>The <em>generic function</em> <code>no-next-method</code> is called by <code>call-next-method</code> when there is no <em>next method</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_no_nex.htm#no-next-method)", "print-object": "```commonlisp\nprint-object object stream => object\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>stream</code> &mdash; a <em>stream</em>. </p><p>The <em>generic function</em> <code>print-object</code> writes the printed representation of <em>object</em> to <em>stream</em>. The <em>function</em> <code>print-object</code> is called by the <em>Lisp printer</em>; it should not be called by the user. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_pr_obj.htm#print-object)", "method-qualifiers": "```commonlisp\nmethod-qualifiers method => qualifiers\n```\n\n<p><code>method</code> &mdash; a <em>method</em>. </p><p><code>qualifiers</code> &mdash; a <em>proper list</em>. </p><p>Returns a <em>list</em> of the <em>qualifiers</em> of the <em>method</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_method.htm#method-qualifiers)", "reinitialize-instance": "```commonlisp\nreinitialize-instance instance &rest initargs &key &allow-other-keys => instance\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>initargs</code> &mdash; an <em>initialization argument list</em>. </p><p>The <em>generic function</em> <code>reinitialize-instance</code> can be used to change the values of <em>local slots</em> of an <em>instance</em> according to <em>initargs</em>. This <em>generic function</em> can be called by users. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_reinit.htm#reinitialize-instance)", "remove-method": "```commonlisp\nremove-method generic-function method => generic-function\n```\n\n<p><code>generic-function</code> &mdash; a <em>generic function</em>. </p><p><code>method</code> &mdash; a <em>method</em>. </p><p>The <em>generic function</em> <code>remove-method</code> removes a <em>method</em> from <em>generic-function</em> by modifying the <em>generic-function</em> (if necessary). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_rm_met.htm#remove-method)", "slot-missing": "```commonlisp\nslot-missing class object slot-name operation &optional new-value => result*\n```\n\n<p><code>class</code> &mdash; the <em>class</em> of <em>object</em>. </p><p><code>object</code> &mdash; an <em>object</em>. </p><p><code>slot-name</code> &mdash; a <em>symbol</em> (the <em>name</em> of a would-be <em>slot</em>). </p><p><code>operation</code> &mdash; one of the <em>symbols</em> <code>setf</code>, <code>slot-boundp</code>, <code>slot-makunbound</code>, or <code>slot-value</code>. </p><p><code>new-value</code> &mdash; an <em>object</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>The generic function <code>slot-missing</code> is invoked when an attempt is made to <em>access</em> a <em>slot</em> in an <em>object</em> whose <em>metaclass</em> is <code>standard-class</code> and the <em>slot</em> of the name <em>slot-name</em> is not a <em>name</em> of a <em>slot</em> in that <em>class</em>. The default <em>method</em> signals an error. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_mi.htm#slot-missing)", "shared-initialize": "```commonlisp\nshared-initialize instance slot-names &rest initargs &key &allow-other-keys => instance\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>slot-names</code> &mdash; a <em>list</em> or <code>t</code>. </p><p><code>initargs</code> &mdash; a <em>list</em> of <em>keyword/value pairs</em> (of initialization argument <em>names</em> and <em>values</em>). </p><p>The generic function <code>shared-initialize</code> is used to fill the <em>slots</em> of an <em>instance</em> using <em>initargs</em> and <code>:initform</code> forms. It is called when an instance is created, when an instance is re-initialized, when an instance is updated to conform to a redefined <em>class</em>, and when an instance is updated to conform to a different <em>class</em>. The generic function <code>shared-initialize</code> is called by the system-supplied primary <em>method</em> for <code>initialize-instance</code>, <code>reinitialize-instance</code>, <code>update-instance-for-redefined-class</code>, and <code>update-instance-for-different-class</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_shared.htm#shared-initialize)", "update-instance-for-redefined-class": "```commonlisp\nupdate-instance-for-redefined-class instance added-slots discarded-slots property-list &rest initargs &key &allow-other-keys\n => result*\n```\n\n<p><code>instance</code> &mdash; an <em>object</em>. </p><p><code>added-slots</code> &mdash; a <em>list</em>. </p><p><code>discarded-slots</code> &mdash; a <em>list</em>. </p><p><code>property-list</code> &mdash; a <em>list</em>. </p><p><code>initargs</code> &mdash; an <em>initialization argument list</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>The <em>generic function</em> <code>update-instance-for-redefined-class</code> is not intended to be called by programmers. Programmers may write <em>methods</em> for it. The <em>generic function</em> <code>update-instance-for-redefined-class</code> is called by the mechanism activated by <code>make-instances-obsolete</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_upda_1.htm#update-instance-for-redefined-class)", "slot-unbound": "```commonlisp\nslot-unbound class instance slot-name => result*\n```\n\n<p><code>class</code> &mdash; the <em>class</em> of the <em>instance</em>. </p><p><code>instance</code> &mdash; the <em>instance</em> in which an attempt was made to <em>read</em> the <em>unbound</em> <em>slot</em>. </p><p><code>slot-name</code> &mdash; the <em>name</em> of the <em>unbound</em> <em>slot</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p>The generic function <code>slot-unbound</code> is called when an unbound <em>slot</em> is read in an <em>instance</em> whose metaclass is <code>standard-class</code>. The default <em>method</em> signals an error  of <em>type</em> <code>unbound-slot</code>. The name slot of the <code>unbound-slot</code> <em>condition</em> is initialized to the name of the offending variable, and the instance slot of the <code>unbound-slot</code> <em>condition</em> is initialized to the offending instance.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_slt_un.htm#slot-unbound)", "update-instance-for-different-class": "```commonlisp\nupdate-instance-for-different-class previous current &rest initargs &key &allow-other-keys => implementation-dependent\n```\n\n<p><code>previous</code> &mdash; a copy of the original <em>instance</em>. </p><p><code>current</code> &mdash; the original <em>instance</em> (altered). </p><p><code>initargs</code> &mdash; an <em>initialization argument list</em>. </p><p>The generic function <code>update-instance-for-different-class</code> is not intended to be called by programmers. Programmers may write <em>methods</em> for it. The <em>function</em> <code>update-instance-for-different-class</code> is called only by the <em>function</em> <code>change-class</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_update.htm#update-instance-for-different-class)", "structure": "```commonlisp\ndocumentation x doc-type => documentation\n(setf documentation) new-value x doc-type => new-value\n```\n\n<p> <code>x</code> &mdash; an <em>object</em>.  </p><p><code>doc-type</code> &mdash; a <em>symbol</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>, or <code>nil</code>. </p><p><code>new-value</code> &mdash; a <em>string</em>. </p><p>The <em>generic function</em> <code>documentation</code> returns the <em>documentation string</em> associated with the given <em>object</em> if it is available; otherwise it returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm#structure)", "variable": "```commonlisp\ndocumentation x doc-type => documentation\n(setf documentation) new-value x doc-type => new-value\n```\n\n<p> <code>x</code> &mdash; an <em>object</em>.  </p><p><code>doc-type</code> &mdash; a <em>symbol</em>. </p><p><code>documentation</code> &mdash; a <em>string</em>, or <code>nil</code>. </p><p><code>new-value</code> &mdash; a <em>string</em>. </p><p>The <em>generic function</em> <code>documentation</code> returns the <em>documentation string</em> associated with the given <em>object</em> if it is available; otherwise it returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/f_docume.htm#variable)", "array": "<p><code>array</code>, <code>t</code> </p><p>This denotes the set of <em>arrays</em> whose <em>element type</em>, <em>rank</em>, and <em>dimensions</em> match any given <em>element-type</em>, <em>rank</em>, and <em>dimensions</em>. Specifically: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_array.htm#array)", "bit-vector": "<p><code>bit-vector</code>, <code>vector</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This denotes the same <em>type</em> as the <em>type</em> <code>(array bit (</code><em>size</em><code>))</code>; that is, the set of <em>bit vectors</em> of size <em>size</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_bt_vec.htm#bit-vector)", "broadcast-stream": "<p><code>broadcast-stream</code>, <code>stream</code>, <code>t</code> </p><p>A <em>broadcast stream</em> is an <em>output</em> <em>stream</em> which has associated with it a set of zero or more <em>output</em> <em>streams</em> such that any output sent to the <em>broadcast stream</em> gets passed on as output to each of the associated <em>output</em> <em>streams</em>. (If a <em>broadcast stream</em> has no <em>component streams</em>, then all output to the <em>broadcast stream</em> is discarded.) </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_broadc.htm#broadcast-stream)", "built-in-class": "<p><code>built-in-class</code>, <code>class</code>,  <code>standard-object</code>,  <code>t</code> </p><p>A <em>built-in class</em> is a <em>class</em> whose <em>instances</em> have restricted capabilities or special representations. Attempting to use <code>defclass</code> to define <em>subclasses</em> of a <em>built-in class</em> signals an error of <em>type</em> <code>error</code>. Calling <code>make-instance</code> to create an <em>instance</em> of a <em>built-in class</em> signals an error of <em>type</em> <code>error</code>. Calling <code>slot-value</code> on an <em>instance</em> of a <em>built-in class</em> signals an error of <em>type</em> <code>error</code>. Redefining a <em>built-in class</em> or using <code>change-class</code> to change the <em>class</em> of an <em>instance</em> to or from a <em>built-in class</em> signals an error of <em>type</em> <code>error</code>. However, <em>built-in classes</em> can be used as <em>parameter specializers</em> in <em>methods</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_built_.htm#built-in-class)", "class": "<p><code>class</code>,  <code>standard-object</code>,  <code>t</code>  </p><p>The <em>type</em> <code>class</code> represents <em>objects</em> that determine the structure and behavior of their <em>instances</em>. Associated with an <em>object</em> of <em>type</em> <code>class</code> is information describing its place in the directed acyclic graph of <em>classes</em>, its <em>slots</em>, and its options. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_class.htm#class)", "concatenated-stream": "<p><code>concatenated-stream</code>, <code>stream</code>, <code>t</code> </p><p>A <em>concatenated stream</em> is an <em>input</em> <em>stream</em> which is a <em>composite stream</em> of zero or more other <em>input</em> <em>streams</em>, such that the sequence of data which can be read from the <em>concatenated stream</em> is the same as the concatenation of the sequences of data which could be read from each of the constituent <em>streams</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_concat.htm#concatenated-stream)", "echo-stream": "<p><code>echo-stream</code>, <code>stream</code>, <code>t</code> </p><p>An <em>echo stream</em> is a <em>bidirectional</em> <em>stream</em> that gets its input from an associated <em>input</em> <em>stream</em> and sends its output to an associated <em>output</em> <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_echo_s.htm#echo-stream)", "file-stream": "<p><code>file-stream</code>, <code>stream</code>, <code>t</code> </p><p>An <em>object</em> of <em>type</em> <code>file-stream</code> is a <em>stream</em> the direct source or sink of which is a <em>file</em>. Such a <em>stream</em> is created explicitly by <code>open</code> and <code>with-open-file</code>, and implicitly by <em>functions</em> such as <code>load</code> that process <em>files</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_file_s.htm#file-stream)", "generic-function": "<p><code>generic-function</code>, <code>function</code>, <code>t</code>  </p><p>A <em>generic function</em> is a <em>function</em> whose behavior depends on the <em>classes</em> or identities of the <em>arguments</em> supplied to it. A generic function object contains a set of <em>methods</em>, a <em>lambda list</em>, a <em>method combination</em> <em>type</em>, and other information. The <em>methods</em> define the class-specific behavior and operations of the <em>generic function</em>; a <em>method</em> is said to <em>specialize</em> a <em>generic function</em>. When invoked, a <em>generic function</em> executes a subset of its <em>methods</em> based on the <em>classes</em> or identities of its <em>arguments</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_generi.htm#generic-function)", "hash-table": "<p><code>hash-table</code>, <code>t</code> </p><p><em>Hash tables</em> provide a way of mapping any <em>object</em> (a <em>key</em>) to an associated <em>object</em> (a <em>value</em>). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_hash_t.htm#hash-table)", "integer": "<p><code>integer</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>This denotes the <em>integers</em> on the interval described by <em>lower-limit</em> and <em>upper-limit</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_intege.htm#integer)", "package": "<p><code>package</code>, <code>t</code> </p><p>A <em>package</em> is a <em>namespace</em> that maps <em>symbol</em> <em>names</em> to <em>symbols</em>; see Section 11.1 (Package Concepts). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_pkg.htm#package)", "method": "<p><code>method</code>, <code>t</code>  </p><p>A <em>method</em> is an <em>object</em> that represents a modular part of the behavior of a <em>generic function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_method.htm#method)", "number": "<p><code>number</code>, <code>t</code> </p><p>The <em>type</em> <code>number</code> contains <em>objects</em> which represent mathematical numbers.  The <em>types</em> <code>real</code> and <code>complex</code> are <em>disjoint</em> <em>subtypes</em> of <code>number</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_number.htm#number)", "readtable": "<p><code>readtable</code>, <code>t</code> </p><p>A <em>readtable</em> maps <em>characters</em> into <em>syntax types</em> for the <em>Lisp reader</em>; see Section 2 (Syntax). A <em>readtable</em> also contains associations between <em>macro characters</em> and their <em>reader macro functions</em>, and records information about the case conversion rules to be used by the <em>Lisp reader</em> when parsing <em>symbols</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_rdtabl.htm#readtable)", "random-state": "<p><code>random-state</code>, <code>t</code> </p><p>A <em>random state</em> <em>object</em> contains state information used by the pseudo-random number generator. The nature of a <em>random state</em> <em>object</em> is <em>implementation-dependent</em>. It can be printed out and successfully read back in by the same <em>implementation</em>, but might not function correctly as a <em>random state</em> in another <em>implementation</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_rnd_st.htm#random-state)", "real": "<p><code>real</code>, <code>number</code>, <code>t</code> </p><p>This denotes the <em>reals</em> on the interval described by <em>lower-limit</em> and <em>upper-limit</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_real.htm#real)", "ratio": "<p><code>ratio</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>A <em>ratio</em> is a <em>number</em> representing the mathematical ratio of two non-zero integers, the numerator and denominator, whose greatest common divisor is one, and of which the denominator is positive and greater than one. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_ratio.htm#ratio)", "restart": "<p><code>restart</code>, <code>t</code> </p><p>An <em>object</em> of <em>type</em> <code>restart</code> represents a <em>function</em> that can be called to perform some form of recovery action, usually a transfer of control to an outer point in the running program. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_rst.htm#restart)", "standard-class": "<p><code>standard-class</code>, <code>class</code>,  <code>standard-object</code>,  <code>t</code> </p><p>The <em>class</em> <code>standard-class</code> is the default <em>class</em> of <em>classes</em> defined by <code>defclass</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_std_cl.htm#standard-class)", "sequence": "<p><code>sequence</code>, <code>t</code> </p><p><em>Sequences</em> are ordered collections of <em>objects</em>, called the <em>elements</em> of the <em>sequence</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_seq.htm#sequence)", "standard-generic-function": "<p><code>standard-generic-function</code>, <code>generic-function</code>, <code>function</code>, <code>t</code> </p><p>The <em>class</em> <code>standard-generic-function</code> is the default <em>class</em> of <em>generic functions</em> <em>established</em> by <code>defmethod</code>, <code>ensure-generic-function</code>, <code>defgeneric</code>,    and <code>defclass</code> <em>forms</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_std_ge.htm#standard-generic-function)", "standard-method": "<p><code>standard-method</code>, <code>method</code>,  <code>standard-object</code>,  <code>t</code> </p><p>The <em>class</em> <code>standard-method</code> is the default <em>class</em> of <em>methods</em> defined by the <code>defmethod</code> and <code>defgeneric</code> <em>forms</em>.     </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_std_me.htm#standard-method)", "stream": "<p><code>stream</code>, <code>t</code> </p><p>A <em>stream</em> is an <em>object</em> that can be used with an input or output function to identify an appropriate source or sink of <em>characters</em> or <em>bytes</em> for that operation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_stream.htm#stream)", "string-stream": "<p><code>string-stream</code>, <code>stream</code>, <code>t</code> </p><p>A <em>string stream</em> is a <em>stream</em> which reads input from or writes output to an associated <em>string</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_stg_st.htm#string-stream)", "symbol": "<p><code>symbol</code>, <code>t</code> </p><p><em>Symbols</em> are used for their <em>object</em> identity to name various entities in Common Lisp, including (but not limited to) linguistic entities such as <em>variables</em> and <em>functions</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_symbol.htm#symbol)", "structure-class": "<p><code>structure-class</code>, <code>class</code>,  <code>standard-object</code>,  <code>t</code> </p><p>All <em>classes</em> defined by means of <code>defstruct</code> are <em>instances</em> of the <em>class</em> <code>structure-class</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_stu_cl.htm#structure-class)", "synonym-stream": "<p><code>synonym-stream</code>, <code>stream</code>, <code>t</code> </p><p>A <em>stream</em> that is an alias for another <em>stream</em>, which is the <em>value</em> of a <em>dynamic variable</em> whose <em>name</em> is the <em>synonym stream symbol</em> of the <em>synonym stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_syn_st.htm#synonym-stream)", "two-way-stream": "<p><code>two-way-stream</code>, <code>stream</code>, <code>t</code> </p><p>A <em>bidirectional</em> <em>composite stream</em> that receives its input from an associated <em>input</em> <em>stream</em> and sends its output to an associated <em>output</em> <em>stream</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_two_wa.htm#two-way-stream)", "base-char": "<p><code>base-char</code>, <code>character</code>, <code>t</code> </p><p>The <em>type</em> <code>base-char</code> is defined as the <em>upgraded array element type</em> of <code>standard-char</code>. An <em>implementation</em> can support additional <em>subtypes</em> of <em>type</em> <code>character</code> (besides the ones listed in this standard) that might or might not be <em>supertypes</em> of <em>type</em> <code>base-char</code>. In addition, an <em>implementation</em> can define <code>base-char</code> to be the <em>same</em> <em>type</em> as <code>character</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_base_c.htm#base-char)", "bignum": "<p><code>bignum</code>, <code>integer</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p> The <em>type</em> <code>bignum</code> is defined to be exactly <code>(and integer (not fixnum))</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_bignum.htm#bignum)", "base-string": "<p><code>base-string</code>, <code>string</code>, <code>vector</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This is equivalent to the type <code>(vector base-char </code><em>size</em><code>)</code>; that is, the set of <em>base strings</em> of size <em>size</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_base_s.htm#base-string)", "boolean": "<p><code>boolean</code>, <code>symbol</code>, <code>t</code> </p><p>The <em>type</em> <code>boolean</code> contains the <em>symbols</em> <code>t</code> and <code>nil</code>, which represent true and false, respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_ban.htm#boolean)", "double-float": "<p><code>short-float</code>: <code>short-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>single-float</code>: <code>single-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>double-float</code>: <code>double-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>long-float</code>: <code>long-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>Each of these denotes the set of <em>floats</em> of the indicated <em>type</em> that are on the interval specified by the <em>interval designators</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_short_.htm#double-float)", "compiled-function": "<p><code>compiled-function</code>, <code>function</code>, <code>t</code> </p><p> Any <em>function</em> may be considered by an <em>implementation</em> to be a a <em>compiled function</em> if it contains no references to <em>macros</em> that must be expanded at run time, and it contains no unresolved references to <em>load time values</em>. See Section 3.2.2 (Compilation Semantics).  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_cmpd_f.htm#compiled-function)", "extended-char": "<p><code>extended-char</code>, <code>character</code>, <code>t</code> </p><p>The <em>type</em> <code>extended-char</code> is equivalent to the <em>type</em> <code>(and character (not base-char))</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_extend.htm#extended-char)", "fixnum": "<p><code>fixnum</code>, <code>integer</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>A <em>fixnum</em> is an <em>integer</em> whose value is between <code>most-negative-fixnum</code> and <code>most-positive-fixnum</code> inclusive. Exactly which <em>integers</em> are <em>fixnums</em> is <em>implementation-defined</em>.  The <em>type</em> <code>fixnum</code> is required to be a supertype of <code>(signed-byte 16)</code>.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_fixnum.htm#fixnum)", "keyword": "<p><code>keyword</code>, <code>symbol</code>, <code>t</code> </p><p>The <em>type</em> <code>keyword</code> includes all <em>symbols</em> <em>interned</em> the <code>KEYWORD</code> package. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_kwd.htm#keyword)", "long-float": "<p><code>short-float</code>: <code>short-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>single-float</code>: <code>single-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>double-float</code>: <code>double-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>long-float</code>: <code>long-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>Each of these denotes the set of <em>floats</em> of the indicated <em>type</em> that are on the interval specified by the <em>interval designators</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_short_.htm#long-float)", "signed-byte": "<p><code>signed-byte</code>, <code>integer</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>This denotes the set of <em>integers</em> that can be represented in two's-complement form in a <em>byte</em> of <em>s</em> bits. This is equivalent to <code>(integer -2^s-1 2^s-1-1)</code>. The type <code>signed-byte</code> or the type <code>(signed-byte *)</code> is the same as the <em>type</em> <code>integer</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_sgn_by.htm#signed-byte)", "simple-array": "<p><code>simple-array</code>, <code>array</code>, <code>t</code> </p><p>This <em>compound type specifier</em> is treated exactly as the corresponding <em>compound type specifier</em> for <em>type</em> <code>array</code> would be treated, except that the set is further constrained to include only <em>simple arrays</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_smp_ar.htm#simple-array)", "short-float": "<p><code>short-float</code>: <code>short-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>single-float</code>: <code>single-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>double-float</code>: <code>double-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>long-float</code>: <code>long-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>Each of these denotes the set of <em>floats</em> of the indicated <em>type</em> that are on the interval specified by the <em>interval designators</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_short_.htm#short-float)", "simple-bit-vector": "<p><code>simple-bit-vector</code>, <code>bit-vector</code>, <code>vector</code>, <code>simple-array</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This denotes the same type as the <em>type</em> <code>(simple-array bit (</code><em>size</em><code>))</code>; that is, the set of <em>simple bit vectors</em> of size <em>size</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_smp_bt.htm#simple-bit-vector)", "simple-base-string": "<p><code>simple-base-string</code>, <code>base-string</code>, <code>simple-string</code>, <code>string</code>, <code>vector</code>, <code>simple-array</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This is equivalent to the type <code>(simple-array base-char (</code><em>size</em><code>))</code>; that is, the set of <em>simple</em> <em>base strings</em> of size <em>size</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_smp_ba.htm#simple-base-string)", "simple-string": "<p><code>simple-string</code>, <code>string</code>, <code>vector</code>, <code>simple-array</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This denotes the union of all <em>types</em> <code>(simple-array </code><em>c</em><code> (</code><em>size</em><code>))</code> for all <em>subtypes</em> <em>c</em> of <code>character</code>; that is, the set of <em>simple strings</em> of size <em>size</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_smp_st.htm#simple-string)", "simple-vector": "<p><code>simple-vector</code>, <code>vector</code>, <code>simple-array</code>, <code>array</code>, <code>sequence</code>, <code>t</code> </p><p>This is the same as <code>(simple-array t (</code><em>size</em><code>))</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_smp_ve.htm#simple-vector)", "single-float": "<p><code>short-float</code>: <code>short-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>single-float</code>: <code>single-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>double-float</code>: <code>double-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p><code>long-float</code>: <code>long-float</code>, <code>float</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>Each of these denotes the set of <em>floats</em> of the indicated <em>type</em> that are on the interval specified by the <em>interval designators</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_short_.htm#single-float)", "unsigned-byte": "<p><code>unsigned-byte</code>, <code>signed-byte</code>, <code>integer</code>, <code>rational</code>,  <code>real</code>,  <code>number</code>, <code>t</code> </p><p>This denotes the set of non-negative <em>integers</em> that can be represented in a byte of size <em>s</em> (bits). This is equivalent to <code>(mod </code><em>m</em><code>)</code> for <em>m</em>=2^s, or to <code>(integer 0 </code><em>n</em><code>)</code> for <em>n</em>=2^s-1. The <em>type</em> <code>unsigned-byte</code> or the type <code>(unsigned-byte *)</code> is the same as the type <code>(integer 0 *)</code>, the set of non-negative <em>integers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_unsgn_.htm#unsigned-byte)", "standard-char": "<p><code>standard-char</code>,  <code>base-char</code>,  <code>character</code>, <code>t</code> </p><p>A fixed set of 96 <em>characters</em> required to be present in all <em>conforming implementations</em>. <em>Standard characters</em> are defined in Section 2.1.3 (Standard Characters). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_std_ch.htm#standard-char)", "*break-on-signals*": "<p>a <em>type specifier</em>. </p><p><code>nil</code>. </p><p>When <code>(typep </code><em>condition</em><code> *break-on-signals*)</code> returns <em>true</em>, calls to <code>signal</code>, and to other <em>operators</em> such as <code>error</code> that implicitly call <code>signal</code>, enter the debugger prior to <em>signaling</em> the <em>condition</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_break_.htm#STbreak-on-signalsST)", "***": "<p>an <em>object</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>*</code>, <code>**</code>, and <code>***</code> are maintained by the <em>Lisp read-eval-print loop</em> to save the values of results that are printed each time through the loop. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v__stst_.htm#STSTST)", "**": "<p>an <em>object</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>*</code>, <code>**</code>, and <code>***</code> are maintained by the <em>Lisp read-eval-print loop</em> to save the values of results that are printed each time through the loop. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v__stst_.htm#STST)", "*compile-file-truename*": "<p>The <em>value</em> of <code>*compile-file-pathname*</code> must always be a <em>pathname</em> or <code>nil</code>. The <em>value</em> of <code>*compile-file-truename*</code> must always be a <em>physical pathname</em> or <code>nil</code>. </p><p><code>nil</code>. </p><p>During a call to <code>compile-file</code>, <code>*compile-file-pathname*</code> is <em>bound</em> to the <em>pathname</em> denoted by the first argument to <code>compile-file</code>, merged against the defaults; that is, it is <em>bound</em> to <code>(pathname (merge-pathnames </code><em>input-file</em><code>))</code>. During the same time interval, <code>*compile-file-truename*</code> is <em>bound</em> to the <em>truename</em> of the <em>file</em> being <em>compiled</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_cmp_fi.htm#STcompile-file-truenameST)", "*compile-print*": "<p>a <em>generalized boolean</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*compile-print*</code> is the default value of the <code>:print</code> <em>argument</em> to <code>compile-file</code>. The <em>value</em> of <code>*compile-verbose*</code> is the default value of the <code>:verbose</code> <em>argument</em> to <code>compile-file</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_cmp_pr.htm#STcompile-printST)", "*compile-verbose*": "<p>a <em>generalized boolean</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*compile-print*</code> is the default value of the <code>:print</code> <em>argument</em> to <code>compile-file</code>. The <em>value</em> of <code>*compile-verbose*</code> is the default value of the <code>:verbose</code> <em>argument</em> to <code>compile-file</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_cmp_pr.htm#STcompile-verboseST)", "*debugger-hook*": "<p>a <em>designator</em> for a <em>function</em> of two <em>arguments</em> (a <em>condition</em> and the <em>value</em> of <code>*debugger-hook*</code> at the time the debugger was entered), or <code>nil</code>. </p><p><code>nil</code>. </p><p>When the <em>value</em> of <code>*debugger-hook*</code> is <em>non-nil</em>, it is called prior to normal entry into the debugger, either due to a call to <code>invoke-debugger</code> or due to automatic entry into the debugger from a call to <code>error</code> or <code>cerror</code> with a condition that is not handled. The <em>function</em> may either handle the <em>condition</em> (transfer control) or return normally (allowing the standard debugger to run). To minimize recursive errors while debugging, <code>*debugger-hook*</code> is bound to <code>nil</code> by <code>invoke-debugger</code> prior to calling the <em>function</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debugg.htm#STdebugger-hookST)", "*compile-file-pathname*": "<p>The <em>value</em> of <code>*compile-file-pathname*</code> must always be a <em>pathname</em> or <code>nil</code>. The <em>value</em> of <code>*compile-file-truename*</code> must always be a <em>physical pathname</em> or <code>nil</code>. </p><p><code>nil</code>. </p><p>During a call to <code>compile-file</code>, <code>*compile-file-pathname*</code> is <em>bound</em> to the <em>pathname</em> denoted by the first argument to <code>compile-file</code>, merged against the defaults; that is, it is <em>bound</em> to <code>(pathname (merge-pathnames </code><em>input-file</em><code>))</code>. During the same time interval, <code>*compile-file-truename*</code> is <em>bound</em> to the <em>truename</em> of the <em>file</em> being <em>compiled</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_cmp_fi.htm#STcompile-file-pathnameST)", "*error-output*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STerror-outputST)", "*features*": "<p>a <em>proper list</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*features*</code> is called the <em>features list</em>. It is a <em>list</em> of <em>symbols</em>, called <em>features</em>, that correspond to some aspect of the <em>implementation</em> or <em>environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_featur.htm#STfeaturesST)", "*default-pathname-defaults*": "<p>a <em>pathname</em> <em>object</em>. </p><p>An <em>implementation-dependent</em> <em>pathname</em>, typically in the working directory that was current when Common Lisp was started up. </p><p>a <em>pathname</em>, used as the default whenever a <em>function</em> needs a default <em>pathname</em> and one is not supplied. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_defaul.htm#STdefault-pathname-defaultsST)", "*debug-io*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STdebug-ioST)", "*gensym-counter*": "<p>a non-negative <em>integer</em>. </p><p><em>implementation-dependent</em>. </p><p>A number which will be used in constructing the <em>name</em> of the next <em>symbol</em> generated by the <em>function</em> <code>gensym</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_gensym.htm#STgensym-counterST)", "*load-truename*": "<p>The <em>value</em> of <code>*load-pathname*</code> must always be a <em>pathname</em> or <code>nil</code>. The <em>value</em> of <code>*load-truename*</code> must always be a <em>physical pathname</em> or <code>nil</code>. </p><p><code>nil</code>. </p><p>During a call to <code>load</code>, <code>*load-pathname*</code> is <em>bound</em> to the <em>pathname</em> denoted by the the first argument to <code>load</code>, merged against the defaults; that is, it is <em>bound</em> to <code>(pathname (merge-pathnames </code><em>filespec</em><code>))</code>. During the same time interval, <code>*load-truename*</code> is <em>bound</em> to the <em>truename</em> of the <em>file</em> being loaded. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ld_pns.htm#STload-truenameST)", "*load-print*": "<p>a <em>generalized boolean</em>. </p><p>The initial <em>value</em> of <code>*load-print*</code> is <em>false</em>. The initial <em>value</em> of <code>*load-verbose*</code> is <em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*load-print*</code> is the default value of the <code>:print</code> <em>argument</em> to <code>load</code>. The <em>value</em> of <code>*load-verbose*</code> is the default value of the <code>:verbose</code> <em>argument</em> to <code>load</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ld_prs.htm#STload-printST)", "*load-pathname*": "<p>The <em>value</em> of <code>*load-pathname*</code> must always be a <em>pathname</em> or <code>nil</code>. The <em>value</em> of <code>*load-truename*</code> must always be a <em>physical pathname</em> or <code>nil</code>. </p><p><code>nil</code>. </p><p>During a call to <code>load</code>, <code>*load-pathname*</code> is <em>bound</em> to the <em>pathname</em> denoted by the the first argument to <code>load</code>, merged against the defaults; that is, it is <em>bound</em> to <code>(pathname (merge-pathnames </code><em>filespec</em><code>))</code>. During the same time interval, <code>*load-truename*</code> is <em>bound</em> to the <em>truename</em> of the <em>file</em> being loaded. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ld_pns.htm#STload-pathnameST)", "*macroexpand-hook*": "<p>a <em>designator</em> for a <em>function</em> of three <em>arguments</em>: a <em>macro function</em>, a <em>macro form</em>, and an <em>environment</em> <em>object</em>. </p><p>  a <em>designator</em> for a function that is equivalent to the <em>function</em> <code>funcall</code>, but that might have additional <em>implementation-dependent</em> side-effects.   </p><p>Used as the expansion interface hook by <code>macroexpand-1</code> to control the <em>macro expansion</em> process. When a <em>macro form</em> is to be expanded, this <em>function</em> is called with three arguments: the <em>macro function</em>, the <em>macro form</em>, and the <em>environment</em> in which the <em>macro form</em> is to be expanded.  The <em>environment</em> <em>object</em> has <em>dynamic extent</em>; the consequences are undefined if the <em>environment</em> <em>object</em> is referred to outside the <em>dynamic extent</em> of the macro expansion function.  </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_mexp_h.htm#STmacroexpand-hookST)", "*modules*": "<p>a <em>list</em> of <em>strings</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*modules*</code> is a list of names of the modules that have been loaded into the current <em>Lisp image</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_module.htm#STmodulesST)", "*package*": "<p>a <em>package</em> <em>object</em>. </p><p>the <code>COMMON-LISP-USER</code> package. </p><p>Whatever <em>package</em> <em>object</em> is currently the <em>value</em> of <code>*package*</code> is referred to as the <em>current package</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pkg.htm#STpackageST)", "*load-verbose*": "<p>a <em>generalized boolean</em>. </p><p>The initial <em>value</em> of <code>*load-print*</code> is <em>false</em>. The initial <em>value</em> of <code>*load-verbose*</code> is <em>implementation-dependent</em>. </p><p>The <em>value</em> of <code>*load-print*</code> is the default value of the <code>:print</code> <em>argument</em> to <code>load</code>. The <em>value</em> of <code>*load-verbose*</code> is the default value of the <code>:verbose</code> <em>argument</em> to <code>load</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_ld_prs.htm#STload-verboseST)", "*print-array*": "<p>a <em>generalized boolean</em>. </p><p><em>implementation-dependent</em>. </p><p>Controls the format in which <em>arrays</em> are printed. If it is <em>false</em>, the contents of <em>arrays</em> other than <em>strings</em> are never printed. Instead, <em>arrays</em> are printed in a concise form using <code>#&lt;</code> that gives enough information for the user to be able to identify the <em>array</em>, but does not include the entire <em>array</em> contents. If it is <em>true</em>, non-<em>string</em> <em>arrays</em> are printed using <code>#(...)</code>, <code>#*</code>, or <code>#nA</code> syntax. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_ar.htm#STprint-arrayST)", "*print-base*": "<p><code>*print-base*</code> &mdash; a <em>radix</em>. <code>*print-radix*</code> &mdash; a <em>generalized boolean</em>. </p><p>The initial <em>value</em> of <code>*print-base*</code> is <code>10</code>. The initial <em>value</em> of <code>*print-radix*</code> is <em>false</em>. </p><p><code>*print-base*</code> and <code>*print-radix*</code> control the printing of <em>rationals</em>. The <em>value</em> of <code>*print-base*</code> is called the <em>current output base</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_bas.htm#STprint-baseST)", "*print-circle*": "<p>a <em>generalized boolean</em>. </p><p><em>false</em>. </p><p>Controls the attempt to detect circularity and sharing in an <em>object</em> being printed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_cir.htm#STprint-circleST)", "*print-case*": "<p>One of the <em>symbols</em> <code>:upcase</code>, <code>:downcase</code>, or <code>:capitalize</code>. </p><p>The <em>symbol</em> <code>:upcase</code>. </p><p>The <em>value</em> of <code>*print-case*</code> controls the case (upper, lower, or mixed) in which to print any uppercase characters in the names of <em>symbols</em> when vertical-bar syntax is not used. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_cas.htm#STprint-caseST)", "*print-escape*": "<p>a <em>generalized boolean</em>. </p><p><em>true</em>. </p><p>If <em>false</em>, escape characters and <em>package prefixes</em> are not output when an expression is printed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_esc.htm#STprint-escapeST)", "*print-lines*": "<p>a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>nil</code>. </p><p>When the <em>value</em> of <code>*print-lines*</code> is other than <code>nil</code>, it is a limit on the number of output lines produced when something is pretty printed. If an attempt is made to go beyond that many lines, ``<code>..</code>'' is printed at the end of the last line followed by all of the suffixes (closing delimiters) that are pending to be printed. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_lin.htm#STprint-linesST)", "*print-gensym*": "<p>a <em>generalized boolean</em>. </p><p><em>true</em>. </p><p>Controls whether the prefix ``<code>#:</code>'' is printed before <em>apparently uninterned</em> <em>symbols</em>. The prefix is printed before such <em>symbols</em> if and only if the <em>value</em> of <code>*print-gensym*</code> is <em>true</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_gen.htm#STprint-gensymST)", "*print-level*": "<p>a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>nil</code>. </p><p><code>*print-level*</code> controls how many levels deep a nested <em>object</em> will print. If it is <em>false</em>, then no control is exercised. Otherwise, it is an <em>integer</em> indicating the maximum level to be printed. An <em>object</em> to be printed is at level <code>0</code>; its components (as of a <em>list</em> or <em>vector</em>) are at level <code>1</code>; and so on. If an <em>object</em> to be recursively printed has components and is at a level equal to or greater than the <em>value</em> of <code>*print-level*</code>, then the <em>object</em> is printed as ``<code>#</code>''. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_lev.htm#STprint-levelST)", "*print-pprint-dispatch*": "<p>a <em>pprint dispatch table</em>. </p><p><em>implementation-dependent</em>, but the initial entries all use a special class of priorities that have the property that they are less than every priority that can be specified using <code>set-pprint-dispatch</code>, so that the initial contents of any entry can be overridden. </p><p>The <em>pprint dispatch table</em> which currently controls the <em>pretty printer</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_ppr.htm#STprint-pprint-dispatchST)", "*print-length*": "<p>a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>nil</code>. </p><p><code>*print-level*</code> controls how many levels deep a nested <em>object</em> will print. If it is <em>false</em>, then no control is exercised. Otherwise, it is an <em>integer</em> indicating the maximum level to be printed. An <em>object</em> to be printed is at level <code>0</code>; its components (as of a <em>list</em> or <em>vector</em>) are at level <code>1</code>; and so on. If an <em>object</em> to be recursively printed has components and is at a level equal to or greater than the <em>value</em> of <code>*print-level*</code>, then the <em>object</em> is printed as ``<code>#</code>''. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_lev.htm#STprint-lengthST)", "*print-radix*": "<p><code>*print-base*</code> &mdash; a <em>radix</em>. <code>*print-radix*</code> &mdash; a <em>generalized boolean</em>. </p><p>The initial <em>value</em> of <code>*print-base*</code> is <code>10</code>. The initial <em>value</em> of <code>*print-radix*</code> is <em>false</em>. </p><p><code>*print-base*</code> and <code>*print-radix*</code> control the printing of <em>rationals</em>. The <em>value</em> of <code>*print-base*</code> is called the <em>current output base</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_bas.htm#STprint-radixST)", "*print-miser-width*": "<p>a non-negative <em>integer</em>, or <code>nil</code>. </p><p><em>implementation-dependent</em> </p><p>If it is not <code>nil</code>, the <em>pretty printer</em> switches to a compact style of output (called miser style) whenever the width available for printing a substructure is less than or equal to this many <em>ems</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_mis.htm#STprint-miser-widthST)", "*print-pretty*": "<p>a <em>generalized boolean</em>. </p><p><em>implementation-dependent</em>. </p><p>Controls whether the <em>Lisp printer</em> calls the <em>pretty printer</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_pre.htm#STprint-prettyST)", "*print-right-margin*": "<p>a non-negative <em>integer</em>, or <code>nil</code>. </p><p><code>nil</code>. </p><p>If it is <em>non-nil</em>, it specifies the right margin (as <em>integer</em> number of <em>ems</em>) to use when the <em>pretty printer</em> is making layout decisions. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_rig.htm#STprint-right-marginST)", "*query-io*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STquery-ioST)", "*print-readably*": "<p>a <em>generalized boolean</em>. </p><p><em>false</em>. </p><p>If <code>*print-readably*</code> is <em>true</em>, some special rules for printing <em>objects</em> go into effect. Specifically, printing any <em>object</em> O1 produces a printed representation that, when seen by the <em>Lisp reader</em> while the <em>standard readtable</em> is in effect, will produce an <em>object</em> O2 that is <em>similar</em> to O1. The printed representation produced might or might not be the same as the printed representation produced when <code>*print-readably*</code> is <em>false</em>. If printing an <em>object</em> <em>readably</em> is not possible, an error of <em>type</em> <code>print-not-readable</code> is signaled rather than using a syntax (e.g., the ``<code>#&lt;</code>'' syntax) that would not be readable by the same <em>implementation</em>. If the <em>value</em> of some other <em>printer control variable</em> is such that these requirements would be violated, the <em>value</em> of that other <em>variable</em> is ignored. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pr_rda.htm#STprint-readablyST)", "*read-base*": "<p>a <em>radix</em>. </p><p><code>10</code>. </p><p>Controls the interpretation of tokens by <code>read</code> as being <em>integers</em> or <em>ratios</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rd_bas.htm#STread-baseST)", "*random-state*": "<p>a <em>random state</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>current random state</em>, which is used, for example, by the <em>function</em> <code>random</code> when a <em>random state</em> is not explicitly supplied. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rnd_st.htm#STrandom-stateST)", "*read-default-float-format*": "<p>one of the <em>atomic type specifiers</em> <code>short-float</code>, <code>single-float</code>, <code>double-float</code>, or <code>long-float</code>, or else some other <em>type specifier</em> defined by the <em>implementation</em> to be acceptable. </p><p>The <em>symbol</em> <code>single-float</code>. </p><p>Controls the floating-point format that is to be used when reading a floating-point number that has no <em>exponent marker</em> or that has <code>e</code> or <code>E</code> for an <em>exponent marker</em>. Other <em>exponent markers</em> explicitly prescribe the floating-point format to be used. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rd_def.htm#STread-default-float-formatST)", "*read-suppress*": "<p>a <em>generalized boolean</em>. </p><p><em>false</em>. </p><p>This variable is intended primarily to support the operation of the read-time conditional notations <code>#+</code> and <code>#-</code>. It is important for the <em>reader macros</em> which implement these notations to be able to skip over the printed representation of an <em>expression</em> despite the possibility that the syntax of the skipped <em>expression</em> may not be entirely valid for the current implementation, since <code>#+</code> and <code>#-</code> exist in order to allow the same program to be shared among several Lisp implementations (including dialects other than Common Lisp) despite small incompatibilities of syntax. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rd_sup.htm#STread-suppressST)", "*readtable*": "<p>a <em>readtable</em>. </p><p>A <em>readtable</em> that conforms to the description of Common Lisp syntax in Section 2 (Syntax). </p><p>The <em>value</em> of <code>*readtable*</code> is called the <em>current readtable</em>. It controls the parsing behavior of the <em>Lisp reader</em>, and can also influence the <em>Lisp printer</em> (e.g., see the <em>function</em> <code>readtable-case</code>). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rdtabl.htm#STreadtableST)", "*read-eval*": "<p>a <em>generalized boolean</em>. </p><p><em>true</em>. </p><p>If it is <em>true</em>, the <code>#.</code> <em>reader macro</em> has its normal effect. Otherwise, that <em>reader macro</em> signals an error of <em>type</em> <code>reader-error</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_rd_eva.htm#STread-evalST)", "*standard-input*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STstandard-inputST)", "*terminal-io*": "<p>a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the <em>value</em> of some <em>I/O customization variable</em>. </p><p>The <em>value</em> of <code>*terminal-io*</code>, called <em>terminal I/O</em>, is ordinarily a <em>bidirectional</em> <em>stream</em> that connects to the user's console. Typically, writing to this <em>stream</em> would cause the output to appear on a display screen, for example, and reading from the <em>stream</em> would accept input from a keyboard. It is intended that standard input functions such as <code>read</code> and <code>read-char</code>, when used with this <em>stream</em>, cause echoing of the input into the output side of the <em>stream</em>. The means by which this is accomplished are <em>implementation-dependent</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_termin.htm#STterminal-ioST)", "//": "<p>a <em>proper list</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>/</code>, <code>//</code>, and <code>///</code> are maintained by the <em>Lisp read-eval-print loop</em> to save the values of results that were printed at the end of the loop. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_sl_sls.htm#SLSL)", "*trace-output*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STtrace-outputST)", "+++": "<p>an <em>object</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>+</code>, <code>++</code>, and <code>+++</code> are maintained by the <em>Lisp read-eval-print loop</em> to save <em>forms</em> that were recently <em>evaluated</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pl_plp.htm#PLPLPL)", "++": "<p>an <em>object</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>+</code>, <code>++</code>, and <code>+++</code> are maintained by the <em>Lisp read-eval-print loop</em> to save <em>forms</em> that were recently <em>evaluated</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_pl_plp.htm#PLPL)", "*standard-output*": "<p>For <code>*standard-input*</code>: an <em>input</em> <em>stream</em> </p><p>For <code>*error-output*</code>, <code>*standard-output*</code>, and <code>*trace-output*</code>: an <em>output</em> <em>stream</em>. </p><p>For <code>*debug-io*</code>, <code>*query-io*</code>: a <em>bidirectional</em> <em>stream</em>. </p><p><em>implementation-dependent</em>, but it must be an <em>open</em> <em>stream</em> that is not a <em>generalized synonym stream</em> to an <em>I/O customization variables</em> but that might be a <em>generalized synonym stream</em> to the value of some <em>I/O customization variable</em>. The initial value might also be a <em>generalized synonym stream</em> to either the <em>symbol</em> <code>*terminal-io*</code> or to the <em>stream</em> that is its <em>value</em>. </p><p>These <em>variables</em> are collectively called the <em>standardized</em> <em>I/O customization variables</em>. They can be <em>bound</em> or <em>assigned</em> in order to change the default destinations for input and/or output used by various <em>standardized</em> <em>operators</em> and facilities. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_debug_.htm#STstandard-outputST)", "///": "<p>a <em>proper list</em>. </p><p><em>implementation-dependent</em>. </p><p>The <em>variables</em> <code>/</code>, <code>//</code>, and <code>///</code> are maintained by the <em>Lisp read-eval-print loop</em> to save the values of results that were printed at the end of the loop. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_sl_sls.htm#SLSLSL)", "most-positive-single-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-positive-single-float)", "most-positive-short-float": "<p><em>implementation-dependent</em>. </p><p>These <em>constant variables</em> provide a way for programs to examine the <em>implementation-defined</em> limits for the various float formats. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_most_1.htm#most-positive-short-float)", "boole-orc1": "<p>The identity and nature of the <em>values</em> of each of these <em>variables</em> is <em>implementation-dependent</em>, except that it must be <em>distinct</em> from each of the <em>values</em> of the others, and it must be a valid first <em>argument</em> to the <em>function</em> <code>boole</code>. </p><p>Each of these <em>constants</em> has a <em>value</em> which is one of the sixteen possible <em>bit-wise logical operation specifiers</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/v_b_1_b.htm#boole-orc1)", "values": "```commonlisp\nvalues &rest object => object*\n(setf (values &rest place) new-values)\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p> <code>place</code> &mdash; a <em>place</em>. </p><p><code>new-value</code> &mdash; an <em>object</em>.  </p><p><code>values</code> returns the <em>objects</em> as <em>multiple values</em>[2]. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_values.htm#values)", "error": "<p><code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code> </p><p>The <em>type</em> <code>error</code> consists of all <em>conditions</em> that represent <em>errors</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_error.htm#error)", "t": "<p><code>t</code>. </p><p>The <em>boolean</em> representing true, and the canonical <em>generalized boolean</em> representing true. Although any <em>object</em> other than <code>nil</code> is considered <em>true</em>, <code>t</code> is generally used when there is no special reason to prefer one such <em>object</em> over another. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_t.htm#t)", "type": "```commonlisp\n(type typespec var*) \n(typespec var*) \n```\n\n<p><code>typespec</code> &mdash; a <em>type specifier</em>. </p><p><code>var</code> &mdash; a <em>variable</em> <em>name</em>. </p><p><em>declaration</em> or <em>proclamation</em> </p><p>Affects only variable <em>bindings</em> and specifies that the <em>vars</em> take on values only of the specified <em>typespec</em>. In particular, values assigned to the variables by <code>setq</code>, as well as the initial values of the <em>vars</em> must be of the specified <em>typespec</em>. <code>type</code> declarations never apply to function <em>bindings</em> (see <code>ftype</code>). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_type.htm#type)", "abort": "```commonlisp\nabort &optional condition =>| \ncontinue &optional condition => nil\nmuffle-warning &optional condition =>| \nstore-value value &optional condition => nil\nuse-value value &optional condition => nil\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p>  <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.   </p><p>Transfers control to the most recently established <em>applicable restart</em> having the same name as the function. That is, the <em>function</em> <code>abort</code> searches for an <em>applicable</em> <code>abort</code> <em>restart</em>, the <em>function</em> <code>continue</code> searches for an <em>applicable</em> <code>continue</code> <em>restart</em>, and so on. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_abort.htm#abort)", "continue": "```commonlisp\nabort &optional condition =>| \ncontinue &optional condition => nil\nmuffle-warning &optional condition =>| \nstore-value value &optional condition => nil\nuse-value value &optional condition => nil\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p>  <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.   </p><p>Transfers control to the most recently established <em>applicable restart</em> having the same name as the function. That is, the <em>function</em> <code>abort</code> searches for an <em>applicable</em> <code>abort</code> <em>restart</em>, the <em>function</em> <code>continue</code> searches for an <em>applicable</em> <code>continue</code> <em>restart</em>, and so on. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_contin.htm#continue)", "store-value": "```commonlisp\nabort &optional condition =>| \ncontinue &optional condition => nil\nmuffle-warning &optional condition =>| \nstore-value value &optional condition => nil\nuse-value value &optional condition => nil\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p>  <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.   </p><p>Transfers control to the most recently established <em>applicable restart</em> having the same name as the function. That is, the <em>function</em> <code>abort</code> searches for an <em>applicable</em> <code>abort</code> <em>restart</em>, the <em>function</em> <code>continue</code> searches for an <em>applicable</em> <code>continue</code> <em>restart</em>, and so on. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_store_.htm#store-value)", "logical-pathname": "```commonlisp\nlogical-pathname pathspec => logical-pathname\n```\n\n<p><code>pathspec</code> &mdash; a <em>logical pathname</em>, a <em>logical pathname</em> <em>namestring</em>, or a <em>stream</em>. </p><p><code>logical-pathname</code> &mdash; a <em>logical pathname</em>. </p><p><code>logical-pathname</code> converts <em>pathspec</em> to a <em>logical pathname</em> and returns the new <em>logical pathname</em>. If <em>pathspec</em> is a <em>logical pathname</em> <em>namestring</em>, it should contain a host component and its following <em>colon</em>. If <em>pathspec</em> is a <em>stream</em>, it should be one for which <code>pathname</code> returns a <em>logical pathname</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_logica.htm#logical-pathname)", "use-value": "```commonlisp\nabort &optional condition =>| \ncontinue &optional condition => nil\nmuffle-warning &optional condition =>| \nstore-value value &optional condition => nil\nuse-value value &optional condition => nil\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p>  <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.   </p><p>Transfers control to the most recently established <em>applicable restart</em> having the same name as the function. That is, the <em>function</em> <code>abort</code> searches for an <em>applicable</em> <code>abort</code> <em>restart</em>, the <em>function</em> <code>continue</code> searches for an <em>applicable</em> <code>continue</code> <em>restart</em>, and so on. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_use_va.htm#use-value)", "complex": "```commonlisp\ncomplex realpart &optional imagpart => complex\n```\n\n<p><code>realpart</code> &mdash; a <em>real</em>. </p><p><code>imagpart</code> &mdash; a <em>real</em>. </p><p><code>complex</code> &mdash; a <em>rational</em> or a <em>complex</em>. </p><p><code>complex</code> returns a <em>number</em> whose real part is <em>realpart</em> and whose imaginary part is <em>imagpart</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_comple.htm#complex)", "character": "```commonlisp\ncharacter character => denoted-character\n```\n\n<p> <code>character</code> &mdash; a <em>character designator</em>.  </p><p><code>denoted-character</code> &mdash; a <em>character</em>. </p><p>Returns the <em>character</em> denoted by the <em>character</em> <em>designator</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_ch.htm#character)", "muffle-warning": "```commonlisp\nabort &optional condition =>| \ncontinue &optional condition => nil\nmuffle-warning &optional condition =>| \nstore-value value &optional condition => nil\nuse-value value &optional condition => nil\n```\n\n<p><code>value</code> &mdash; an <em>object</em>. </p><p>  <code>condition</code> &mdash; a <em>condition</em> <em>object</em>, or <code>nil</code>.   </p><p>Transfers control to the most recently established <em>applicable restart</em> having the same name as the function. That is, the <em>function</em> <code>abort</code> searches for an <em>applicable</em> <code>abort</code> <em>restart</em>, the <em>function</em> <code>continue</code> searches for an <em>applicable</em> <code>continue</code> <em>restart</em>, and so on. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_muffle.htm#muffle-warning)", "float": "```commonlisp\nfloat number &optional prototype => float\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>prototype</code> &mdash; a <em>float</em>. </p><p><code>float</code> &mdash; a <em>float</em>. </p><p><code>float</code> converts a  <em>real</em>  number to a <em>float</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_float.htm#float)", "cons": "```commonlisp\ncons object-1 object-2 => cons\n```\n\n<p><code>object-1</code> &mdash; an <em>object</em>. </p><p><code>object-2</code> &mdash; an <em>object</em>. </p><p><code>cons</code> &mdash; a <em>cons</em>. </p><p>Creates a <em>fresh</em> <em>cons</em>, the <em>car</em> of which is <em>object-1</em> and the <em>cdr</em> of which is <em>object-2</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_cons.htm#cons)", "list": "```commonlisp\nlist &rest objects => list\nlist* &rest objects+ => result\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>list</em>. </p><p><code>result</code> &mdash; an <em>object</em>. </p><p><code>list</code> returns a <em>list</em> containing the supplied <em>objects</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_list.htm#list)", "null": "```commonlisp\nnull object => boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>boolean</code> &mdash; a <em>boolean</em>. </p><p>Returns <code>t</code> if <em>object</em> is the <em>empty list</em>; otherwise, returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_null.htm#null)", "pathname": "```commonlisp\npathname pathspec => pathname\n```\n\n<p> <code>pathspec</code> &mdash; a <em>pathname designator</em>.  </p><p><code>pathname</code> &mdash; a <em>pathname</em>. </p><p>Returns the <em>pathname</em> denoted by <em>pathspec</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_pn.htm#pathname)", "eql": "```commonlisp\neql x y => generalized-boolean\n```\n\n<p><code>x</code> &mdash; an <em>object</em>. </p><p><code>y</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>The value of <code>eql</code> is <em>true</em> of two objects, <em>x</em> and <em>y</em>, in the folowing cases: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_eql.htm#eql)", "string": "```commonlisp\nstring x => string\n```\n\n<p> <code>x</code> &mdash; a <em>string</em>, a <em>symbol</em>, or a <em>character</em>.  </p><p><code>string</code> &mdash; a <em>string</em>. </p><p>Returns a <em>string</em> described by <em>x</em>; specifically: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_string.htm#string)", "rational": "```commonlisp\nrational number => rational\nrationalize number => rational\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>rational</code> &mdash; a <em>rational</em>. </p><p><code>rational</code> and <code>rationalize</code> convert  <em>reals</em>  to <em>rationals</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_ration.htm#rational)", "vector": "```commonlisp\nvector &rest objects => vector\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>vector</code> &mdash; a <em>vector</em> of <em>type</em> <code>(vector t *)</code>. </p><p>Creates a <em>fresh</em> <em>simple general vector</em> whose size corresponds to the number of <em>objects</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_vector.htm#vector)", "mod": "```commonlisp\nmod number divisor => modulus\nrem number divisor => remainder\n```\n\n<p><code>number</code> &mdash; a <em>real</em>. </p><p><code>divisor</code> &mdash; a <em>real</em>. </p><p><code>modulus</code>, <code>remainder</code> &mdash; a <em>real</em>. </p><p><code>mod</code> and <code>rem</code> are generalizations of the modulus and remainder functions respectively. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_mod.htm#mod)", "member": "```commonlisp\nmember item list &key key test test-not => tail\nmember-if predicate list &key key => tail\nmember-if-not predicate list &key key => tail\n```\n\n<p><code>item</code> &mdash; an <em>object</em>. </p><p><code>list</code> &mdash; a <em>proper list</em>. </p><p><code>predicate</code> &mdash; a <em>designator</em> for a <em>function</em> of one <em>argument</em> that returns a <em>generalized boolean</em>. </p><p><code>test</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>test-not</code> &mdash; a <em>designator</em> for a <em>function</em> of two <em>arguments</em> that returns a <em>generalized boolean</em>. </p><p><code>key</code> &mdash; a <em>designator</em> for a <em>function</em> of one argument, or <code>nil</code>. </p><p><code>tail</code> &mdash; a <em>list</em>. </p><p><code>member</code>, <code>member-if</code>, and <code>member-if-not</code> each search <em>list</em> for <em>item</em> or for a top-level element that <em>satisfies the test</em>. The argument to the <em>predicate</em> function is an element of <em>list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_member.htm#member)", "not": "```commonlisp\nnot x => boolean\n```\n\n<p><code>x</code> &mdash; a <em>generalized boolean</em> (i.e., any <em>object</em>). </p><p><code>boolean</code> &mdash; a <em>boolean</em>. </p><p>Returns <code>t</code> if <em>x</em> is <em>false</em>; otherwise, returns <code>nil</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_not.htm#not)", "-": "```commonlisp\n- number => negation\n- minuend &rest subtrahends+ => difference\n```\n\n<p><code>number</code>, <code>minuend</code>, <code>subtrahend</code> &mdash; a <em>number</em>. </p><p><code>negation</code>, <code>difference</code> &mdash; a <em>number</em>. </p><p>The <em>function</em> <code>-</code> performs arithmetic subtraction and negation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a__.htm#-)", "*": "```commonlisp\n* &rest numbers => product\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>product</code> &mdash; a <em>number</em>. </p><p>Returns the product of <em>numbers</em>, performing any necessary type conversions in the process. If no <em>numbers</em> are supplied, <code>1</code> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_st.htm#ST)", "atom": "```commonlisp\natom object => generalized-boolean\n```\n\n<p><code>object</code> &mdash; an <em>object</em>. </p><p><code>generalized-boolean</code> &mdash; a <em>generalized boolean</em>. </p><p>Returns <em>true</em> if <em>object</em> is of <em>type</em> <code>atom</code>; otherwise, returns <em>false</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_atom.htm#atom)", "+": "```commonlisp\n+ &rest numbers => sum\n```\n\n<p><code>number</code> &mdash; a <em>number</em>. </p><p><code>sum</code> &mdash; a <em>number</em>. </p><p>Returns the sum of <em>numbers</em>, performing any necessary type conversions in the process. If no <em>numbers</em> are supplied, <code>0</code> is returned. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_pl.htm#PL)", "/": "```commonlisp\n/ number => reciprocal\n/ numerator &rest denominators+ => quotient\n```\n\n<p><code>number</code>, <code>denominator</code> &mdash; a non-zero <em>number</em>. </p><p><code>numerator</code>, <code>quotient</code>, <code>reciprocal</code> &mdash; a <em>number</em>. </p><p>The <em>function</em> <code>/</code> performs division or reciprocation. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_sl.htm#SL)", "lambda": "```commonlisp\nlambda lambda-list [[declaration* | documentation]] form* => function\n```\n\n<p><code>lambda-list</code> &mdash; an <em>ordinary lambda list</em>. </p><p><code>declaration</code> &mdash; a <code>declare</code> <em>expression</em>; not evaluated. </p><p><code>documentation</code> &mdash; a <em>string</em>; not evaluated. </p><p><code>form</code> &mdash; a <em>form</em>. </p><p><code>function</code> &mdash; a <em>function</em>. </p><p>Provides a shorthand notation for a <code>function</code> <em>special form</em> involving a <em>lambda expression</em> such that: </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_lambda.htm#lambda)", "setf": "```commonlisp\nsetf {pair}* => result*\npsetf {pair}* => nil\npair::= place newvalue \n\n```\n\n<p><code>place</code> &mdash; a <em>place</em>. </p><p><code>newvalue</code> &mdash; a <em>form</em>. </p><p> <code>results</code> &mdash; the <em>multiple values</em>[2] returned by the storing form for the last <em>place</em>, or <code>nil</code> if there are no <em>pairs</em>.  </p><p><code>setf</code> changes the <em>value</em> of <em>place</em> to be <em>newvalue</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_setf.htm#setf)", "or": "```commonlisp\nor form* => results*\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> or <em>primary value</em> (see below) resulting from the evaluation of the last <em>form</em> executed or <code>nil</code>. </p><p><code>or</code> evaluates each <em>form</em>, one at a time, from left to right. The evaluation of all <em>forms</em> terminates when a <em>form</em> evaluates to <em>true</em> (i.e., something other than <code>nil</code>). </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_or.htm#or)", "bit": "```commonlisp\nbit bit-array &rest subscripts => bit\nsbit bit-array &rest subscripts => bit\n(setf (bit bit-array &rest subscripts) new-bit)\n(setf (sbit bit-array &rest subscripts) new-bit)\n```\n\n<p><code>bit-array</code> &mdash; for <code>bit</code>, a <em>bit array</em>; for <code>sbit</code>, a <em>simple bit array</em>. </p><p><code>subscripts</code> &mdash; a <em>list</em> of <em>valid array indices</em> for the <em>bit-array</em>. </p><p><code>bit</code> &mdash; a <em>bit</em>. </p><p><code>bit</code> and <code>sbit</code> <em>access</em> the <em>bit-array</em> <em>element</em> specified by <em>subscripts</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_bit.htm#bit)", "function": "```commonlisp\nfunction name => function\n```\n\n<p><code>name</code> &mdash; a <em>function name</em> or <em>lambda expression</em>. </p><p><code>function</code> &mdash; a <em>function</em> <em>object</em>. </p><p>The <em>value</em> of <code>function</code> is the <em>functional value</em> of <em>name</em> in the current <em>lexical environment</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_fn.htm#function)", "nil": "<p><code>nil</code>. </p><p><code>nil</code> represents both <em>boolean</em> (and <em>generalized boolean</em>) <em>false</em> and the <em>empty list</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_nil.htm#nil)", "and": "```commonlisp\nand form* => result*\n```\n\n<p><code>form</code> &mdash; a <em>form</em>. </p><p><code>results</code> &mdash; the <em>values</em> resulting from the evaluation of the last <em>form</em>, or the symbols <code>nil</code> or <code>t</code>. </p><p>The macro <code>and</code> evaluates each <em>form</em> one at a time from left to right. As soon as any <em>form</em> evaluates to <code>nil</code>, <code>and</code> returns <code>nil</code> without evaluating the remaining <em>forms</em>. If all <em>forms</em> but the last evaluate to <em>true</em> values, <code>and</code> returns the results produced by evaluating the last <em>form</em>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_and.htm#and)", "declare": "```commonlisp\ndeclare declaration-specifier*\n```\n\n<p><code>declaration-specifier</code> &mdash; a <em>declaration specifier</em>; not evaluated. </p><p>A <code>declare</code> <em>expression</em></a>, sometimes called a <em>declaration</em></a>, can occur only at the beginning of the bodies of certain <em>forms</em></a>; that is, it may be preceded only by other <code>declare</code></a> <em>expressions</em></a>, or by a <em>documentation string</em></a> if the context permits. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/s_declar.htm#declare)", "method-combination": "\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/a_method.htm#method-combination)", "satisfies": "```commonlisp\nsatisfies predicate-name\n```\n\n<p><code>predicate-name</code> &mdash; a <em>symbol</em>. </p><p>This denotes the set of all <em>objects</em> that satisfy the <em>predicate</em></a> <em>predicate-name</em>, which must be a <em>symbol</em></a> whose global <em>function</em></a> definition is a one-argument predicate. A name is required for <em>predicate-name</em>; <em>lambda expressions</em></a> are not allowed. For example, the <em>type specifier</em></a> <code>(and integer (satisfies evenp))</code> denotes the set of all even integers. The form <code>(typep </code><em>x</em><code> '(satisfies </code><em>p</em><code>))</code> is equivalent to <code>(if (</code><em>p</em><code> </code><em>x</em><code>) t nil)</code>. </p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/t_satisf.htm#satisfies)", "&body": "```commonlisp\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\n```\n\n<p>A <em>macro lambda list</em> is used in describing <em>macros</em></a> defined by the <em>operators</em></a> in the next figure. <pre>define-compiler-macro  defmacro</a>  macrolet</a>  <br/>define-setf-expander</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_dd.htm#AMbody)", "&environment": "```commonlisp\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\n```\n\n<p>A <em>macro lambda list</em> is used in describing <em>macros</em></a> defined by the <em>operators</em></a> in the next figure. <pre>define-compiler-macro  defmacro</a>  macrolet</a>  <br/>define-setf-expander</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_dd.htm#AMenvironment)", "&whole": "```commonlisp\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\nreqvars::= var* \noptvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] \nrestvar::= [{&rest | &body} var] \nkeyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* \n            [&allow-other-keys]] \nauxvars::= [&aux {var | (var [init-form])}*] \nenvvar::= [&environment var] \nwholevar::= [&whole var] \nlambda-list::= (wholevar envvar  reqvars envvar  optvars envvar \n                restvar envvar  keyvars envvar  auxvars envvar) | \n               (wholevar envvar  reqvars envvar  optvars envvar .  var) \npattern::= (wholevar reqvars optvars restvar keyvars auxvars) | \n           (wholevar reqvars optvars . var) \n\n```\n\n<p>A <em>macro lambda list</em> is used in describing <em>macros</em></a> defined by the <em>operators</em></a> in the next figure. <pre>define-compiler-macro  defmacro</a>  macrolet</a>  <br/>define-setf-expander</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_dd.htm#AMwhole)", "&allow-other-keys": "```commonlisp\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\n```\n\n<p>An <em>ordinary lambda list</em> is used to describe how a set of <em>arguments</em></a> is received by an <em>ordinary</em> <em>function</em></a>. The <em>defined names</em></a> in the next figure are those which use <em>ordinary lambda lists</em></a>: <pre>define-method-combination  handler-case</a>  restart-case</a>  <br/>defun</a>  labels</a>  <br/>flet</a>  lambda</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_da.htm#AMallow-other-keys)", "&aux": "```commonlisp\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\n```\n\n<p>An <em>ordinary lambda list</em> is used to describe how a set of <em>arguments</em></a> is received by an <em>ordinary</em> <em>function</em></a>. The <em>defined names</em></a> in the next figure are those which use <em>ordinary lambda lists</em></a>: <pre>define-method-combination  handler-case</a>  restart-case</a>  <br/>defun</a>  labels</a>  <br/>flet</a>  lambda</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_da.htm#AMaux)", "&key": "```commonlisp\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\n```\n\n<p>An <em>ordinary lambda list</em> is used to describe how a set of <em>arguments</em></a> is received by an <em>ordinary</em> <em>function</em></a>. The <em>defined names</em></a> in the next figure are those which use <em>ordinary lambda lists</em></a>: <pre>define-method-combination  handler-case</a>  restart-case</a>  <br/>defun</a>  labels</a>  <br/>flet</a>  lambda</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_da.htm#AMkey)", "&optional": "```commonlisp\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\n```\n\n<p>An <em>ordinary lambda list</em> is used to describe how a set of <em>arguments</em></a> is received by an <em>ordinary</em> <em>function</em></a>. The <em>defined names</em></a> in the next figure are those which use <em>ordinary lambda lists</em></a>: <pre>define-method-combination  handler-case</a>  restart-case</a>  <br/>defun</a>  labels</a>  <br/>flet</a>  lambda</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_da.htm#AMoptional)", "&rest": "```commonlisp\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\nlambda-list::= (var* \n                [&optional {var | (var [init-form [supplied-p-parameter]])}*] \n                [&rest var] \n                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] \n                [&aux {var | (var [init-form])}*]) \n\n```\n\n<p>An <em>ordinary lambda list</em> is used to describe how a set of <em>arguments</em></a> is received by an <em>ordinary</em> <em>function</em></a>. The <em>defined names</em></a> in the next figure are those which use <em>ordinary lambda lists</em></a>: <pre>define-method-combination  handler-case</a>  restart-case</a>  <br/>defun</a>  labels</a>  <br/>flet</a>  lambda</a>  <br/></pre></p>\n\n[[Docs]](https://www.lispworks.com/documentation/lw50/CLHS/Body/03_da.htm#AMrest)"}